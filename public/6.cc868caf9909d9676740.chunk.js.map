{"version":3,"sources":["webpack:///./src/helpers/cleanUsername.ts","webpack:///./src/lib/appManagers/appUsersManager.ts","webpack:///./src/lib/appManagers/appPeersManager.ts","webpack:///./src/lib/storages/dialogs.ts","webpack:///./src/lib/storages/filters.ts","webpack:///./src/lib/appManagers/appMessagesManager.ts","webpack:///./src/helpers/string/splitStringByLength.ts","webpack:///./src/lib/appManagers/appChatsManager.ts","webpack:///./src/components/peerTitle.ts","webpack:///./src/helpers/bytes/bytesFromHex.ts","webpack:///./src/lib/appManagers/appPhotosManager.ts","webpack:///./src/helpers/bytes/bytesToDataURL.ts","webpack:///./src/lib/appManagers/appProfileManager.ts","webpack:///./src/lib/appManagers/apiUpdatesManager.ts","webpack:///./src/lib/appManagers/appStickersManager.ts","webpack:///./src/lib/appManagers/appDocsManager.ts","webpack:///./src/lib/mtproto/serverTimeManager.ts","webpack:///./src/helpers/assumeType.ts","webpack:///./src/helpers/schedulers/debounce.ts","webpack:///./src/components/visibilityIntersector.ts","webpack:///./src/helpers/array/findAndSpliceAll.ts","webpack:///./src/components/lazyLoadQueue.ts","webpack:///./src/lib/appManagers/appMessagesIdsManager.ts","webpack:///./src/helpers/dom/renderImageFromUrl.ts","webpack:///./src/helpers/windowSize.ts","webpack:///./src/helpers/callbackifyAll.ts","webpack:///./src/lib/appManagers/appReactionsManager.ts","webpack:///./src/helpers/dom/htmlToSpan.ts","webpack:///./src/lib/appManagers/appNotificationsManager.ts","webpack:///./src/helpers/files.ts","webpack:///./src/helpers/middleware.ts","webpack:///./src/helpers/fixBase64String.ts","webpack:///./src/helpers/formatPhoneNumber.ts","webpack:///./src/helpers/object/safeReplaceObject.ts","webpack:///./src/components/preloader.ts","webpack:///./src/lib/appManagers/appAvatarsManager.ts","webpack:///./src/lib/calls/groupCallState.ts","webpack:///./src/helpers/callbackify.ts","webpack:///./src/helpers/string/limitSymbols.ts","webpack:///./src/lib/appManagers/appDraftsManager.ts","webpack:///./src/lib/calls/localConferenceDescription.ts","webpack:///./src/lib/searchIndex.ts","webpack:///./src/helpers/array/flatten.ts","webpack:///./src/helpers/canvas/getTextWidth.ts","webpack:///./src/components/middleEllipsis.ts","webpack:///./src/lib/appManagers/appGroupCallsManager.ts","webpack:///./src/lib/calls/helpers/createMainStreamManager.ts","webpack:///./src/helpers/array/insertInDescendSortedArray.ts","webpack:///./src/lib/appManagers/appPollsManager.ts","webpack:///./src/lib/calls/helpers/stopTrack.ts","webpack:///./src/lib/calls/streamManager.ts","webpack:///./src/lib/calls/utils.ts","webpack:///./src/helpers/object/getObjectKeysAndSort.ts","webpack:///./src/helpers/slicedArray.ts","webpack:///./src/helpers/compareValue.ts","webpack:///./src/helpers/long/compareLong.ts","webpack:///./src/helpers/heavyQueue.ts","webpack:///./src/environment/canvasFilterSupport.ts","webpack:///./src/helpers/blur.ts","webpack:///./src/config/latinizeMap.ts","webpack:///./src/helpers/cleanSearchText.ts","webpack:///./src/helpers/number/numberThousandSplitter.ts","webpack:///./src/helpers/array/filterUnique.ts","webpack:///./src/lib/appManagers/appWebPagesManager.ts","webpack:///./src/helpers/dom/htmlToDocumentFragment.ts","webpack:///./src/lib/calls/helpers/getStream.ts","webpack:///./src/lib/calls/helpers/getVideoConstraints.ts","webpack:///./src/lib/calls/constants.ts","webpack:///./src/lib/calls/sdpBuilder.ts","webpack:///./src/lib/calls/sdp/index.ts","webpack:///./src/helpers/string/splitStringByLimitWithRest.ts","webpack:///./src/helpers/uniqueNumberGenerator.ts","webpack:///./src/lib/calls/sdp/attributeSplitted.ts","webpack:///./src/lib/calls/sdp/mediaLineParts.ts","webpack:///./src/lib/calls/sdp/line.ts","webpack:///./src/lib/calls/sdp/attributeInner.ts","webpack:///./src/lib/calls/sdp/attributes.ts","webpack:///./src/lib/calls/sdp/mediaSection.ts","webpack:///./src/lib/calls/sdp/sessionSection.ts","webpack:///./src/lib/calls/sdp/utils.ts","webpack:///./src/helpers/bytes/bytesToHex.ts","webpack:///./src/lib/mtproto/referenceDatabase.ts","webpack:///./src/lib/calls/helpers/parseMediaSectionInfo.ts","webpack:///./src/lib/calls/helpers/parseSourceGroups.ts","webpack:///./src/environment/vibrateSupport.ts","webpack:///./src/helpers/string/convertInputKeyToKey.ts","webpack:///./src/helpers/object/defineNotNumerableProperties.ts","webpack:///./src/lib/opusDecodeController.ts","webpack:///./src/environment/webmSupport.ts","webpack:///./src/helpers/object/safeReplaceArrayInObject.ts","webpack:///./src/environment/imageMimeTypesSupport.ts","webpack:///./src/helpers/audioAssetPlayer.ts","webpack:///./src/lib/calls/helpers/getScreenConstraints.ts","webpack:///./src/lib/calls/helpers/getScreenStream.ts","webpack:///./src/lib/calls/stringFromLineBuilder.ts","webpack:///./src/helpers/string/escapeRegExp.ts","webpack:///./src/lib/calls/groupCallConnectionInstance.ts","webpack:///./src/lib/calls/helpers/processMediaSection.ts","webpack:///./src/lib/calls/helpers/filterServerCodecs.ts","webpack:///./src/lib/calls/helpers/fixLocalOffer.ts","webpack:///./src/lib/calls/groupCallInstance.ts","webpack:///./src/lib/calls/callConnectionInstanceBase.ts","webpack:///./src/lib/calls/helpers/createPeerConnection.ts","webpack:///./src/lib/calls/helpers/createDataChannel.ts","webpack:///./src/helpers/formatCallDuration.ts","webpack:///./src/helpers/formatDuration.ts","webpack:///./src/environment/movSupport.ts","webpack:///./src/environment/videoMimeTypesSupport.ts","webpack:///./src/lib/calls/helpers/getStreamCached.ts","webpack:///./src/lib/calls/callInstanceBase.ts","webpack:///./src/lib/calls/helpers/getAudioConstraints.ts","webpack:///./src/environment/constraintSupport.ts"],"names":["cleanUsername","username","toLowerCase","appUsersManager","storage","appStateManager","storages","users","updateUsersStatuses","timestampNow","i","this","user","updateUserStatus","clear","setInterval","rootScope","addEventListener","addMultipleEventsListeners","update","userId","user_id","status","expires","serverTimeManager","serverTimeOffset","was_online","dispatchEvent","setUserToStateIfNeeded","updateUserPhoto","photo","photo_id","forceUserOnline","date","_","safeReplaceObject","toPeerId","console","warn","updateUserName","saveApiUser","first_name","last_name","e","getSelf","id","contactsIndex","indexObject","getUserSearchText","getState","then","state","storagesResults","length","setUserNameToCache","contactsList","Array","isArray","forEach","pushContact","contactsFillPromise","resolve","peerId","appPeersManager","isUser","toUserId","getFromCache","set","getUser","delete","init","usernames","isPeerNeeded","findAndSplice","getTopPeersPromises","createSearchIndex","undefined","Set","updatedContactsList","pushToState","cached","isFulfilled","promise","invokeApi","result","saveApiUsers","contacts","contact","onContactsModified","slice","Promise","resolvedPeer","processResolvedPeer","appChatsManager","saveApiChats","chats","getPeer","getPeerId","peer","phone","add","requestPeerSingle","releaseSinglePeer","pFlags","self","format","filter","Boolean","join","query","includeSaved","sortBy","fillContacts","_contactsList","results","search","has","sort","userId1","userId2","sortName1","sortName","sortName2","localeCompare","status1","getUserStatusForSort","myUserId","myId","indexOfAndSplice","testSelfSearch","unshift","getContacts","userIds","map","block","invokeApiSingle","getInputPeerById","value","apiUpdatesManager","processLocalUpdate","peer_id","getOutputPeer","blocked","index","clearBadChars","ignoreCase","latinize","includeTag","apiUsers","override","saved","oldUser","oldSearchUsername","searchUsername","min","fullName","deleted","cleanSearchText","changedPhoto","changedTitle","wasContact","newContact","onContactUpdated","formatPhoneNumber","formatted","isObject","access_hash","key","args","isBot","support","today","Date","diff","getTime","getDate","dateEl","timeEl","bot","isRegularUser","isContact","allowMin","phone_number","vcard","eventTimestamp","timestamp","updatesState","syncLoading","importContacts","phones","error","Error","type","inputContacts","j","push","client_id","toString","importedContactsResult","imported","importedContact","topPeersCache","cachedTime","now","peers","offset","limit","hash","topPeers","categories","topPeer","requestPeer","rating","contactsBlocked","count","peerIds","u","concat","c","lat","long","accuracy_radius","background","self_expires","geo_point","updates","processUpdateMessage","entities","parseEntities","trim","path","URL","wrapUrl","url","pathname","err","invokeApiCacheable","q","cacheSeconds","my_results","filterUnique","p","curIsContact","popContact","offline","showPhone","getUserInput","add_phone_privacy_exception","restrictionReasons","restriction_reason","restricted","DialogColorsFg","DialogColors","DialogColorsMap","newMethod","originMethod","String","prototype","Number","hasRights","toChatId","isRestricted","getUserPhoto","getChatPhoto","chat","getChat","migrated_to","deactivated","plainText","onlyFirstName","_limitSymbols","title","split","wrapEmojiText","chatId","isChannel","channel_id","chat_id","getUserString","getChatString","getAbbreviation","isPeerId","charAt","peerParams","substr","isMegagroup","isBroadcast","reason","text","ignorePeerId","getInputPeer","getUserInputPeer","pic","idx","Math","abs","getDialogType","getChatTyped","noforwards","appMessagesManager","appDraftsManager","appNotificationsManager","appMessagesIdsManager","folders","onUpdateFolderPeers","folder_peers","folderPeer","folder_id","dialog","dropDialog","pinned","handleDialogUnpinning","generateIndexForDialog","pushDialog","scheduleHandleNewDialogs","onUpdateDialogPinned","folderId","getDialogOnly","onUpdatePinnedDialogs","handleOrder","order","pinnedOrders","reverse","newPinned","dialogs","getFolderDialogs","dialogsResult","applyDialogs","d","getCache","peerText","getPeerSearchText","dialogsIndex","onFilterUpdate","getCachedDialogs","processDialogForFilter","filterId","processDialogForFilters","indexKey","orderIndex","left","dropDialogOnDeletion","updateFolderPeers","updateDialogPinned","updatePinnedDialogs","freezeSaving","setDialogsFromState","bind","allDialogsLoaded","top_message","getServerMessageId","topMessage","saveMessages","saveDialog","getMessageByPeer","reloadConversation","loaded","0","1","setDialogsLoaded","savePinnedOrders","dialogsOffsetDate","dialogsNum","cachedResults","offsetDate","getOffsetDate","unreadMessagesCount","unreadDialogsCount","skipMigrated","folder","getFolder","migratedTo","filtersStorage","testDialogForFilter","pinnedIndex","pinnedPeerIds","indexOf","generateDialogIndex","generateDialogPinnedDateByIndex","pinned_peers","skipped","isPinned","filters","getDialogIndexKey","wasIndex","findIndex","wasDialog","wasDialogIndex","newDialogIndex","setDialogIndexInFilter","prepareFolderUnreadCountModifyingByDialog","splice","insertInDescendSortedArray","callbacks","callback","toggle","wasUnreadCount","getDialogUnreadCount","newUnreadCount","addMessagesCount","addDialogsCount","modifyFolderUnreadCount","max","dispatchUnreadTimeout","ctx","setTimeout","justReturn","message","topDate","generateDialogPinnedDate","channelId","channel","draft","foundIndex","pts","historyStorage","getHistoryStorage","messagesStorage","getMessagesStorage","history","incomingMessage","mid","getMessageFromStorage","is_outgoing","fromId","viaBotId","isAnyChat","newPts","getChannelState","ignoreOffsetDate","saveGlobalOffset","pos","setDialogToState","getDialogOffsetDate","savedGlobalOffsetDate","savedOffsetDate","isDialogsLoaded","clearDialogFromState","foundDialog","getDialog","wasPinned","keepLocal","dropped","dropDialogWithEvent","forEachReverse","messages","updatedDialogs","topPendingMessage","pendingTopMsgs","maxId","newUpdatesAfterReloadToHandle","saveUpdate","size","Object","keys","assign","wasDialogBefore","generateMessageId","wasTopMessage","generateTempMessageId","from_id","out","isOutgoing","log","migratedToPeer","migratedFromTo","migratedToFrom","read_inbox_max_id","read_outbox_max_id","saveDraft","isOut","unread","unread_count","isEnd","Bottom","insertSlice","setEnd","mergeReplyKeyboard","readMaxId","readOutboxMaxId","savePeerSettings","settings","notify_settings","addChannelState","defineNotNumerableProperties","getFilter","offsetIndex","ret","promises","fillContactsResult","reloadMissingDialogsPromise","reloadMissingPeerIds","all","getDialogs","realFolderId","curDialogStorage","indexStr","d1","d2","loadedAll","isEnoughDialogs","isTopEnd","getTopMessages","convertment","onUpdateDialogFilter","saveDialogFilter","onUpdateDialogFilterOrder","setOrderIndex","hasOwnProperty","updateDialogFilter","updateDialogFilters","oldFilters","copy","getDialogFilters","_filterId","find","updateDialogFilterOrder","reloadedPeerIds","excludePeerIds","includes","includePeerIds","exclude_archived","exclude_read","isDialogUnread","exclude_muted","isPeerLocalMuted","unread_mentions_count","broadcasts","groups","isAnyGroup","bots","non_contacts","config","pinned_infolder_count_max","reject","prepend","remove","flags","getOutputDialogFilter","bool","f","a","b","filterIncludedPinnedPeers","include_peers","reloadDialogs","inputPeer","isAlreadyReloaded","reloadPromises","missingPeerIds","overwrite","from","to","oldFilter","pendingByRandomId","pendingByMessageId","pendingAfterMsgs","tempFinalizeCallbacks","sendSmthLazyLoadQueue","needSingleMessages","Map","fetchSingleMessagesPromise","maxSeenId","newMessagesHandleTimeout","newMessagesToHandle","newDialogsToHandle","notificationsHandlePromise","notificationsToHandle","reloadConversationsPeers","logger","Debug","Log","Warn","groupedTempId","typings","unreadMentions","goToNextMentionPromises","batchUpdates","handleNewMessages","clearTimeout","handleNewDialogs","newMaxSeenId","obj","dialogsStorage","incrementMaxSeenId","handleNotifications","window","_peerId","idle","isIDLE","notifyPeerToHandle","getNotifyPeerSettings","muted","peerTypeNotifySettings","mentioned","notifyAboutMessage","fwdCount","onUpdateMessageId","randomId","random_id","pendingData","tempId","threadId","finalizePendingMessageCallbacks","onUpdateNewMessage","getMessagePeer","isLocalThreadUpdate","threadKey","getThreadKey","threadsStorage","good","isInChat","ignoreExisting","pendingMessage","checkPendingMessage","updateMessageRepliesIfNeeded","findSlice","firstSlice","first","action","top_msg_id","handleNewMessage","inboxUnread","releaseUnreadCount","prepareDialogUnreadCountModifying","modifyCachedMentions","setDialogTopMessage","notifyPeer","fwd_from","onUpdateMessageReactions","msg_id","reactions","recentReactions","recent_reactions","recentReaction","previousReactions","previousRecentReactions","deepEqual","show_previews","peerReaction","pushBatchUpdate","batchUpdateReactions","local","setDialogToStateIfMessageIsTop","onUpdateDialogUnreadMark","unread_mark","onUpdateEditMessage","oldMessage","newMessage","handleEditedMessage","isTopMessage","clear_history","newReactions","grouped_id","onUpdateReadHistory","max_id","read_max_id","getObjectKeysAndSort","stillUnreadCount","still_unread_count","newUnreadMentionsCount","foundAffected","repliesKey","threadsToReplies","updateMessage","get","replyTo","reply_to","reply_to_top_id","reply_to_msg_id","cancel","setCount","getReadMaxIdIfUnread","threadKeyPart","onUpdateReadMessagesContents","mids","getMessageById","fixDialogUnreadMentionsIfNoMessage","media_unread","onUpdateChannelAvailableMessages","availableMinId","available_min_id","onUpdateDeleteMessages","clearCache","params","threadKeys","historyUpdated","handleDeletedMessages","threadsStorages","msgs","affected","onUpdateChannel","needDialog","historiesStorage","onUpdateChannelReload","onUpdateChannelMessageViews","views","batchUpdateViews","onUpdateServiceNotification","popup","messageId","inbox_date","media","hasUser","verified","pts_count","onUpdatePinnedMessages","missingMessages","wrapSingleMessage","finally","werePinned","pinnedMessages","hiddenPinnedMessages","onUpdateNotifySettings","onUpdateNewScheduledMessage","scheduledMessagesStorage","isScheduled","onUpdateDeleteScheduledMessages","batch","toDispatch","getMessagesFromMap","previousResults","changedResults","reactionCount","previousReactionCount","_reactionCount","reaction","chosen","updateMessageID","updateNewDiscussionMessage","updateNewMessage","updateNewChannelMessage","updateDialogUnreadMark","updateEditMessage","updateEditChannelMessage","updateMessageReactions","updateReadChannelDiscussionInbox","updateReadChannelDiscussionOutbox","updateReadHistoryInbox","updateReadHistoryOutbox","updateReadChannelInbox","updateReadChannelOutbox","updateChannelReadMessagesContents","updateReadMessagesContents","updateChannelAvailableMessages","updateDeleteMessages","updateDeleteChannelMessages","updateChannel","updateChannelReload","updateChannelMessageViews","updateServiceNotification","updatePinnedMessages","updatePinnedChannelMessages","updateNotifySettings","updateNewScheduledMessage","updateDeleteScheduledMessages","filterFunc","getScheduledMessagesStorage","webpage","appWebPagesManager","getWebPage","drop","poll","appPollsManager","pollToMessages","maxSeenMsgId","batchUpdatesDebounced","debounce","event","details","middleware","clean","messagesStorageByPeerId","groupedMessagesStorage","searchesStorage","threadsServiceMessagesIdsStorage","sendEntites","entity","callbackName","finalize","deferred","options","invokeAfterMessageIsSent","editMessage","parseMarkdown","schedule_date","scheduleDate","is_scheduled","newMedia","getInputEntities","no_webpage","noWebPage","handled","replyToMsgId","MAX_LENGTH","message_length_max","splitted","splitStringByLength","str","maxLength","lastSliceStartIndex","arrayIndex","cut","end","part","_arrayIndex","lastIndex","partLength","webPage","sendText","getPeerMigratedTo","generateOutgoingMessage","toggleError","on","send","sentRequestOptions","afterMessageId","sendAs","sendAsPeerId","apiPromise","invokeApiAfter","query_id","queryId","resultId","clear_draft","clearDraft","send_as","silent","wrapMessageEntities","seq","beforeMessageSending","file","attachType","apiFileName","fileType","mime_type","fileName","File","name","isDocument","Blob","caption","attributes","isPhoto","document","actionName","isVoiceMessage","attribute","voice","waveform","duration","isMedia","photoSize","w","width","h","height","location","sizes","cacheContext","appDownloadManager","getCacheContext","downloaded","objectURL","appPhotosManager","savePhoto","videoAttribute","round_message","isRoundMessage","supports_streaming","noSound","file_name","thumbs","thumb","blob","thumbCacheContext","appDocsManager","saveDoc","preloader","attachMethod","tryAgainOnFail","isUpload","sentDeferred","attachPromise","catch","uploaded","cancelPendingMessage","setTyping","uploadPromise","file_reference","inputMedia","load","thumbUploadPromise","upload","notifyAll","done","total","inputFile","force_file","addNotifyListener","progress","percents","floor","isGroupedItem","code","files","sendFile","sendFileDetails","groupId","o","invoke","multiMedia","multi_media","messageMedia","getMediaInput","doc","inputSingleMedia","inputs","contactPeerId","sendOther","getContactMediaInput","pollId","savePoll","total_voters","recent_voters","getPoll","getPhoto","getDoc","geo","geoPoint","address","provider","venue_id","venue_type","postAuthor","signatures","generateFromId","post_author","generateFlags","random","generateReplyHeader","via_bot_id","reply_markup","replyMarkup","replies","generateReplies","pending","replyToTopId","header","channelFull","appProfileManager","getCachedFullChat","linked_chat_id","comments","replies_pts","isAnonymousSending","post","originalMessage","fwdHeader","isUserHidden","from_name","userFull","getCachedFullUser","private_forward_name","channel_post","saved_from_msg_id","saved_from_peer","MAX_SAFE_INTEGER","admin_rights","anonymous","chatHistoryStorage","offset_date","offset_id","offset_peer","offsetPeerId","noErrorBox","resetPinnedOrder","telegramMeWebManager","setAuthorized","maxSeenIdIncremented","hasPrepend","noIdsDialogs","setFolderId","folderDialogs","dialogsLength","slicedDialogs","fromPeerId","dropCaptions","dropAuthor","newMids","newMessages","generateForwardHeader","replyToMid","replyToMessageIdx","newReplyToMid","group","from_peer","to_peer","with_my_score","withMyScore","drop_author","drop_media_captions","generateEmptyMessage","createMessageStorage","inputDialogPeer","getInputDialogPeerById","reloadConversationsPromise","inputDialogPeers","fullfillLeft","just_clear","revoke","affectedHistory","doFlushHistory","justClear","getHistory","historyResult","getChannelInput","s","m","ss","getPinnedMessage","getSearch","inputFilter","unpin","pm_oneside","unpinAll","unpinAllMessages","totalEntities","foundMessages","minMid","getMidsByAlbum","verify","isMessage","reply_to_mid","overwriting","msgId","savedFromPeerId","savedFromMid","savedFrom","fwdFromId","mediaContext","unsupported","ttl_seconds","originalDoc","messageKey","getMessageKeyForPendingWebPage","saveWebPage","migrateFrom","migrateTo","suffix","video_sizes","appGroupCallsManager","saveGroupCall","call","video","migrateChecks","saveMessage","apiEntities","fixEmoji","myEntities","mergeEntities","usingMids","plain","highlightWord","withoutMediaType","parts","hasAlbumKey","addPart","langKey","el","createElement","innerHTML","append","assumeType","usingFullAlbum","getMidsByMessage","albumText","getAlbumText","emoticon","question","game","stickerEmojiRaw","span","performer","actionWrapped","wrapMessageActionTextNew","limitSymbols","wrapPlainText","match","found","regExp","RegExp","escapeRegExp","exec","sortEntities","messageWrapped","wrapRichText","noLinebreaks","noLinks","noTextFormat","htmlToDocumentFragment","fragment","createDocumentFragment","senderTitle","classList","fromMe","getMessageSenderPeerIdOrName","element","peerTitle","fromName","onclick","href","setAttribute","unsafeMessage","setInnerHTML","langPackKey","getNameDivHTML","getPeerTitle","formatCallDuration","endsWith","wrapJoinVoiceChatAnchor","daysToStart","tomorrowDate","setDate","k","_args","IntlDateElement","day","month","year","t","pinnedMessage","fetchMessageReplyTo","isMessageIsTopMessage","dataset","dir","wrapMessageForReply","htmlToSpan","joined","anchorHTML","domain","langPack","wrapMessageActionTextNewUnsafe","botId","startParam","start_param","inviteToChannel","addChatUser","toggleDialogPin","pinned_dialogs_count_max","getPinnedOrders","getDialogPeer","read","hasChat","fromChat","kind","goodMedias","sticker","canMessageBeEdited","edit_time_limit","messageReplyMarkup","lastReplyMarkup","selective","maxOutId","single_use","hidden","canCache","func","filterMessagesByInputFilter","foundMsgs","filtering","neededContents","neededDocTypes","excludeDocTypes","goodEntities","matchUrl","nextRate","backLimit","minDate","maxDate","offset_id_offset","next_rate","filterMessagesByInputFilterFromStorage","method","min_date","max_date","add_offset","min_id","offsetId","offsetMessage","offset_rate","searchResult","foundCount","getDiscussionMessage","maxMessageId","serviceStartMessage","is_single","filterMessages","generateThreadServiceStartMessage","newDialogsHandlePromise","localMessageIds","creator","delete_messages","affectedMessages","force","triedToReadMaxId","readPromise","soundReset","getPeerString","readHistory","slicedArray","Top","fixUnreadMentionsCountIfNeeded","loadNextPromise","loadNextMentions","last","getUnreadMentions","mergeHistoryResult","minId","messagesMessages","msgIds","getNotifyPeerTypeSettings","getNotifySettings","getInputNotifyPeerById","threadMessage","broadcastEventName","finalizePendingMessage","muteUntil","mute_until","mute","mutePeer","canSendToUser","finalMessage","tempMessage","newPhoto","newDoc","newPhotoSize","oldCacheContext","downloadOptions","getPhotoDownloadOptions","fakeDownload","oldDoc","getInputFileName","polls","handleReleasingMessage","skipReadParticipants","skipReactionsList","emptyMessageReactionsList","next_offset","canViewMessageReadParticipants","getMessageReadParticipants","appReactionsManager","getMessageReactionsList","messageReactionsList","readParticipantsPeerIds","filteredReadParticipants","arr","some","combined","readPeerId","reactionsCount","readParticipants","nextOffset","participants_count","appConfig","chat_read_mark_size_threshold","chat_read_mark_expire_period","increment","notification","peerString","notificationMessage","noIncrement","notificationFromPeerId","tag","peerPhoto","getPeerPhoto","appAvatarsManager","loadAvatar","loadPromise","image","notify","canSendToPeer","isFetchIntervalNeeded","unsetEnd","Both","offsetIdOffset","haveSlice","sliceMe","fulfilled","fillHistoryStorage","constructSlice","topWasMeantToLoad","isBottomEnd","isHistoryResultEnd","requestHistory","oldestMessage","foundSlice","_historyResult","requestPromises","after","getMessagesResult","fetchSingleMessages","replyToPeerId","reply_to_peer_id","typing","timeout","smth","referenceDatabase","deleteContext","deleteWebPageFromPending","updatePollToMessage","groupedId","groupedStorage","albums","peerMessagesToHandle","deletedMids","noForwards","getElementCallback","newMap","peerIdStr","onChatUpdated","updateChannelParticipant","updateChatDefaultBannedRights","default_banned_rights","apiChats","saveApiChat","oldChat","rights","defaultRights","isThread","isCheckingRightsForSelf","megagroup","banned_rights","myFlags","post_messages","broadcast","until_date","getChannelInputPeer","getChatInputPeer","input","usersInputs","fwdLimit","fwd_limit","deleteChatUser","leaveChannel","leaveChat","deleteChannel","deleteChat","inputChatPhoto","about","participant","getParticipantPeerId","actor_id","qts","prev_participant","new_participant","kicked_by","editBanned","view_messages","kickFromChannel","messagesChats","enabled","migrateChat","available_reactions","invokeApiSingleProcess","processResult","sendAsPeers","weakMap","WeakMap","peerTitleWeakMap","querySelectorAll","PeerTitle","bytesFromHex","hexString","len","bytes","Uint8Array","ceil","start","parseInt","photos","context","oldPhoto","safeReplaceArrayInObject","saveContext","boxWidth","boxHeight","useBytes","pushDocumentSize","devicePixelRatio","bestPhotoSize","calcImageInBox","inputUser","photosResult","photoIds","isSticker","mimeType","jpegHeader","jpegTail","btoa","fromCharCode","bytesToDataURL","num","getPreviewURLFromBytes","useBlur","getPreviewURLFromThumb","canvas","Image","renderImageFromUrl","noZoom","choosePhotoSize","boxSize","aspect","isFit","aspectCovered","style","ignoreCache","getImageFromStrippedThumb","queueId","onlyCache","thumb_size","dcId","dc_id","photoId","fullWidth","windowSize","fullHeight","download","getDownload","createObjectURL","getInput","fullPhotoSize","downloadToDisc","AppProfileManager","usersFull","chatsFull","onUpdateUserTyping","typingsInPeer","cancelAction","getChatFull","onUpdatePeerBlocked","updateChatParticipants","participants","chatFull","updateChatParticipantAdd","_participants","inviter_id","version","updateChatParticipantDelete","updateUserTyping","updateChatUserTyping","updateChannelUserTyping","updatePeerBlocked","fullChat","updated","call_active","hasChatPhoto","chat_photo","refreshFullPeer","invalidateChannelParticipants","usersUserFull","full_user","profile_photo","getProfile","profile","getProfileByPeerId","getChannelFull","full_chat","exported_invite","link","exportedInvite","channelParticipant","fullChannel","processError","getChannelParticipants","cP","getTopPeers","ratingMap","processUserIds","updateResult","strippedThumb","stripped_thumb","previous","deletedList","reduce","acc","verifyParticipantForOnlineCount","chatInfo","channelParticipants","reduceParticipantsForOnlineCount","res","onlines","pendingPtsUpdates","pendingSeqUpdates","syncPending","channelStates","attached","debug","processOpts","seqStart","seq_start","forceGetDifference","processUpdate","toId","Proxy","target","saveUpdatesState","us","nextSeq","pendingUpdatesData","popPendingSeqUpdate","seqAwaiting","ptsAwaiting","curState","curPts","goodPts","goodIndex","getDifference","wasSyncing","pts_total_limit","differenceResult","other_updates","new_messages","apiMessage","nextState","intermediate_state","justAName","channelState","getChannelDifference","lastPtsUpdateTime","popPts","popSeq","popPendingPtsUpdate","langCode","newVersion","stateResult","setUpdatesProcessor","setProxy","strs","en","ru","getChangelog","lang","fetch","ok","langStr","languages","language","LOCAL_IDS_SET","appStickersManager","getStickerSetPromises","getStickersByEmoticonsPromises","sounds","getAnimatedEmojiStickerSet","updateNewStickerSet","stickerSet","stickerset","saveStickerSet","getGreetingStickersTimeout","getGreetingSticker","justPreload","getGreetingStickersPromise","getStickersByEmoticon","docs","greetingStickers","shift","downloadDoc","cachedSet","documents","refreshTime","useCache","saveStickers","getStickerSetInput","saveById","getStickerSet","getAnimatedEmojiSounds","emoji","animations","getAnimatedEmojiSoundsPromise","getAppConfig","emojies_sounds","sound","bytesStr","atob","file_reference_base64","charCodeAt","this_dc","invokeApiHashable","stickers","replace","isAnimation","cleanEmoji","pack","packs","preloadEmojiPromise","getAnimatedEmojiSticker","mediaSize","active","emojiSticker","toneIndex","animation","loadAnimationWorker","container","animationData","autoplay","loop","saveLottiePreview","once","preloadAnimatedEmojiStickerAnimation","soundDoc","getAnimatedEmojiSoundDocument","newSet","setToCache","needSave","installed_date","thumb_dc_id","isAnimated","animated","thumb_version","short_name","sets","covered","videos","archived","excludeFeatured","exclude_featured","foundSaved","cache","cover","allStickers","getAllStickers","includeOurStickers","preloadStickerSets","getRecentStickers","messagesStickers","installedSets","recentStickers","foundStickers","cachedStickersAnimated","cachedStickersStatic","iteratePacks","docId","docEmoticon","_doc","EXTENSION_MIME_TYPE_MAP","mov","gif","pdf","savingLottiePreview","downloading","onServiceWorkerFail","supportsStreaming","alt","stickerSetInput","ext","pop","mappedMimeType","monthAsNumber","leadingZero","isServiceWorkerOnline","getFileURL","thumbSize","inputFileLocation","getFileDownloadOptions","toDataURL","preloadPhoto","tryNotToUseBytes","getThumbURL","originalPromise","isPlaySupported","reader","FileReader","onloadend","uint8","decode","readAsArrayBuffer","stickerCachedThumbs","toBlob","createDownloadAnchor","addTaskListener","task","payload","x","fn","ms","shouldRunFirst","shouldRunLast","waitingTimeout","waitingPromise","hadNewCall","_resolve","_reject","apply","_waitingTimeout","VisibilityIntersector","onVisibilityChange","items","locked","observer","IntersectionObserver","entries","changed","entry","isIntersecting","visible","getVisible","disconnect","targets","observe","unobserve","unlock","refresh","findAndSpliceAll","array","parallelLimit","queue","inProcess","lockPromise","unlockResolve","processQueue","throttle","_processQueue","item","loadItem","getItem","processItem","addElement","super","lock","intersector","unlockAndRefresh","div","intersectorTimeout","wasSeen","setProcessQueueTimeout","_queue","spliced","AppMessagesIdsManager","tempNum","temp","MESSAGE_ID_OFFSET","MESSAGE_ID_INCREMENT","clearMessageId","toServer","l","used","loadedURLs","elem","HTMLImageElement","HTMLVideoElement","src","SVGImageElement","setAttributeNS","backgroundImage","isImage","loader","renderImageFromUrlPromise","visualViewport","innerWidth","innerHeight","callbackifyAll","values","SAVE_DOC_KEYS","REFERENCE_CONTEXT","availableReactions","getAvailableReactions","sendReactionPromises","lastSendingTimes","availableReaction","around_animation","static_icon","appear_animation","center_icon","messagesAvailableReactions","callbackify","inactive","activeAvailableReactions","getActiveAvailableReactions","unshiftQuickReaction","getQuickReaction","quickReaction","filteredChatAvailableReactions","unshiftQuickReactionInner","getAvailableReactionsForPeer","reactions_default","getReactionCached","onlyLocal","lastSendingTimeKey","myPeerId","chosenReactionIdx","chosenReaction","can_see_list","reactionCountIdx","userReaction","indexes","promiseKey","editMessageUpdateIdx","editMessageUpdate","sendReaction","html","notificationsShown","notificationIndex","notificationsCount","soundsPlayed","vibrateSupport","peerSettings","notifyUsers","notifyChats","notifyBroadcasts","faviconEl","head","querySelector","titleBackup","titleChanged","stopped","pushInited","updateLocalSettings","updSettings","nodesktop","volume","novibrate","nopreview","nopush","needPush","isAvailable","registeredDevice","subscribe","unsubscribe","setSettings","nosound","notifications","checkMuteUntil","checkMuteUntilTimeout","closestMuteUntil","peerNotifySettings","requestPermission","Notification","removeEventListener","navigator","vibrate","mozVibrate","webkitVibrate","notificationsUiSupport","topMessagesDeferred","notifySoundEl","body","checkMuteUntilThrottled","stop","newVal","toggleToggler","tokenData","unregisterDevice","registerDevice","notificationData","period","custom","enable","resetTitle","setFavicon","clearInterval","titleInterval","getContext","beginPath","arc","PI","fillStyle","fill","fontSize","font","textBaseline","textAlign","fillText","getNotifyPeerTypePromise","inputKey","compare_sound","notifyContactsSignUp","prevFavicon","cloneNode","parentNode","replaceChild","notifySettings","isMuted","respectType","n","inputNotify","typeNotifySettings","getPeerLocalSettings","permission","data","testSound","icon","setLocalNotificationsDisabled","close","focus","onclose","show","hide","nextSoundAt","prevSoundVolume","filename","audio","hidePushNotifications","token_type","tokenType","token","tokenValue","other_uids","app_sandbox","secret","createPosterFromMedia","videoWidth","videoHeight","naturalWidth","naturalHeight","quality","aspectFitted","drawImage","createPosterFromVideo","onseeked","currentTime","onerror","createPosterForVideo","preloadVideo","race","onMediaLoad","readyState","HAVE_METADATA","useCanplayOnIos","getFilesFromEvent","onlyTypes","scanFiles","isDirectory","directoryReader","createReader","readEntries","itemFile","getAsFile","DataTransferItem","DragEvent","dataTransfer","clipboardData","originalEvent","webkitGetAsEntry","requestFile","accept","display","click","getMiddleware","cleanupObj","cleaned","additionalCallback","_cleanupObj","fixBase64String","toUrl","prefixes","maxPrefixLength","setPrefix","country","prefix","country_code","originalStr","countriesList","country_codes","prefixCountry","phoneCode","leftPattern","patterns","searchForPattern","pattern","mostMatchedPatternMatches","mostMatchedPattern","_pattern","patternMatches","symbol","wasObject","newObject","ProgressivePreloader","detached","cancelable","streamable","onClick","contains","loadFunc","color","bold","constructContainer","construct","totalLength","downloadSvg","lastElementChild","cancelSvg","previousElementSibling","circle","firstElementChild","setProgress","startTime","onEnd","elapsedTime","delay","TRANSITION_TIME","detach","attach","parentElement","setManual","reset","useRafs","getTotalLength","strokeDasharray","savedAvatarURLs","getAvatarPromise","peerPhotoFileLocation","big","limitPart","img","onlyThumb","renderThumbPromise","thumbImage","animate","animationsEnabled","isFullLoaded","putAvatar","childElementCount","mutateElement","renderPromise","isDialog","isBig","getPeerColorById","avatarAvailable","avatarRendered","abbr","getPeerInitials","GROUP_CALL_STATE","limitFrom","drafts","getAllDraftPromise","updateDraftMessage","peerID","getKey","getAllDrafts","apiDraft","processApiDraft","draft1","draft2","rMessage","wrapDraftText","localDraft","saveOnServer","serverDraft","getDraft","draftsAreEqual","draftObj","isEmptyDraft","saveLocalDraft","emptyDraft","syncDraft","ConferenceEntry","port","direction","originalDirection","endpoint","connection","setDirection","transceiver","addTransceiver","source","sourceGroups","sources","isAnswer","generateSsrc","LocalConferenceDescription","sessionId","entriesByMid","entriesBySource","entriesByPeerId","setSource","setPeerId","isSending","sendEntry","recvEntry","createEntry","fromConference","conference","minChars","fullTexts","searchText","newFoundObjs","queryWords","queryWordsLength","fullText","what","foundChars","word","fullTextLength","queries","_search","val","getTextWidth","measureText","testQueue","fontFamily","pendingTest","setTestQueue","testElement","getElementWidth","sizeType","mediaSizes","getBoundingClientRect","mapped","firstTime","textLength","multiplier","textWidth","elementWidth","textContent","fontWeight","newElementWidth","widthChanged","smallerText","smallerWidth","smallerTextLength","half","clamp","half1","half2","removeAttribute","capture","passive","MiddleEllipsisElement","HTMLElement","customElements","define","makeSsrcsFromParticipant","makeSsrcFromParticipant","audio_source","source_groups","presentation","groupCalls","nextOffsets","updateGroupCall","updateGroupCallParticipants","groupCallId","saveApiParticipants","groupCall","currentGroupCall","hangUp","audioAsset","nextOffsetsMap","setNextOffset","newNextOffset","skipCounterUpdating","getCachedParticipants","oldParticipant","hasLeft","can_self_unmute","isCurrentGroupCall","onParticipantUpdate","doNotDispatchParticipantUpdate","getGroupCall","modified","just_joined","apiParticipants","saveApiParticipant","isUpdatingMeInCurrentCall","isSharingAudio","raiseHand","raise_hand_rating","videoStopped","generateSelfVideo","connections","main","setMuted","getGroupCallInput","getInputPeerSelf","raise_hand","video_paused","videoPaused","video_stopped","presentation_paused","presentationPaused","participants_next_offset","oldCall","shouldUpdate","stopConnectingSound","playSoundWithTimeout","stopSound","cancelDelayedPlay","rejoin","joinVideo","streamManager","createAudio","constraints","getAudioConstraints","getVideoConstraints","stream","getStream","addStream","inputStream","MediaStream","createMainStreamManager","joinGroupCallInternal","bindPrefix","fixSafariAudio","CLOSED","setCurrentGroupCall","playSound","getGroupCallFull","connectionInstance","createConnectionInstance","createPeerConnection","negotiate","onTrack","iceConnectionState","startConnectingSound","getGroupCallParticipants","createDescription","createDataChannel","appendStreamToConference","handleUpdateGroupCallParticipants","updatingSdp","audioSource","mainSources","presentationSources","tsNow","prepareToSavingNextOffset","ids","groupCallParticipants","discard","changeUserMuted","getParticipantByPeerId","editParticipant","property","sortProperty","prev","next","updateMessagePoll","poll_id","saveResults","chosenIndexes","answer","correctAnswers","solution","solutionEntities","correct_answers","solution_entities","optionIds","answers","option","sendVote","votesList","closed","newPoll","getInputMediaPoll","stopTrack","track","AudioStreamAnalyser","streamSource","createMediaStreamSource","analyser","createAnalyser","gain","createGain","minDecibels","maxDecibels","smoothingTimeConstant","fftSize","connect","StreamManager","interval","getAmplitude","streamAnalyser","frequencyBinCount","getByteFrequencyData","analyse","counter","amplitudes","AudioContext","webkitAudioContext","outputStream","canCreateConferenceEntry","types","getTracks","addTrack","getSource","itemSource","removeTrack","finalizeAddingTrack","changeTimer","substring","oldTrack","timer","transceiverInit","streams","tracks","findEntry","createTransceiver","mediaTrackType","trackIdx","sender","replaceTrack","toTelegramSource","fromTelegramSource","scale","rms","sqrt","object","SliceEnd","compareValue","val1","val2","toExponential","str1","str2","str1Length","compareLong","sliceConstructor","getSliceConstructor","slices","None","side","deleteCount","flatten","lowerBound","upperBound","lowerIndex","upperIndex","foundSliceIndex","sliced","insertIndex","prevSlice","nextSlice","sliceOffset","findSliceOffset","sliceStart","sliceEnd","bottomWasMeantToLoad","topFulfilled","bottomFulfilled","SlicedArray","heavyQueue","processingQueue","addHeavyTask","processHeavyQueue","todo","performance","possiblePromise","process","realResult","timedChunk","requireBlurPromise","fastBlurFunc","processBlurNext","radius","iterations","alpha","default","dataUri","className","onload","badCharsRe","trimRe","C2L","й","ц","у","к","е","н","г","ш","щ","з","х","ъ","ф","ы","в","а","п","р","о","л","д","ж","э","я","ч","с","м","и","т","ь","б","ю","clearBadCharsAndTrim","processSearchText","hasTag","originalText","ch","latinizeCh","latinizeString","fixCyrillic","numberThousandSplitter","joiner","photoTypeSet","webpages","pendingWebPages","updateWebPage","apiWebPage","oldWebPage","isUpdated","siteName","site_name","shortTitle","author","description","pendingSet","shortDescriptionText","DocumentFragment","template","content","mediaDevices","getUserMedia","frameRate","GROUP_CALL_AMPLITUDE_ANALYSE_COUNT_MAX","GROUP_CALL_AMPLITUDE_ANALYSE_INTERVAL_MS","WEBRTC_MEDIA_PORT","fixMediaLineType","mediaType","getConnectionTypeForMediaType","generateMediaFirstLine","payloadIds","connectionType","SDPBuilder","foundation","component","protocol","toUpperCase","priority","ip","generation","performCandidate","sId","bundleMids","bundle","transport","skipCandidates","ufrag","pwd","fingerprint","fingerprints","setup","candidates","candidate","addCandidate","streamName","addSource","ssrc","addMsid","ssrcGroup","semantics","isApplication","codec","isInactive","shouldBeSkipped","payloadTypes","addTransport","hdrexts","hdrext","uri","clockrate","channels","parameters","fbs","fb","subtype","addSsrc","addHeader","addSsrcEntry","addConference","SDP","session","mediaSections","lines","line","parsed","section","splitStringByLimitWithRest","separator","UniqueNumberGenerator","maxTries","_try","SDPAttributeSplitted","SDPMediaLineParts","missed","rest","nestedMap","makeAttributes","innerParts","fillAttributes","attributesMap","linesArray","mediaLineParts","exists","resultShouldBeArray","SDPSessionSection","parseSdp","createSection","sessionSection","lineStr","test","isIncorrectSdpLine","parseSdpLine","addSimulcast","sdp","generator","originalSsrcs","ssrcs","generate","ssrcs2","ssrcsStrLines","ssrc2","v","bytesToHex","contexts","links","originalPayload","refreshReference","postMessage","reference","getContexts","_context","getReferenceByLink","refreshEmojiesSoundsPromise","hex","newHex","newContext","parseMediaSectionInfo","clientInfo","lookupAttributeKeys","telegramSourceGroups","sdpLines","parseSourceGroups","raw","IS_VIBRATE_SUPPORTED","convertInputKeyToKey","names","props","writable","configurable","defineProperties","opusDecodeController","sampleRate","tasks","keepAlive","isPlaySupportedResult","canPlayType","wavWorker","Worker","page","onTaskEnd","worker","command","buffers","typedArray","buffer","loadWorker","loadWavWorker","terminateWorkers","executeNewTask","kill","terminate","decoderSampleRate","outputBufferSampleRate","wavBitDepth","wavSampleRate","pages","withWaveform","pushDecodeTask","dataBlob","IS_WEBM_SUPPORTED","IMAGE_MIME_TYPES_SUPPORTED","AudioAssetPlayer","assets","assetName","play","Audio","pause","getScreenConstraints","skipAudio","getScreenStream","screenStream","getDisplayMedia","getVideoTracks","contentHint","StringFromLineBuilder","newLine","negotiateThrottled","iceServers","iceTransportPolicy","bundlePolicy","rtcpMuxPolicy","iceCandidatePoolSize","dataChannel","maybeUpdateRemoteVideoConstraints","updateConstraintsInterval","localSdp","mainChannels","processedChannels","processed","sectionInfo","JSON","stringify","processMediaSection","audioChannel","videoChannel","useChannel","setEntrySource","setEntryPeerId","parse","groupCallInput","request","join_as","setData","extmap","performExtmap","filterServerCodecs","isNewConnection","getEntryByMid","originalOffer","createOffer","iceRestart","offer","hasMunged","skipAddingMulticast","mediaLine","localMLine","codecIds","newData","setPort","newSdp","newChannel","mungedSdp","fixLocalOffer","setLocalDescription","invokeJoinGroupCall","entriesToDelete","answerDescription","generateSdp","deleteEntry","signalingState","iceGatheringState","connectionState","setRemoteDescription","negotiating","updateConstraints","getTransceivers","setParameters","getParameters","degradationPreference","colibriClass","defaultConstraints","maxHeight","onStageEndpoints","minHeight","sendDataChannelData","saveInputVideoStream","safeAssign","isSpeakingMap","pinnedSources","participantsSsrcs","hadAutoPinnedSources","dispatchPinnedThrottled","pinnedSource","cleanup","MUTED","UNMUTED","MUTED_BY_ADMIN","CONNECTING","requestAudioSource","toggleMuted","getElement","clone","srcObject","raise","stopScreenSharing","addInputVideoStream","startScreenSharingPromise","startScreenSharingInternal","unpinSource","closeConnectionAndStream","isSharingScreen","startScreenSharing","startVideoSharingPromise","startVideoSharingInternal","appendToConference","isSharingVideo","stopVideoSharing","startVideoSharing","isDiscarded","tryAddTrack","getEntryBySource","oldSsrcs","pinSource","modifiedTypes","oldSsrc","oldSource","oldEntry","setEndpoint","RTCPeerConnection","dict","stopStream","closeConnection","negotiateInternal","CALL_DURATION_LANG_KEYS","showLast","modulus","formatDuration","strings","elements","VIDEO_MIME_TYPES_SUPPORTED","getStreamCached","_cache","screen","isScreen","player","hasInputTrackKind","noop","requestInputSource","isAudioGood","isVideoGood","onInputStream","isOutput","tagName","isVideo","elementEndpoint","useStream","paused","sinkId","outputDeviceId","setSinkId","appendChild","getAudioTracks","isClosing","channelCount","constraint","getSupportedConstraints","constraintSupported"],"mappings":"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,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,KAAK,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,KAAK,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,KAAK,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,KAAK,IAAK,KAAK,IAAK,IAAI,IAAK,IAAI,IAAK,KAAK,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,KAAK,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,KAAK,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,KAAK,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,KAAK,IAAK,KAAK,IAAK,IAAI,IAAK,KAAK,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,KAAK,IAAK,IAAI,IAAK,KAAK,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,KAAK,IAAK,KAAK,IAAK,KAAK,IAAK,KAAK,IAAK,KAAK,IAAK,KAAK,IAAK,KAAK,IAAK,KAAK,IAAK,KAAK,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,KAAK,IAAK,KAAK,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,KAAK,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,KAAK,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,KAAK,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,KAAK,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,KAAK,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,KAAK,IAAK,KAAK,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,KAAK,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,KAAK,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,KAAK,IAAK,IAAI,IAAK,KAAK,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,KAAK,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,KAAK,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,KAAK,IAAK,KAAK,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,KAAK,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,IAAI,IAAK,KAAK,IAAK,MAAM,IAAK,MAAM,IAAK,KAAK,IAAK,KAAK,IAAK,KAAK,IAAK,KAAK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","file":"6.cc868caf9909d9676740.chunk.js","sourcesContent":["/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n * \r\n * Originally from:\r\n * https://github.com/zhukov/webogram\r\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\r\n * https://github.com/zhukov/webogram/blob/master/LICENSE\r\n */\r\n\r\nexport default function cleanUsername(username: string) {\r\n  return username && username.toLowerCase() || '';\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n * \r\n * Originally from:\r\n * https://github.com/zhukov/webogram\r\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\r\n * https://github.com/zhukov/webogram/blob/master/LICENSE\r\n */\r\n\r\nimport { MOUNT_CLASS_TO } from \"../../config/debug\";\r\nimport filterUnique from \"../../helpers/array/filterUnique\";\r\nimport findAndSplice from \"../../helpers/array/findAndSplice\";\r\nimport indexOfAndSplice from \"../../helpers/array/indexOfAndSplice\";\r\nimport deferredPromise, { CancellablePromise } from \"../../helpers/cancellablePromise\";\r\nimport cleanSearchText from \"../../helpers/cleanSearchText\";\r\nimport cleanUsername from \"../../helpers/cleanUsername\";\r\nimport { formatFullSentTimeRaw, tsNow } from \"../../helpers/date\";\r\nimport { formatPhoneNumber } from \"../../helpers/formatPhoneNumber\";\r\nimport isObject from \"../../helpers/object/isObject\";\r\nimport safeReplaceObject from \"../../helpers/object/safeReplaceObject\";\r\nimport { isRestricted } from \"../../helpers/restrictions\";\r\nimport { Chat, ContactsResolvedPeer, InputContact, InputGeoPoint, InputMedia, InputPeer, InputUser, User as MTUser, UserProfilePhoto, UserStatus } from \"../../layer\";\r\nimport I18n, { i18n, LangPackKey } from \"../langPack\";\r\n//import apiManager from '../mtproto/apiManager';\r\nimport apiManager from '../mtproto/mtprotoworker';\r\nimport { REPLIES_PEER_ID, SERVICE_PEER_ID } from \"../mtproto/mtproto_config\";\r\nimport serverTimeManager from \"../mtproto/serverTimeManager\";\r\nimport { RichTextProcessor } from \"../richtextprocessor\";\r\nimport rootScope from \"../rootScope\";\r\nimport SearchIndex from \"../searchIndex\";\r\nimport apiUpdatesManager from \"./apiUpdatesManager\";\r\nimport appChatsManager from \"./appChatsManager\";\r\nimport appPeersManager from \"./appPeersManager\";\r\nimport appStateManager from \"./appStateManager\";\r\n\r\nexport type User = MTUser.user;\r\nexport type TopPeerType = 'correspondents' | 'bots_inline';\r\nexport type MyTopPeer = {id: PeerId, rating: number};\r\n\r\nexport class AppUsersManager {\r\n  private storage = appStateManager.storages.users;\r\n  \r\n  private users: {[userId: UserId]: User};\r\n  private usernames: {[username: string]: UserId};\r\n  private contactsIndex: SearchIndex<UserId>;\r\n  private contactsFillPromise: CancellablePromise<AppUsersManager['contactsList']>;\r\n  private contactsList: Set<UserId>;\r\n  private updatedContactsList: boolean;\r\n  \r\n  private getTopPeersPromises: {[type in TopPeerType]?: Promise<MyTopPeer[]>};\r\n\r\n  constructor() {\r\n    this.clear(true);\r\n\r\n    setInterval(this.updateUsersStatuses, 60000);\r\n\r\n    rootScope.addEventListener('state_synchronized', this.updateUsersStatuses);\r\n\r\n    rootScope.addMultipleEventsListeners({\r\n      updateUserStatus: (update) => {\r\n        const userId = update.user_id;\r\n        const user = this.users[userId];\r\n        if(user) {\r\n          user.status = update.status;\r\n          if(user.status) {\r\n            if('expires' in user.status) {\r\n              user.status.expires -= serverTimeManager.serverTimeOffset;\r\n            }\r\n\r\n            if('was_online' in user.status) {\r\n              user.status.was_online -= serverTimeManager.serverTimeOffset;\r\n            }\r\n          }\r\n\r\n          //user.sortStatus = this.getUserStatusForSort(user.status);\r\n          rootScope.dispatchEvent('user_update', userId);\r\n          this.setUserToStateIfNeeded(user);\r\n        } //////else console.warn('No user by id:', userId);\r\n      },\r\n\r\n      updateUserPhoto: (update) => {\r\n        const userId = update.user_id;\r\n        const user = this.users[userId];\r\n        if(user) {\r\n          if((user.photo as UserProfilePhoto.userProfilePhoto)?.photo_id === (update.photo as UserProfilePhoto.userProfilePhoto)?.photo_id) {\r\n            return;\r\n          }\r\n\r\n          this.forceUserOnline(userId, update.date);\r\n\r\n          if(update.photo._ === 'userProfilePhotoEmpty') {\r\n            delete user.photo;\r\n          } else {\r\n            user.photo = safeReplaceObject(user.photo, update.photo);\r\n          }\r\n\r\n          this.setUserToStateIfNeeded(user);\r\n\r\n          rootScope.dispatchEvent('user_update', userId);\r\n          rootScope.dispatchEvent('avatar_update', userId.toPeerId());\r\n        } else console.warn('No user by id:', userId);\r\n      },\r\n\r\n      updateUserName: (update) => {\r\n        const userId = update.user_id;\r\n        const user = this.users[userId];\r\n        if(user) {\r\n          this.forceUserOnline(userId);\r\n          \r\n          this.saveApiUser({\r\n            ...user, \r\n            first_name: update.first_name,\r\n            last_name: update.last_name,\r\n            username: update.username\r\n          }, true);\r\n        }\r\n      }\r\n    });\r\n\r\n    /* case 'updateContactLink':\r\n    this.onContactUpdated(update.user_id, update.my_link._ === 'contactLinkContact');\r\n    break; */\r\n\r\n    rootScope.addEventListener('language_change', (e) => {\r\n      const userId = this.getSelf().id;\r\n      this.contactsIndex.indexObject(userId, this.getUserSearchText(userId));\r\n    });\r\n\r\n    appStateManager.getState().then((state) => {\r\n      const users = appStateManager.storagesResults.users;\r\n      if(users.length) {\r\n        for(let i = 0, length = users.length; i < length; ++i) {\r\n          const user = users[i];\r\n          if(user) {\r\n            this.users[user.id] = user;\r\n            this.setUserNameToCache(user);\r\n          }\r\n        }\r\n      }\r\n\r\n      const contactsList = state.contactsList;\r\n      if(contactsList && Array.isArray(contactsList)) {\r\n        contactsList.forEach(userId => {\r\n          this.pushContact(userId);\r\n        });\r\n\r\n        if(contactsList.length) {\r\n          this.contactsFillPromise = deferredPromise();\r\n          this.contactsFillPromise.resolve(this.contactsList);\r\n        }\r\n      }\r\n\r\n      appStateManager.addEventListener('peerNeeded', (peerId) => {\r\n        if(!appPeersManager.isUser(peerId)) {\r\n          return;\r\n        }\r\n        \r\n        const userId = peerId.toUserId();\r\n        if(!this.storage.getFromCache(userId)) {\r\n          this.storage.set({\r\n            [userId]: this.getUser(userId)\r\n          });\r\n        }\r\n      });\r\n\r\n      appStateManager.addEventListener('peerUnneeded', (peerId) => {\r\n        if(!appPeersManager.isUser(peerId)) {\r\n          return;\r\n        }\r\n\r\n        const userId = peerId.toUserId();\r\n        if(this.storage.getFromCache(userId)) {\r\n          this.storage.delete(userId);\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  public clear(init = false) {\r\n    if(!init) {\r\n      const users = appStateManager.storagesResults.users;\r\n      for(const userId in this.users) {\r\n        // const userId = +userId;\r\n        if(!userId) continue;\r\n        const peerId = userId.toPeerId();\r\n        if(!appStateManager.isPeerNeeded(peerId)) {\r\n          const user = this.users[userId];\r\n          if(user.username) {\r\n            delete this.usernames[cleanUsername(user.username)];\r\n          }\r\n\r\n          findAndSplice(users, (user) => user.id === userId);\r\n          this.storage.delete(userId);\r\n          delete this.users[userId];\r\n        }\r\n      }\r\n    } else {\r\n      this.users = {};\r\n      this.usernames = {};\r\n    }\r\n    \r\n    this.getTopPeersPromises = {};\r\n    this.contactsIndex = this.createSearchIndex();\r\n    this.contactsFillPromise = undefined;\r\n    this.contactsList = new Set();\r\n    this.updatedContactsList = false;\r\n  }\r\n\r\n  private onContactsModified() {\r\n    const contactsList = [...this.contactsList];\r\n    appStateManager.pushToState('contactsList', contactsList);\r\n  }\r\n\r\n  public fillContacts() {\r\n    if(this.contactsFillPromise && this.updatedContactsList) {\r\n      return {\r\n        cached: this.contactsFillPromise.isFulfilled,\r\n        promise: this.contactsFillPromise\r\n      };\r\n    }\r\n\r\n    this.updatedContactsList = true;\r\n\r\n    const promise = deferredPromise<Set<UserId>>();\r\n    apiManager.invokeApi('contacts.getContacts').then((result) => {\r\n      if(result._ === 'contacts.contacts') {\r\n        this.contactsList.clear();\r\n      \r\n        this.saveApiUsers(result.users);\r\n\r\n        result.contacts.forEach((contact) => {\r\n          this.pushContact(contact.user_id);\r\n        });\r\n\r\n        this.onContactsModified();\r\n\r\n        this.contactsFillPromise = promise;\r\n      }\r\n\r\n      promise.resolve(this.contactsList);\r\n    }, () => {\r\n      this.updatedContactsList = false;\r\n    });\r\n\r\n    return {\r\n      cached: this.contactsFillPromise?.isFulfilled,\r\n      promise: this.contactsFillPromise || (this.contactsFillPromise = promise)\r\n    };\r\n  }\r\n\r\n  public resolveUsername(username: string): Promise<Chat | User> {\r\n    if(username[0] === '@') {\r\n      username = username.slice(1);\r\n    }\r\n\r\n    username = username.toLowerCase();\r\n    if(this.usernames[username]) {\r\n      return Promise.resolve(this.users[this.usernames[username]]);\r\n    }\r\n\r\n    return apiManager.invokeApi('contacts.resolveUsername', {username}).then(resolvedPeer => {\r\n      return this.processResolvedPeer(resolvedPeer);\r\n    });\r\n  }\r\n\r\n  private processResolvedPeer(resolvedPeer: ContactsResolvedPeer.contactsResolvedPeer) {\r\n    this.saveApiUsers(resolvedPeer.users);\r\n    appChatsManager.saveApiChats(resolvedPeer.chats);\r\n\r\n    return appPeersManager.getPeer(appPeersManager.getPeerId(resolvedPeer.peer)) as Chat | User;\r\n  }\r\n\r\n  public resolvePhone(phone: string) {\r\n    return apiManager.invokeApi('contacts.resolvePhone', {phone}).then(resolvedPeer => {\r\n      return this.processResolvedPeer(resolvedPeer) as User;\r\n    });\r\n  }\r\n\r\n  public pushContact(id: UserId) {\r\n    this.contactsList.add(id);\r\n    this.contactsIndex.indexObject(id, this.getUserSearchText(id));\r\n    appStateManager.requestPeerSingle(id.toPeerId(), 'contact');\r\n  }\r\n\r\n  public popContact(id: UserId) {\r\n    this.contactsList.delete(id);\r\n    this.contactsIndex.indexObject(id, ''); // delete search index\r\n    appStateManager.releaseSinglePeer(id.toPeerId(), 'contact');\r\n  }\r\n\r\n  public getUserSearchText(id: UserId) {\r\n    const user = this.users[id];\r\n    if(!user) {\r\n      return '';\r\n    }\r\n\r\n    const arr: string[] = [\r\n      user.first_name,\r\n      user.last_name,\r\n      user.phone,\r\n      user.username,\r\n      user.pFlags.self ? I18n.format('SavedMessages', true) : '',\r\n      user.pFlags.self ? 'Saved Messages' : ''\r\n    ];\r\n\r\n    return arr.filter(Boolean).join(' ');\r\n  }\r\n\r\n  public getContacts(query?: string, includeSaved = false, sortBy: 'name' | 'online' | 'none' = 'name') {\r\n    return this.fillContacts().promise.then(_contactsList => {\r\n      let contactsList = [..._contactsList];\r\n      if(query) {\r\n        const results = this.contactsIndex.search(query);\r\n        const filteredContactsList = [...contactsList].filter(id => results.has(id));\r\n\r\n        contactsList = filteredContactsList;\r\n      }\r\n\r\n      if(sortBy === 'name') {\r\n        contactsList.sort((userId1, userId2) => {\r\n          const sortName1 = (this.users[userId1] || {}).sortName || '';\r\n          const sortName2 = (this.users[userId2] || {}).sortName || '';\r\n          return sortName1.localeCompare(sortName2);\r\n        });\r\n      } else if(sortBy === 'online') {\r\n        contactsList.sort((userId1, userId2) => {\r\n          const status1 = appUsersManager.getUserStatusForSort(appUsersManager.getUser(userId1).status);\r\n          const status2 = appUsersManager.getUserStatusForSort(appUsersManager.getUser(userId2).status);\r\n          return status2 - status1;\r\n        });\r\n      }\r\n\r\n      const myUserId = rootScope.myId.toUserId();\r\n      indexOfAndSplice(contactsList, myUserId);\r\n      if(includeSaved) {\r\n        if(this.testSelfSearch(query)) {\r\n          contactsList.unshift(myUserId);\r\n        }\r\n      }\r\n\r\n      return contactsList;\r\n    });\r\n  }\r\n\r\n  public getContactsPeerIds(\r\n    query?: Parameters<AppUsersManager['getContacts']>[0], \r\n    includeSaved?: Parameters<AppUsersManager['getContacts']>[1], \r\n    sortBy?: Parameters<AppUsersManager['getContacts']>[2]) {\r\n    return this.getContacts(query, includeSaved, sortBy).then(userIds => {\r\n      return userIds.map(userId => userId.toPeerId(false));\r\n    });\r\n  }\r\n\r\n  public toggleBlock(peerId: PeerId, block: boolean) {\r\n    return apiManager.invokeApiSingle(block ? 'contacts.block' : 'contacts.unblock', {\r\n      id: appPeersManager.getInputPeerById(peerId)\r\n    }).then(value => {\r\n      if(value) {\r\n        apiUpdatesManager.processLocalUpdate({\r\n          _: 'updatePeerBlocked',\r\n          peer_id: appPeersManager.getOutputPeer(peerId),\r\n          blocked: block\r\n        });\r\n      }\r\n\r\n      return value;\r\n    });\r\n  }\r\n\r\n  public testSelfSearch(query: string) {\r\n    const user = this.getSelf();\r\n    const index = this.createSearchIndex();\r\n    index.indexObject(user.id, this.getUserSearchText(user.id));\r\n    return index.search(query).has(user.id);\r\n  }\r\n\r\n  private createSearchIndex() {\r\n    return new SearchIndex<UserId>({\r\n      clearBadChars: true,\r\n      ignoreCase: true,\r\n      latinize: true,\r\n      includeTag: true\r\n    });\r\n  }\r\n\r\n  public saveApiUsers(apiUsers: MTUser[], override?: boolean) {\r\n    if((apiUsers as any).saved) return;\r\n    (apiUsers as any).saved = true;\r\n    apiUsers.forEach((user) => this.saveApiUser(user, override));\r\n  }\r\n\r\n  private setUserNameToCache(user: MTUser.user, oldUser?: MTUser.user) {\r\n    if(!oldUser || oldUser.username !== user.username) {\r\n      if(oldUser?.username) {\r\n        const oldSearchUsername = cleanUsername(oldUser.username);\r\n        delete this.usernames[oldSearchUsername];\r\n      }\r\n\r\n      if(user.username) {\r\n        const searchUsername = cleanUsername(user.username);\r\n        this.usernames[searchUsername] = user.id;\r\n      }\r\n    }\r\n  }\r\n\r\n  public saveApiUser(user: MTUser, override?: boolean) {\r\n    if(user._ === 'userEmpty') return;\r\n\r\n    const userId = user.id;\r\n    const oldUser = this.users[userId];\r\n\r\n    // ! commented block can affect performance !\r\n    // if(oldUser && !override) {\r\n    //   console.log('saveApiUser same');\r\n    //   return;\r\n    // }\r\n\r\n    if(user.pFlags === undefined) {\r\n      user.pFlags = {};\r\n    }\r\n\r\n    if(user.pFlags.min && oldUser !== undefined) {\r\n      return;\r\n    }\r\n\r\n    // * exclude from state\r\n    // defineNotNumerableProperties(user, ['initials', 'num', 'rFirstName', 'rFullName', 'rPhone', 'sortName', 'sortStatus']);\r\n\r\n    this.setUserNameToCache(user, oldUser);\r\n\r\n    if(!oldUser \r\n      || oldUser.sortName === undefined \r\n      || oldUser.first_name !== user.first_name \r\n      || oldUser.last_name !== user.last_name) {\r\n      const fullName = user.first_name + (user.last_name ? ' ' + user.last_name : '');\r\n\r\n      user.sortName = user.pFlags.deleted ? '' : cleanSearchText(fullName, false);\r\n    } else {\r\n      user.sortName = oldUser.sortName;\r\n    }\r\n\r\n    if(user.status) {\r\n      if((user.status as UserStatus.userStatusOnline).expires) {\r\n        (user.status as UserStatus.userStatusOnline).expires -= serverTimeManager.serverTimeOffset;\r\n      }\r\n\r\n      if((user.status as UserStatus.userStatusOffline).was_online) {\r\n        (user.status as UserStatus.userStatusOffline).was_online -= serverTimeManager.serverTimeOffset;\r\n      }\r\n    }\r\n\r\n    //user.sortStatus = user.pFlags.bot ? -1 : this.getUserStatusForSort(user.status);\r\n\r\n    let changedPhoto = false, changedTitle = false;\r\n    if(oldUser === undefined) {\r\n      this.users[userId] = user;\r\n    } else {\r\n      if(user.first_name !== oldUser.first_name \r\n        || user.last_name !== oldUser.last_name \r\n        || user.username !== oldUser.username) {\r\n        changedTitle = true;\r\n      }\r\n\r\n      const oldPhotoId = (oldUser.photo as UserProfilePhoto.userProfilePhoto)?.photo_id;\r\n      const newPhotoId = (user.photo as UserProfilePhoto.userProfilePhoto)?.photo_id;\r\n      if(oldPhotoId !== newPhotoId) {\r\n        changedPhoto = true;\r\n      }\r\n\r\n      /* if(user.pFlags.bot && user.bot_info_version !== oldUser.bot_info_version) {\r\n        \r\n      } */\r\n\r\n      const wasContact = !!oldUser.pFlags.contact;\r\n      const newContact = !!user.pFlags.contact;\r\n\r\n      safeReplaceObject(oldUser, user);\r\n      rootScope.dispatchEvent('user_update', userId);\r\n\r\n      if(wasContact !== newContact) {\r\n        this.onContactUpdated(userId, newContact, wasContact);\r\n      }\r\n    }\r\n\r\n    if(changedPhoto) {\r\n      rootScope.dispatchEvent('avatar_update', user.id.toPeerId());\r\n    }\r\n\r\n    if(changedTitle) {\r\n      rootScope.dispatchEvent('peer_title_edit', user.id.toPeerId());\r\n    }\r\n\r\n    this.setUserToStateIfNeeded(user);\r\n  }\r\n\r\n  public setUserToStateIfNeeded(user: User) {\r\n    if(appStateManager.isPeerNeeded(user.id.toPeerId())) {\r\n      this.storage.set({\r\n        [user.id]: user\r\n      });\r\n    }\r\n  }\r\n\r\n  public formatUserPhone(phone: string) {\r\n    return '+' + formatPhoneNumber(phone).formatted;\r\n  }\r\n\r\n  public isUserOnlineVisible(id: UserId) {\r\n    return this.getUserStatusForSort(id) > 3;\r\n  }\r\n\r\n  public getUserStatusForSort(status: User['status'] | UserId) {\r\n    if(typeof(status) !== 'object') {\r\n      status = this.getUser(status).status;\r\n    }\r\n\r\n    if(status) {\r\n      const expires = status._ === 'userStatusOnline' ? status.expires : (status._ === 'userStatusOffline' ? status.was_online : 0);\r\n      if(expires) {\r\n        return expires;\r\n      }\r\n\r\n      /* const timeNow = tsNow(true);\r\n      switch(status._) {\r\n        case 'userStatusRecently':\r\n          return timeNow - 86400 * 3;\r\n        case 'userStatusLastWeek':\r\n          return timeNow - 86400 * 7;\r\n        case 'userStatusLastMonth':\r\n          return timeNow - 86400 * 30;\r\n      } */\r\n      switch(status._) {\r\n        case 'userStatusRecently':\r\n          return 3;\r\n        case 'userStatusLastWeek':\r\n          return 2;\r\n        case 'userStatusLastMonth':\r\n          return 1;\r\n      }\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  public getUser(id: User | UserId) {\r\n    if(isObject<User>(id)) {\r\n      return id;\r\n    }\r\n\r\n    return this.users[id] || {_: 'userEmpty', id, pFlags: {deleted: true}, access_hash: ''} as any as User;\r\n  }\r\n\r\n  public getSelf() {\r\n    return this.getUser(rootScope.myId);\r\n  }\r\n\r\n  public getUserStatusString(id: UserId): HTMLElement {\r\n    let key: LangPackKey;\r\n    let args: any[];\r\n\r\n    switch(id) {\r\n      case REPLIES_PEER_ID:\r\n        key = 'Peer.RepliesNotifications';\r\n        break;\r\n      case SERVICE_PEER_ID:\r\n        key = 'Peer.ServiceNotifications';\r\n        break;\r\n      default: {\r\n        if(this.isBot(id)) {\r\n          key = 'Bot';\r\n          break;\r\n        }\r\n\r\n        const user = this.getUser(id);\r\n        if(!user) {\r\n          key = '' as any;\r\n          break;\r\n        }\r\n\r\n        if(user.pFlags.support) {\r\n          key = 'SupportStatus';\r\n          break;\r\n        }\r\n\r\n        switch(user.status?._) {\r\n          case 'userStatusRecently': {\r\n            key = 'Lately';\r\n            break;\r\n          }\r\n    \r\n          case 'userStatusLastWeek': {\r\n            key = 'WithinAWeek';\r\n            break;\r\n          }\r\n    \r\n          case 'userStatusLastMonth': {\r\n            key = 'WithinAMonth';\r\n            break;\r\n          }\r\n          \r\n          case 'userStatusOffline': {\r\n            const date = user.status.was_online;\r\n            const today = new Date();\r\n            const now = today.getTime() / 1000 | 0;\r\n            \r\n            const diff = now - date;\r\n            if(diff < 60) {\r\n              key = 'Peer.Status.justNow';\r\n            } else if(diff < 3600) {\r\n              key = 'Peer.Status.minAgo';\r\n              const c = diff / 60 | 0;\r\n              args = [c];\r\n            } else if(diff < 86400 && today.getDate() === new Date(date * 1000).getDate()) {\r\n              key = 'LastSeen.HoursAgo';\r\n              const c = diff / 3600 | 0;\r\n              args = [c];\r\n            } else {\r\n              key = 'Peer.Status.LastSeenAt';\r\n              const {dateEl, timeEl} = formatFullSentTimeRaw(date);\r\n              args = [dateEl, timeEl];\r\n            }\r\n            \r\n            break;\r\n          }\r\n    \r\n          case 'userStatusOnline': {\r\n            key = 'Online';\r\n            break;\r\n          }\r\n    \r\n          default: {\r\n            key = 'ALongTimeAgo';\r\n            break;\r\n          }\r\n        }\r\n\r\n        break;\r\n      }\r\n    }\r\n    \r\n    return i18n(key, args);\r\n  }\r\n\r\n  public isBot(id: UserId) {\r\n    return this.users[id] && !!this.users[id].pFlags.bot;\r\n  }\r\n\r\n  public isContact(id: UserId) {\r\n    return this.contactsList.has(id) || !!(this.users[id] && this.users[id].pFlags.contact);\r\n  }\r\n  \r\n  public isRegularUser(id: UserId) {\r\n    const user = this.users[id];\r\n    return user && !this.isBot(id) && !user.pFlags.deleted && !user.pFlags.support;\r\n  }\r\n\r\n  public isNonContactUser(id: UserId) {\r\n    return this.isRegularUser(id) && !this.isContact(id) && id.toPeerId() !== rootScope.myId;\r\n  }\r\n\r\n  public hasUser(id: UserId, allowMin?: boolean) {\r\n    const user = this.users[id];\r\n    return isObject(user) && (allowMin || !user.pFlags.min);\r\n  }\r\n\r\n  public canSendToUser(id: UserId) {\r\n    const user = this.getUser(id);\r\n    return !user.pFlags.deleted && user.id.toPeerId() !== REPLIES_PEER_ID;\r\n  }\r\n\r\n  public getUserPhoto(id: UserId) {\r\n    const user = this.getUser(id);\r\n\r\n    return user && user.photo || {\r\n      _: 'userProfilePhotoEmpty'\r\n    };\r\n  }\r\n\r\n  public getUserString(id: UserId) {\r\n    const user = this.getUser(id);\r\n    return 'u' + id + (user.access_hash ? '_' + user.access_hash : '');\r\n  }\r\n\r\n  public getUserInput(id: UserId): InputUser {\r\n    const user = this.getUser(id);\r\n    if(user.pFlags && user.pFlags.self) {\r\n      return {_: 'inputUserSelf'};\r\n    }\r\n\r\n    return {\r\n      _: 'inputUser',\r\n      user_id: id,\r\n      access_hash: user.access_hash\r\n    };\r\n  }\r\n\r\n  public getUserInputPeer(id: UserId): InputPeer.inputPeerSelf | InputPeer.inputPeerUser {\r\n    const user = this.getUser(id);\r\n    if(user.pFlags && user.pFlags.self) {\r\n      return {_: 'inputPeerSelf'};\r\n    }\r\n\r\n    return {\r\n      _: 'inputPeerUser',\r\n      user_id: id,\r\n      access_hash: user.access_hash\r\n    };\r\n  }\r\n\r\n  public getContactMediaInput(id: UserId): InputMedia.inputMediaContact {\r\n    const user = this.getUser(id);\r\n\r\n    return {\r\n      _: 'inputMediaContact',\r\n      first_name: user.first_name,\r\n      last_name: user.last_name,\r\n      phone_number: user.phone,\r\n      vcard: '',\r\n      user_id: id\r\n    };\r\n  }\r\n\r\n  public updateUsersStatuses = () => {\r\n    const timestampNow = tsNow(true);\r\n    for(const i in this.users) {\r\n      const user = this.users[i];\r\n      this.updateUserStatus(user, timestampNow);\r\n    }\r\n  };\r\n\r\n  public updateUserStatus(user: MTUser.user, timestampNow = tsNow(true)) {\r\n    if(user.status &&\r\n      user.status._ === 'userStatusOnline' &&\r\n      user.status.expires < timestampNow) {\r\n      user.status = {_: 'userStatusOffline', was_online: user.status.expires};\r\n      rootScope.dispatchEvent('user_update', user.id);\r\n\r\n      this.setUserToStateIfNeeded(user);\r\n    }\r\n  }\r\n\r\n  public forceUserOnline(id: UserId, eventTimestamp?: number) {\r\n    if(this.isBot(id)) {\r\n      return;\r\n    }\r\n\r\n    const timestamp = tsNow(true);\r\n    const onlineTimeFor = 60;\r\n    if(eventTimestamp) {\r\n      if((timestamp - eventTimestamp) >= onlineTimeFor) {\r\n        return;\r\n      }\r\n    } else if(apiUpdatesManager.updatesState.syncLoading) {\r\n      return;\r\n    }\r\n\r\n    const user = this.getUser(id);\r\n    if(user &&\r\n      user.status &&\r\n      user.status._ !== 'userStatusOnline' &&\r\n      user.status._ !== 'userStatusEmpty' &&\r\n      !user.pFlags.support &&\r\n      !user.pFlags.deleted) {\r\n\r\n      user.status = {\r\n        _: 'userStatusOnline',\r\n        expires: timestamp + onlineTimeFor\r\n      };\r\n      \r\n      //user.sortStatus = this.getUserStatusForSort(user.status);\r\n      rootScope.dispatchEvent('user_update', id);\r\n\r\n      this.setUserToStateIfNeeded(user);\r\n    }\r\n  }\r\n\r\n  public importContact(first_name: string, last_name: string, phone: string) {\r\n    return this.importContacts([{\r\n      first_name,\r\n      last_name,\r\n      phones: [phone]\r\n    }]).then(userIds => {\r\n      if(!userIds.length) {\r\n        const error = new Error();\r\n        (error as any).type = 'NO_USER';\r\n        throw error;\r\n      }\r\n\r\n      return userIds[0];\r\n    });\r\n  }\r\n\r\n  public importContacts(contacts: {phones: string[], first_name: string, last_name: string}[]) {\r\n    const inputContacts: InputContact[] = [];\r\n\r\n    for(let i = 0; i < contacts.length; ++i) {\r\n      for(let j = 0; j < contacts[i].phones.length; ++j) {\r\n        inputContacts.push({\r\n          _: 'inputPhoneContact',\r\n          client_id: (i << 16 | j).toString(10),\r\n          phone: contacts[i].phones[j],\r\n          first_name: contacts[i].first_name,\r\n          last_name: contacts[i].last_name\r\n        });\r\n      }\r\n    }\r\n\r\n    return apiManager.invokeApi('contacts.importContacts', {\r\n      contacts: inputContacts\r\n    }).then((importedContactsResult) => {\r\n      this.saveApiUsers(importedContactsResult.users);\r\n\r\n      const userIds = importedContactsResult.imported.map((importedContact) => {\r\n        this.onContactUpdated(importedContact.user_id, true);\r\n        return importedContact.user_id;\r\n      });\r\n\r\n      return userIds;\r\n    });\r\n  }\r\n\r\n  public getTopPeers(type: TopPeerType) {\r\n    if(this.getTopPeersPromises[type]) return this.getTopPeersPromises[type];\r\n\r\n    return this.getTopPeersPromises[type] = appStateManager.getState().then((state) => {\r\n      const cached = state.topPeersCache[type];\r\n      if(cached && (cached.cachedTime + 86400e3) > Date.now() && cached.peers) {\r\n        return cached.peers;\r\n      }\r\n\r\n      return apiManager.invokeApi('contacts.getTopPeers', {\r\n        [type]: true,\r\n        offset: 0,\r\n        limit: 15,\r\n        hash: '0'\r\n      }).then((result) => {\r\n        let topPeers: MyTopPeer[] = [];\r\n        if(result._ === 'contacts.topPeers') {\r\n          //console.log(result);\r\n          this.saveApiUsers(result.users);\r\n          appChatsManager.saveApiChats(result.chats);\r\n\r\n          if(result.categories.length) {\r\n            topPeers = result.categories[0].peers.map((topPeer) => {\r\n              const peerId = appPeersManager.getPeerId(topPeer.peer);\r\n              appStateManager.requestPeer(peerId, 'topPeer');\r\n              return {id: peerId, rating: topPeer.rating};\r\n            });\r\n          }\r\n        }\r\n  \r\n        state.topPeersCache[type] = {\r\n          peers: topPeers,\r\n          cachedTime: Date.now()\r\n        };\r\n        appStateManager.pushToState('topPeersCache', state.topPeersCache);\r\n  \r\n        return topPeers;\r\n      });\r\n    });\r\n  }\r\n\r\n  public getBlocked(offset = 0, limit = 0) {\r\n    return apiManager.invokeApiSingle('contacts.getBlocked', {offset, limit}).then(contactsBlocked => {\r\n      this.saveApiUsers(contactsBlocked.users);\r\n      appChatsManager.saveApiChats(contactsBlocked.chats);\r\n      const count = contactsBlocked._ === 'contacts.blocked' ? contactsBlocked.users.length + contactsBlocked.chats.length : contactsBlocked.count;\r\n\r\n      const peerIds: PeerId[] = contactsBlocked.users.map(u => u.id.toPeerId()).concat(contactsBlocked.chats.map(c => c.id.toPeerId(true)));\r\n\r\n      return {count, peerIds};\r\n    });\r\n  }\r\n\r\n  public getLocated(\r\n    lat: number, \r\n    long: number,\r\n    accuracy_radius: number,\r\n    background: boolean = false,\r\n    self_expires: number = 0\r\n  ) {\r\n    const geo_point: InputGeoPoint = {\r\n      _: 'inputGeoPoint',\r\n      lat,\r\n      long,\r\n      accuracy_radius\r\n    };\r\n\r\n    return apiManager.invokeApi('contacts.getLocated', {\r\n      geo_point, \r\n      background\r\n    }).then((updates) => {\r\n      apiUpdatesManager.processUpdateMessage(updates);\r\n      return updates;\r\n    });\r\n  }\r\n\r\n  /* public searchContacts(query: string, limit = 20) {\r\n    return Promise.all([\r\n      this.getContacts(query),\r\n      apiManager.invokeApi('contacts.search', {\r\n        q: query,\r\n        limit\r\n      })\r\n    ]).then(results => {\r\n      const [myContacts, peers] = results;\r\n\r\n      this.saveApiUsers(peers.users);\r\n      appChatsManager.saveApiChats(peers.chats);\r\n\r\n      // * contacts.search returns duplicates in my_results\r\n      const myResults = new Set(myContacts.concat(peers.my_results.map(p => appPeersManager.getPeerID(p))));\r\n\r\n      const out = {\r\n        my_results: [...myResults].slice(0, limit),\r\n        results: peers.results.map(p => appPeersManager.getPeerID(p))\r\n      };\r\n\r\n      return out;\r\n    });\r\n  } */\r\n  public searchContacts(query: string, limit = 20) {\r\n    // handle 't.me/username' as 'username'\r\n    const entities = RichTextProcessor.parseEntities(query);\r\n    if(entities.length && entities[0].length === query.trim().length && entities[0]._ === 'messageEntityUrl') {\r\n      try {\r\n        const url = new URL(RichTextProcessor.wrapUrl(query).url);\r\n        const path = url.pathname.slice(1);\r\n        if(path) {\r\n          query = path;\r\n        }\r\n      } catch(err) {}\r\n    }\r\n\r\n    return apiManager.invokeApiCacheable('contacts.search', {\r\n      q: query,\r\n      limit\r\n    }, {cacheSeconds: 60}).then(peers => {\r\n      this.saveApiUsers(peers.users);\r\n      appChatsManager.saveApiChats(peers.chats);\r\n\r\n      const out = {\r\n        my_results: filterUnique(peers.my_results.map(p => appPeersManager.getPeerId(p))), // ! contacts.search returns duplicates in my_results\r\n        results: peers.results.map(p => appPeersManager.getPeerId(p))\r\n      };\r\n\r\n      return out;\r\n    });\r\n  }\r\n\r\n  private onContactUpdated(userId: UserId, isContact: boolean, curIsContact = this.isContact(userId)) {\r\n    if(isContact !== curIsContact) {\r\n      if(isContact) {\r\n        this.pushContact(userId);\r\n      } else {\r\n        this.popContact(userId);\r\n      }\r\n\r\n      this.onContactsModified();\r\n\r\n      rootScope.dispatchEvent('contacts_update', userId);\r\n    }\r\n  }\r\n\r\n  public updateUsername(username: string) {\r\n    return apiManager.invokeApi('account.updateUsername', {\r\n      username\r\n    }).then((user) => {\r\n      this.saveApiUser(user);\r\n    });\r\n  }\r\n\r\n  public setUserStatus(userId: UserId, offline: boolean) {\r\n    if(this.isBot(userId)) {\r\n      return;\r\n    }\r\n\r\n    const user = this.users[userId];\r\n    if(user) {\r\n      const status: UserStatus = offline ? {\r\n        _: 'userStatusOffline',\r\n        was_online: tsNow(true)\r\n      } : {\r\n        _: 'userStatusOnline',\r\n        expires: tsNow(true) + 50\r\n      };\r\n\r\n      user.status = status;\r\n      //user.sortStatus = this.getUserStatusForSort(user.status);\r\n      rootScope.dispatchEvent('user_update', userId);\r\n\r\n      this.setUserToStateIfNeeded(user);\r\n    }\r\n  }\r\n\r\n  public addContact(userId: UserId, first_name: string, last_name: string, phone: string, showPhone?: true) {\r\n    /* if(!userId) {\r\n      return this.importContacts([{\r\n        first_name,\r\n        last_name,\r\n        phones: [phone]\r\n      }]);\r\n    } */\r\n\r\n    return apiManager.invokeApi('contacts.addContact', {\r\n      id: this.getUserInput(userId),\r\n      first_name,\r\n      last_name,\r\n      phone,\r\n      add_phone_privacy_exception: showPhone\r\n    }).then((updates) => {\r\n      apiUpdatesManager.processUpdateMessage(updates, {override: true});\r\n\r\n      this.onContactUpdated(userId, true);\r\n    });\r\n  }\r\n\r\n  public deleteContacts(userIds: UserId[]) {\r\n    return apiManager.invokeApi('contacts.deleteContacts', {\r\n      id: userIds.map(userId => this.getUserInput(userId))\r\n    }).then((updates) => {\r\n      apiUpdatesManager.processUpdateMessage(updates, {override: true});\r\n\r\n      userIds.forEach(userId => {\r\n        this.onContactUpdated(userId, false);\r\n      });\r\n    });\r\n  }\r\n\r\n  public isRestricted(userId: UserId) {\r\n    const user: MTUser.user = this.getUser(userId);\r\n    const restrictionReasons = user.restriction_reason;\r\n\r\n    return !!(user.pFlags.restricted && restrictionReasons && isRestricted(restrictionReasons));\r\n  }\r\n}\r\n\r\nconst appUsersManager = new AppUsersManager();\r\nMOUNT_CLASS_TO.appUsersManager = appUsersManager;\r\nexport default appUsersManager\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n * \r\n * Originally from:\r\n * https://github.com/zhukov/webogram\r\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\r\n * https://github.com/zhukov/webogram/blob/master/LICENSE\r\n */\r\n\r\nimport type { Chat, ChatPhoto, DialogPeer, InputChannel, InputDialogPeer, InputNotifyPeer, InputPeer, Peer, Update, User, UserProfilePhoto } from \"../../layer\";\r\nimport type { LangPackKey } from \"../langPack\";\r\nimport { MOUNT_CLASS_TO } from \"../../config/debug\";\r\nimport { RichTextProcessor } from \"../richtextprocessor\";\r\nimport rootScope from \"../rootScope\";\r\nimport appChatsManager from \"./appChatsManager\";\r\nimport appUsersManager from \"./appUsersManager\";\r\nimport I18n from '../langPack';\r\nimport { NULL_PEER_ID } from \"../mtproto/mtproto_config\";\r\nimport { getRestrictionReason } from \"../../helpers/restrictions\";\r\nimport isObject from \"../../helpers/object/isObject\";\r\nimport limitSymbols from \"../../helpers/string/limitSymbols\";\r\n\r\n// https://github.com/eelcohn/Telegram-API/wiki/Calculating-color-for-a-Telegram-user-on-IRC\r\n/*\r\n  HTML-color  IRC-color  Description\r\n  #c03d33     4          red\r\n  #4fad2d     3          green\r\n  #d09306     7          yellow\r\n  #168acd     10         blue\r\n  #8544d6     6          purple\r\n  #cd4073     13         pink\r\n  #2996ad     11         sea\r\n  #ce671b     5          orange\r\n  */\r\nconst DialogColorsFg = ['#fc5c51', '#0fb297', '#d09306', '#3d72ed', '#895dd5', '#cd4073', '#00c1a6', '#fa790f'];\r\nconst DialogColors = ['red', 'green', 'yellow', 'blue', 'violet', 'pink', 'cyan', 'orange'];\r\nconst DialogColorsMap = [0, 7, 4, 1, 6, 3, 5];\r\n\r\nexport type PeerType = 'channel' | 'chat' | 'megagroup' | 'group' | 'saved';\r\nexport class AppPeersManager {\r\n  /* public savePeerInstance(peerId: PeerId, instance: any) {\r\n    if(peerId < 0) appChatsManager.saveApiChat(instance);\r\n    else appUsersManager.saveApiUser(instance);\r\n  } */\r\n\r\n  public canPinMessage(peerId: PeerId) {\r\n    return peerId.isUser() || appChatsManager.hasRights(peerId.toChatId(), 'pin_messages');\r\n  }\r\n\r\n  public getPeerPhoto(peerId: PeerId): UserProfilePhoto.userProfilePhoto | ChatPhoto.chatPhoto {\r\n    if(this.isRestricted(peerId)) {\r\n      return;\r\n    }\r\n\r\n    const photo = peerId.isUser() \r\n      ? appUsersManager.getUserPhoto(peerId.toUserId())\r\n      : appChatsManager.getChatPhoto(peerId.toChatId());\r\n\r\n    return photo._ !== 'chatPhotoEmpty' && photo._ !== 'userProfilePhotoEmpty' ? photo : undefined;\r\n  }\r\n\r\n  public getPeerMigratedTo(peerId: PeerId) {\r\n    if(peerId.isUser()) {\r\n      return false;\r\n    }\r\n\r\n    const chat: Chat.chat = appChatsManager.getChat(peerId.toChatId());\r\n    if(chat && chat.migrated_to && chat.pFlags.deactivated) {\r\n      return this.getPeerId(chat.migrated_to as InputChannel.inputChannel);\r\n    }\r\n    \r\n    return false;\r\n  }\r\n\r\n  public getPeerTitle(peerId: PeerId, plainText: true, onlyFirstName?: boolean, _limitSymbols?: number): string;\r\n  public getPeerTitle(peerId: PeerId, plainText?: false, onlyFirstName?: boolean, _limitSymbols?: number): DocumentFragment;\r\n  public getPeerTitle(peerId: PeerId, plainText: boolean, onlyFirstName?: boolean, _limitSymbols?: number): DocumentFragment | string;\r\n  public getPeerTitle(peerId: PeerId, plainText = false, onlyFirstName = false, _limitSymbols?: number): DocumentFragment | string {\r\n    if(!peerId) {\r\n      peerId = rootScope.myId;\r\n    }\r\n    \r\n    let title = '';\r\n    if(peerId.isUser()) {\r\n      const user = appUsersManager.getUser(peerId.toUserId());\r\n      if(user.first_name) title += user.first_name;\r\n      if(user.last_name && (!onlyFirstName || !title)) title += ' ' + user.last_name;\r\n  \r\n      if(!title) title = user.pFlags.deleted ? I18n.format('HiddenName', true) : user.username;\r\n      else title = title.trim();\r\n    } else {\r\n      const chat: Chat.chat = appChatsManager.getChat(peerId.toChatId());\r\n      title = chat.title;\r\n\r\n      if(onlyFirstName) {\r\n        title = title.split(' ')[0];\r\n      }\r\n    }\r\n\r\n    if(_limitSymbols !== undefined) {\r\n      title = limitSymbols(title, _limitSymbols, _limitSymbols);\r\n    }\r\n    \r\n    return plainText ? title : RichTextProcessor.wrapEmojiText(title);\r\n  }\r\n\r\n  public getOutputPeer(peerId: PeerId): Peer {\r\n    if(peerId.isUser()) {\r\n      return {_: 'peerUser', user_id: peerId.toUserId()};\r\n    }\r\n\r\n    const chatId = peerId.toChatId();\r\n    if(appChatsManager.isChannel(chatId)) {\r\n      return {_: 'peerChannel', channel_id: chatId};\r\n    }\r\n\r\n    return {_: 'peerChat', chat_id: chatId};\r\n  }\r\n\r\n  public getPeerString(peerId: PeerId) {\r\n    if(peerId.isUser()) {\r\n      return appUsersManager.getUserString(peerId.toUserId());\r\n    }\r\n    return appChatsManager.getChatString(peerId.toChatId());\r\n  }\r\n\r\n  public getPeerUsername(peerId: PeerId): string {\r\n    return this.getPeer(peerId).username || '';\r\n  }\r\n\r\n  public getPeer(peerId: PeerId) {\r\n    return peerId.isUser()\r\n      ? appUsersManager.getUser(peerId.toUserId())\r\n      : appChatsManager.getChat(peerId.toChatId());\r\n  }\r\n\r\n  public getPeerInitials(peerId: PeerId) {\r\n    const peer: Chat | User = this.getPeer(peerId);\r\n    return RichTextProcessor.getAbbreviation(\r\n      (peer as Chat.chat).title ?? [(peer as User.user).first_name, (peer as User.user).last_name].filter(Boolean).join(' ')\r\n    );\r\n  }\r\n\r\n  public getPeerId(peerId: {user_id: UserId} | {channel_id: ChatId} | {chat_id: ChatId} | InputPeer | PeerId | string): PeerId {\r\n    if(peerId !== undefined && ((peerId as string).isPeerId ? (peerId as string).isPeerId() : false)) return peerId as PeerId;\r\n    // if(typeof(peerId) === 'string' && /^[uc]/.test(peerId)) return peerId as PeerId;\r\n    // if(typeof(peerId) === 'number') return peerId;\r\n    else if(isObject(peerId)) {\r\n      const userId = (peerId as Peer.peerUser).user_id;\r\n      if(userId !== undefined) {\r\n        return userId.toPeerId(false);\r\n      }\r\n\r\n      const chatId = (peerId as Peer.peerChannel).channel_id || (peerId as Peer.peerChat).chat_id;\r\n      if(chatId !== undefined) {\r\n        return chatId.toPeerId(true);\r\n      }\r\n\r\n      return rootScope.myId; // maybe it is an inputPeerSelf\r\n    // } else if(!peerId) return 'u0';\r\n    } else if(!peerId) return NULL_PEER_ID;\r\n    \r\n    const isUser = (peerId as string).charAt(0) === 'u';\r\n    const peerParams = (peerId as string).substr(1).split('_');\r\n\r\n    return isUser ? peerParams[0].toPeerId() : (peerParams[0] || '').toPeerId(true);\r\n  }\r\n\r\n  public getDialogPeer(peerId: PeerId): DialogPeer {\r\n    return {\r\n      _: 'dialogPeer',\r\n      peer: this.getOutputPeer(peerId)\r\n    };\r\n  }\r\n\r\n  public isChannel(peerId: PeerId): boolean {\r\n    return !peerId.isUser() && appChatsManager.isChannel(peerId.toChatId());\r\n  }\r\n\r\n  public isMegagroup(peerId: PeerId) {\r\n    return !peerId.isUser() && appChatsManager.isMegagroup(peerId.toChatId());\r\n  }\r\n\r\n  public isAnyGroup(peerId: PeerId): boolean {\r\n    return !peerId.isUser() && !appChatsManager.isBroadcast(peerId.toChatId());\r\n  }\r\n\r\n  public isBroadcast(peerId: PeerId): boolean {\r\n    return this.isChannel(peerId) && !this.isMegagroup(peerId);\r\n  }\r\n\r\n  public isBot(peerId: PeerId): boolean {\r\n    return peerId.isUser() && appUsersManager.isBot(peerId.toUserId());\r\n  }\r\n\r\n  public isContact(peerId: PeerId): boolean {\r\n    return peerId.isUser() && appUsersManager.isContact(peerId.toUserId());\r\n  }\r\n\r\n  public isUser(peerId: PeerId)/* : peerId is UserId */ {\r\n    return +peerId >= 0;\r\n  }\r\n  \r\n  public isAnyChat(peerId: PeerId) {\r\n    return !this.isUser(peerId);\r\n  }\r\n\r\n  public isRestricted(peerId: PeerId) {\r\n    return peerId.isUser() ? appUsersManager.isRestricted(peerId.toUserId()) : appChatsManager.isRestricted(peerId.toChatId());\r\n  }\r\n\r\n  public getRestrictionReasonText(peerId: PeerId) {\r\n    const peer: Chat.channel | User.user = this.getPeer(peerId);\r\n    const reason = peer.restriction_reason ? getRestrictionReason(peer.restriction_reason) : undefined;\r\n    if(reason) {\r\n      return reason.text;\r\n    } else {\r\n      return peerId.isUser() ? 'This user is restricted' : 'This chat is restricted';\r\n    }\r\n  }\r\n\r\n  /* public getInputPeer(peerString: string): InputPeer {\r\n    var firstChar = peerString.charAt(0);\r\n    var peerParams = peerString.substr(1).split('_');\r\n    let id = +peerParams[0];\r\n\r\n    if(firstChar === 'u') {\r\n      //appUsersManager.saveUserAccess(id, peerParams[1]);\r\n\r\n      return {\r\n        _: 'inputPeerUser',\r\n        user_id: id,\r\n        access_hash: peerParams[1]\r\n      };\r\n    } else if(firstChar === 'c' || firstChar === 's') {\r\n      //appChatsManager.saveChannelAccess(id, peerParams[1]);\r\n      if(firstChar === 's') {\r\n        appChatsManager.saveIsMegagroup(id);\r\n      }\r\n\r\n      return {\r\n        _: 'inputPeerChannel',\r\n        channel_id: id,\r\n        access_hash: peerParams[1] || '0'\r\n      };\r\n    } else {\r\n      return {\r\n        _: 'inputPeerChat',\r\n        chat_id: id\r\n      };\r\n    }\r\n  } */\r\n\r\n  public getInputNotifyPeerById(peerId: PeerId, ignorePeerId: true): Exclude<InputNotifyPeer, InputNotifyPeer.inputNotifyPeer>;\r\n  public getInputNotifyPeerById(peerId: PeerId, ignorePeerId?: false): InputNotifyPeer.inputNotifyPeer;\r\n  public getInputNotifyPeerById(peerId: PeerId, ignorePeerId?: boolean): InputNotifyPeer {\r\n    if(ignorePeerId) {\r\n      if(peerId.isUser()) {\r\n        return {_: 'inputNotifyUsers'};\r\n      } else {\r\n        if(this.isBroadcast(peerId)) {\r\n          return {_: 'inputNotifyBroadcasts'};\r\n        } else {\r\n          return {_: 'inputNotifyChats'};\r\n        }\r\n      }\r\n    } else {\r\n      return {\r\n        _: 'inputNotifyPeer', \r\n        peer: this.getInputPeerById(peerId)\r\n      };\r\n    }\r\n  }\r\n\r\n  public getInputPeerById(peerId: PeerId): InputPeer {\r\n    if(!peerId) {\r\n      return {_: 'inputPeerEmpty'};\r\n    }\r\n\r\n    if(!peerId.isUser()) {\r\n      const chatId = peerId.toChatId();\r\n      return appChatsManager.getInputPeer(chatId);\r\n    }\r\n\r\n    const userId = peerId.toUserId();\r\n    return appUsersManager.getUserInputPeer(userId);\r\n  }\r\n\r\n  public getInputPeerSelf(): InputPeer.inputPeerSelf {\r\n    return {_: 'inputPeerSelf'};\r\n  }\r\n\r\n  public getInputDialogPeerById(peerId: PeerId | InputPeer): InputDialogPeer {\r\n    return {\r\n      _: 'inputDialogPeer',\r\n      peer: isObject<InputPeer>(peerId) ? peerId : this.getInputPeerById(peerId)\r\n    };\r\n  }\r\n\r\n  public getPeerColorById(peerId: PeerId, pic = true) {\r\n    if(!peerId) return '';\r\n\r\n    const idx = DialogColorsMap[Math.abs(+peerId) % 7];\r\n    const color = (pic ? DialogColors : DialogColorsFg)[idx];\r\n    return color;\r\n  }\r\n\r\n  public getPeerSearchText(peerId: PeerId) {\r\n    let text: string;\r\n    if(this.isUser(peerId)) {\r\n      text = '%pu ' + appUsersManager.getUserSearchText(peerId.toUserId());\r\n    } else {\r\n      const chat = appChatsManager.getChat(peerId.toChatId());\r\n      text = '%pg ' + (chat.title || '');\r\n    }\r\n\r\n    return text;\r\n  }\r\n\r\n  public getDialogType(peerId: PeerId): PeerType {\r\n    if(this.isMegagroup(peerId)) {\r\n      return 'megagroup';\r\n    } else if(this.isChannel(peerId)) {\r\n      return 'channel';\r\n    } else if(!this.isUser(peerId)) {\r\n      return 'group';\r\n    } else {\r\n      return peerId === rootScope.myId ? 'saved' : 'chat';\r\n    }\r\n  }\r\n\r\n  public getDeleteButtonText(peerId: PeerId): LangPackKey {\r\n    switch(this.getDialogType(peerId)) {\r\n      case 'channel':\r\n        return appChatsManager.hasRights(peerId.toChatId(), 'delete_chat') ? 'ChannelDelete' : 'ChatList.Context.LeaveChannel';\r\n\r\n      case 'megagroup':\r\n      case 'group':\r\n        return appChatsManager.hasRights(peerId.toChatId(), 'delete_chat') ? 'DeleteMega' : 'ChatList.Context.LeaveGroup';\r\n      \r\n      default:\r\n        return 'ChatList.Context.DeleteChat';\r\n    }\r\n  }\r\n\r\n  public noForwards(peerId: PeerId) {\r\n    if(peerId.isUser()) return false;\r\n    else {\r\n      const chat = appChatsManager.getChatTyped(peerId.toChatId());\r\n      return !!(chat as Chat.chat).pFlags?.noforwards;\r\n    }\r\n  }\r\n}\r\n\r\nexport type IsPeerType = 'isChannel' | 'isMegagroup' | 'isAnyGroup' | 'isBroadcast' | 'isBot' | 'isContact' | 'isUser' | 'isAnyChat';\r\n\r\n[\r\n  'isChannel',\r\n  'isMegagroup',\r\n  'isAnyGroup',\r\n  'isBroadcast',\r\n  'isBot',\r\n  'isContact',\r\n  'isUser',\r\n  'isAnyChat',\r\n].forEach((value) => {\r\n  const newMethod = Array.isArray(value) ? value[0] : value;\r\n  const originMethod = Array.isArray(value) ? value[1] : value;\r\n  // @ts-ignore\r\n  String.prototype[newMethod] = function() {\r\n    // @ts-ignore\r\n    return appPeersManager[originMethod](this.toString());\r\n  };\r\n\r\n  // @ts-ignore\r\n  Number.prototype[newMethod] = function() {\r\n    // @ts-ignore\r\n    return appPeersManager[originMethod](this);\r\n  };\r\n});\r\n\r\ndeclare global {\r\n  interface String {\r\n    isChannel(): boolean;\r\n    isMegagroup(): boolean;\r\n    isAnyGroup(): boolean;\r\n    isBroadcast(): boolean;\r\n    isBot(): boolean;\r\n    isContact(): boolean;\r\n    isUser(): boolean;\r\n    isAnyChat(): boolean;\r\n  }\r\n\r\n  interface Number {\r\n    isChannel(): boolean;\r\n    isMegagroup(): boolean;\r\n    isAnyGroup(): boolean;\r\n    isBroadcast(): boolean;\r\n    isBot(): boolean;\r\n    isContact(): boolean;\r\n    isUser(): boolean;\r\n    isAnyChat(): boolean;\r\n  }\r\n}\r\n\r\nconst appPeersManager = new AppPeersManager();\r\nMOUNT_CLASS_TO.appPeersManager = appPeersManager;\r\nexport default appPeersManager;\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n * \r\n * Originally from:\r\n * https://github.com/zhukov/webogram\r\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\r\n * https://github.com/zhukov/webogram/blob/master/LICENSE\r\n */\r\n\r\nimport type { Chat, DialogPeer, Message, MessagesPeerDialogs, Update } from \"../../layer\";\r\nimport type { AppChatsManager } from \"../appManagers/appChatsManager\";\r\nimport type { AppMessagesManager, Dialog, MyMessage } from \"../appManagers/appMessagesManager\";\r\nimport type { AppPeersManager } from \"../appManagers/appPeersManager\";\r\nimport type { AppUsersManager } from \"../appManagers/appUsersManager\";\r\nimport type { AppDraftsManager } from \"../appManagers/appDraftsManager\";\r\nimport type { AppNotificationsManager } from \"../appManagers/appNotificationsManager\";\r\nimport type { ApiUpdatesManager } from \"../appManagers/apiUpdatesManager\";\r\nimport type { ServerTimeManager } from \"../mtproto/serverTimeManager\";\r\nimport type { AppMessagesIdsManager } from \"../appManagers/appMessagesIdsManager\";\r\nimport { tsNow } from \"../../helpers/date\";\r\nimport apiManager from \"../mtproto/mtprotoworker\";\r\nimport SearchIndex from \"../searchIndex\";\r\nimport rootScope from \"../rootScope\";\r\nimport { AppStateManager } from \"../appManagers/appStateManager\";\r\nimport { SliceEnd } from \"../../helpers/slicedArray\";\r\nimport { MyDialogFilter } from \"./filters\";\r\nimport { NULL_PEER_ID } from \"../mtproto/mtproto_config\";\r\nimport { NoneToVoidFunction } from \"../../types\";\r\nimport ctx from \"../../environment/ctx\";\r\nimport AppStorage from \"../storage\";\r\nimport type DATABASE_STATE from \"../../config/databases/state\";\r\nimport forEachReverse from \"../../helpers/array/forEachReverse\";\r\nimport indexOfAndSplice from \"../../helpers/array/indexOfAndSplice\";\r\nimport insertInDescendSortedArray from \"../../helpers/array/insertInDescendSortedArray\";\r\nimport defineNotNumerableProperties from \"../../helpers/object/defineNotNumerableProperties\";\r\nimport safeReplaceObject from \"../../helpers/object/safeReplaceObject\";\r\n\r\nexport type FolderDialog = {\r\n  dialog: Dialog,\r\n  index: number\r\n};\r\n\r\nexport type Folder = {\r\n  dialogs: Dialog[],\r\n  id: number,\r\n  unreadMessagesCount: number,\r\n  unreadDialogsCount: number,\r\n  dispatchUnreadTimeout?: number\r\n};\r\n\r\nexport const GLOBAL_FOLDER_ID: number = undefined;\r\n\r\n// let spentTime = 0;\r\nexport default class DialogsStorage {\r\n  private storage: AppStateManager['storages']['dialogs'];\r\n  \r\n  private dialogs: {[peerId: PeerId]: Dialog};\r\n\r\n  private folders: {[folderId: number]: Folder} = {};\r\n\r\n  private allDialogsLoaded: {[folder_id: number]: boolean};\r\n  private dialogsOffsetDate: {[folder_id: number]: number};\r\n  private pinnedOrders: {[folder_id: number]: PeerId[]};\r\n  private dialogsNum: number;\r\n\r\n  private dialogsIndex: SearchIndex<PeerId>;\r\n\r\n  private cachedResults: {\r\n    query: string,\r\n    count: number,\r\n    dialogs: Dialog[],\r\n    folderId: number\r\n  };\r\n\r\n  constructor(\r\n    private appMessagesManager: AppMessagesManager, \r\n    private appChatsManager: AppChatsManager, \r\n    private appPeersManager: AppPeersManager, \r\n    private appUsersManager: AppUsersManager,\r\n    private appDraftsManager: AppDraftsManager,\r\n    private appNotificationsManager: AppNotificationsManager,\r\n    private appStateManager: AppStateManager,\r\n    private apiUpdatesManager: ApiUpdatesManager,\r\n    private serverTimeManager: ServerTimeManager,\r\n    private appMessagesIdsManager: AppMessagesIdsManager\r\n  ) {\r\n    this.storage = this.appStateManager.storages.dialogs;\r\n    this.dialogs = this.storage.getCache();\r\n    this.clear(true);\r\n\r\n    rootScope.addEventListener('language_change', () => {\r\n      const peerId = appUsersManager.getSelf().id.toPeerId(false);\r\n      const dialog = this.getDialogOnly(peerId);\r\n      if(dialog) {\r\n        const peerText = appPeersManager.getPeerSearchText(peerId);\r\n        this.dialogsIndex.indexObject(peerId, peerText);\r\n      }\r\n    });\r\n\r\n    const onFilterUpdate = (filter: MyDialogFilter) => {\r\n      const dialogs = this.getCachedDialogs(false);\r\n      for(let i = 0; i < dialogs.length; ++i) {\r\n        this.processDialogForFilter(dialogs[i], filter);\r\n      }\r\n    };\r\n\r\n    rootScope.addEventListener('filter_order', () => {\r\n      const dialogs = this.getCachedDialogs(false);\r\n      for(const filterId in this.folders) {\r\n        if(+filterId > 1) {\r\n          delete this.folders[filterId];\r\n        }\r\n      }\r\n\r\n      for(let i = 0; i < dialogs.length; ++i) {\r\n        const dialog = dialogs[i];\r\n        for(let i = 0; i <= 10; ++i) {\r\n          const indexKey = `index_${i}` as ReturnType<DialogsStorage['getDialogIndexKey']>;\r\n          dialog[indexKey] = undefined;\r\n        }\r\n\r\n        this.processDialogForFilters(dialog);\r\n      }\r\n    });\r\n\r\n    rootScope.addEventListener('filter_update', onFilterUpdate);\r\n    rootScope.addEventListener('filter_new', onFilterUpdate);\r\n\r\n    rootScope.addEventListener('filter_delete', (filter) => {\r\n      const dialogs = this.getCachedDialogs(false);\r\n\r\n      const indexKey = `index_${filter.orderIndex}` as const;\r\n      for(let i = 0; i < dialogs.length; ++i) {\r\n        const dialog = dialogs[i];\r\n        delete dialog[indexKey];\r\n      }\r\n\r\n      delete this.folders[filter.id];\r\n    });\r\n\r\n    rootScope.addEventListener('dialog_notify_settings', (dialog) => {\r\n      this.processDialogForFilters(dialog);\r\n    });\r\n\r\n    rootScope.addEventListener('chat_update', (chatId) => {\r\n      const chat: Chat.chat = this.appChatsManager.getChat(chatId);\r\n\r\n      const peerId = chatId.toPeerId(true);\r\n      if(chat.pFlags.left && this.getDialogOnly(peerId)) {\r\n        this.dropDialogOnDeletion(peerId);\r\n      }\r\n    });\r\n\r\n    rootScope.addMultipleEventsListeners({\r\n      updateFolderPeers: this.onUpdateFolderPeers,\r\n\r\n      updateDialogPinned: this.onUpdateDialogPinned,\r\n\r\n      updatePinnedDialogs: this.onUpdatePinnedDialogs,\r\n    });\r\n\r\n    appStateManager.getState().then((state) => {\r\n      this.pinnedOrders = state.pinnedOrders || {};\r\n      if(!this.pinnedOrders[0]) this.pinnedOrders[0] = [];\r\n      if(!this.pinnedOrders[1]) this.pinnedOrders[1] = [];\r\n      \r\n      const dialogs = appStateManager.storagesResults.dialogs;\r\n      if(dialogs.length) {\r\n        AppStorage.freezeSaving<typeof DATABASE_STATE>(this.setDialogsFromState.bind(this, dialogs), ['chats', 'dialogs', 'messages', 'users']);\r\n      }\r\n\r\n      this.allDialogsLoaded = state.allDialogsLoaded || {};\r\n    });\r\n  }\r\n\r\n  private setDialogsFromState(dialogs: Dialog[]) {\r\n    for(let i = 0, length = dialogs.length; i < length; ++i) {\r\n      const dialog = dialogs[i];\r\n      if(dialog) {\r\n        // if(dialog.peerId !== SERVICE_PEER_ID) {\r\n          dialog.top_message = this.appMessagesIdsManager.getServerMessageId(dialog.top_message); // * fix outgoing message to avoid copying dialog\r\n        // }\r\n\r\n        if(dialog.topMessage) {\r\n          this.appMessagesManager.saveMessages([dialog.topMessage]);\r\n        }\r\n\r\n        for(let i = 0; i <= 10; ++i) {\r\n          // @ts-ignore\r\n          delete dialog[`index_${i}`];\r\n        }\r\n\r\n        this.saveDialog(dialog, undefined, true);\r\n\r\n        // ! WARNING, убрать это когда нужно будет делать чтобы pending сообщения сохранялись\r\n        const message = this.appMessagesManager.getMessageByPeer(dialog.peerId, dialog.top_message);\r\n        if(message.deleted) {\r\n          this.appMessagesManager.reloadConversation(dialog.peerId);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  public isDialogsLoaded(folderId: number) {\r\n    return !!this.allDialogsLoaded[folderId];\r\n  }\r\n\r\n  public setDialogsLoaded(folderId: number, loaded: boolean) {\r\n    if(folderId === GLOBAL_FOLDER_ID && loaded) {\r\n      this.allDialogsLoaded[0] = loaded;\r\n      this.allDialogsLoaded[1] = loaded;\r\n    } else {\r\n      this.allDialogsLoaded[folderId] = loaded;\r\n    }\r\n\r\n    if(this.allDialogsLoaded[0] && this.allDialogsLoaded[1]) {\r\n      this.allDialogsLoaded[GLOBAL_FOLDER_ID] = true;\r\n    }\r\n\r\n    this.appStateManager.pushToState('allDialogsLoaded', this.allDialogsLoaded);\r\n  }\r\n\r\n  public clear(init = false) {\r\n    this.pinnedOrders = {\r\n      0: [],\r\n      1: []\r\n    };\r\n\r\n    if(!init) {\r\n      const dialogs = this.appStateManager.storagesResults.dialogs;\r\n      dialogs.length = 0;\r\n      this.storage.clear();\r\n\r\n      this.setDialogsLoaded(0, false);\r\n      this.setDialogsLoaded(1, false);\r\n      this.setDialogsLoaded(GLOBAL_FOLDER_ID, false);\r\n      this.savePinnedOrders();\r\n    } else {\r\n      this.allDialogsLoaded = {};\r\n    }\r\n\r\n    this.folders = {};\r\n    this.dialogsOffsetDate = {};\r\n    this.dialogsNum = 0;\r\n    this.dialogsIndex = new SearchIndex({\r\n      clearBadChars: true,\r\n      ignoreCase: true,\r\n      latinize: true,\r\n      includeTag: true\r\n    });\r\n    this.cachedResults = {\r\n      query: '',\r\n      count: 0,\r\n      dialogs: [],\r\n      folderId: 0\r\n    };\r\n  }\r\n\r\n  public handleDialogUnpinning(dialog: Dialog, folderId: number) {\r\n    delete dialog.pFlags.pinned;\r\n    indexOfAndSplice(this.pinnedOrders[folderId], dialog.peerId);\r\n    this.savePinnedOrders();\r\n  }\r\n\r\n  public savePinnedOrders() {\r\n    this.appStateManager.pushToState('pinnedOrders', this.pinnedOrders);\r\n  }\r\n\r\n  public resetPinnedOrder(folderId: number) {\r\n    this.pinnedOrders[folderId] = [];\r\n  }\r\n\r\n  public getPinnedOrders(folderId: number) {\r\n    return this.pinnedOrders[folderId];\r\n  }\r\n\r\n  public getOffsetDate(folderId: number): number {\r\n    const offsetDate = this.dialogsOffsetDate[folderId] || 0;\r\n    if(folderId === GLOBAL_FOLDER_ID && !offsetDate) { // make request not from beginning if we have loaded some dialogs\r\n      return Math.min(this.getOffsetDate(0), this.getOffsetDate(1));\r\n    }\r\n\r\n    return offsetDate;\r\n  }\r\n\r\n  public getFolder(id: number) {\r\n    return this.folders[id] ?? (this.folders[id] = {dialogs: [], id, unreadMessagesCount: 0, unreadDialogsCount: 0});\r\n  }\r\n\r\n  public getFolderDialogs(id: number, skipMigrated = true): Dialog[] {\r\n    if(id === GLOBAL_FOLDER_ID) { // * it won't be sorted\r\n      return this.getCachedDialogs(skipMigrated);\r\n    }\r\n\r\n    const folder = this.getFolder(id);\r\n    return skipMigrated ? folder.dialogs.filter(dialog => dialog.migratedTo === undefined) : folder.dialogs;\r\n  }\r\n\r\n  public getCachedDialogs(skipMigrated?: boolean) {\r\n    return this.getFolderDialogs(0, skipMigrated).concat(this.getFolderDialogs(1, skipMigrated));\r\n  }\r\n\r\n  private setDialogIndexInFilter(dialog: Dialog, indexKey: ReturnType<DialogsStorage['getDialogIndexKey']>, filter: MyDialogFilter) {\r\n    let index: number;\r\n\r\n    if(this.appMessagesManager.filtersStorage.testDialogForFilter(dialog, filter)) {\r\n      const pinnedIndex = filter.pinnedPeerIds.indexOf(dialog.peerId);\r\n      if(pinnedIndex !== -1) {\r\n        index = this.generateDialogIndex(this.generateDialogPinnedDateByIndex(filter.pinned_peers.length - 1 - pinnedIndex), true);\r\n      } else if(dialog.pFlags?.pinned) {\r\n        index = this.generateIndexForDialog(dialog, true);\r\n      } else {\r\n        index = dialog.index;\r\n      }\r\n    }\r\n\r\n    return dialog[indexKey] = index;\r\n  }\r\n\r\n  public getDialog(peerId: PeerId, folderId?: number, skipMigrated = true): [Dialog, number] | [] {\r\n    const folders: Dialog[][] = [];\r\n\r\n    if(folderId === undefined) {\r\n      folders.push(this.getFolder(0).dialogs, this.getFolder(1).dialogs);\r\n    } else {\r\n      folders.push(this.getFolderDialogs(folderId, false));\r\n    }\r\n\r\n    for(let folder of folders) {\r\n      let i = 0, skipped = 0;\r\n      for(let length = folder.length; i < length; ++i) {\r\n        const dialog = folder[i];\r\n        if(dialog.peerId === peerId) {\r\n          return [dialog, i - skipped];\r\n        } else if(skipMigrated && dialog.migratedTo !== undefined) {\r\n          ++skipped;\r\n        }\r\n      }\r\n    }\r\n\r\n    return [];\r\n  }\r\n\r\n  public getDialogOnly(peerId: PeerId) {\r\n    return this.dialogs[peerId];\r\n  }\r\n\r\n  /*\r\n  var date = Date.now() / 1000 | 0;\r\n  var m = date * 0x10000;\r\n\r\n  var k = (date + 1) * 0x10000;\r\n  k - m;\r\n  65536\r\n  */\r\n  public generateDialogIndex(date?: number, isPinned?: boolean) {\r\n    if(date === undefined) {\r\n      date = tsNow(true) + this.serverTimeManager.serverTimeOffset;\r\n    }\r\n\r\n    return (date * 0x10000) + (isPinned ? 0 : ((++this.dialogsNum) & 0xFFFF));\r\n  }\r\n\r\n  public processDialogForFilters(dialog: Dialog) {\r\n    // let perf = performance.now();\r\n    const filters = this.appMessagesManager.filtersStorage.filters;\r\n    for(const id in filters) {\r\n      const filter = filters[id];\r\n      this.processDialogForFilter(dialog, filter);\r\n    }\r\n    // spentTime += (performance.now() - perf);\r\n    // console.log('generate index time:', spentTime);\r\n  }\r\n\r\n  public processDialogForFilter(dialog: Dialog, filter: MyDialogFilter) {\r\n    const indexKey = this.getDialogIndexKey(filter.id);\r\n    const folder = this.getFolder(filter.id);\r\n    const dialogs = folder.dialogs;\r\n\r\n    const wasIndex = dialogs.findIndex(d => d.peerId === dialog.peerId);\r\n    const wasDialog = dialogs[wasIndex];\r\n    const wasDialogIndex = wasDialog && wasDialog[indexKey];\r\n\r\n    const newDialogIndex = this.setDialogIndexInFilter(dialog, indexKey, filter);\r\n\r\n    if(wasDialogIndex === newDialogIndex) {\r\n      return;\r\n    }\r\n\r\n    if((!wasDialogIndex && newDialogIndex) || (wasIndex && !newDialogIndex)) {\r\n      this.prepareFolderUnreadCountModifyingByDialog(filter.id, dialog, !!newDialogIndex);\r\n    }\r\n\r\n    if(wasIndex !== -1) {\r\n      dialogs.splice(wasIndex, 1);\r\n    }\r\n\r\n    if(newDialogIndex) {\r\n      insertInDescendSortedArray(dialogs, dialog, indexKey, -1);\r\n    }\r\n  }\r\n\r\n  public prepareDialogUnreadCountModifying(dialog: Dialog) {\r\n    const callbacks: NoneToVoidFunction[] = [\r\n      this.prepareFolderUnreadCountModifyingByDialog(dialog.folder_id, dialog)\r\n    ];\r\n\r\n    const filters = this.appMessagesManager.filtersStorage.filters;\r\n    for(const id in filters) {\r\n      const filter = filters[id];\r\n      if(this.appMessagesManager.filtersStorage.testDialogForFilter(dialog, filter)) {\r\n        callbacks.push(this.prepareFolderUnreadCountModifyingByDialog(filter.id, dialog));\r\n      }\r\n    }\r\n\r\n    return () => callbacks.forEach(callback => callback());\r\n  }\r\n\r\n  public prepareFolderUnreadCountModifyingByDialog(folderId: number, dialog: Dialog, toggle?: boolean) {\r\n    const wasUnreadCount = this.appMessagesManager.getDialogUnreadCount(dialog);\r\n    \r\n    if(toggle !== undefined) {\r\n      this.modifyFolderUnreadCount(folderId, toggle ? wasUnreadCount : -wasUnreadCount, wasUnreadCount ? (toggle ? 1 : -1) : 0);\r\n      return;\r\n    }\r\n\r\n    return () => {\r\n      const newUnreadCount = this.appMessagesManager.getDialogUnreadCount(dialog);\r\n      const addMessagesCount = newUnreadCount - wasUnreadCount;\r\n      const addDialogsCount = (newUnreadCount && !wasUnreadCount) || (!newUnreadCount && wasUnreadCount) ? (wasUnreadCount ? -1 : 1) : 0;\r\n      this.modifyFolderUnreadCount(folderId, addMessagesCount, addDialogsCount);\r\n    };\r\n  }\r\n\r\n  public modifyFolderUnreadCount(folderId: number, addMessagesCount: number, addDialogsCount: number) {\r\n    if(!addMessagesCount && !addDialogsCount) {\r\n      return;\r\n    }\r\n\r\n    const folder = this.getFolder(folderId);\r\n    if(addMessagesCount) {\r\n      folder.unreadMessagesCount = Math.max(0, folder.unreadMessagesCount + addMessagesCount);\r\n    }\r\n    \r\n    if(addDialogsCount) {\r\n      folder.unreadDialogsCount = Math.max(0, folder.unreadDialogsCount + addDialogsCount);\r\n    }\r\n\r\n    if(folder.dispatchUnreadTimeout === undefined) {\r\n      folder.dispatchUnreadTimeout = ctx.setTimeout(() => {\r\n        folder.dispatchUnreadTimeout = undefined;\r\n        rootScope.dispatchEvent('folder_unread', folder);\r\n      }, 0);\r\n    }\r\n  }\r\n\r\n  public generateIndexForDialog(dialog: Dialog, justReturn = false, message?: MyMessage) {\r\n    let topDate = 0, isPinned: boolean;\r\n    if(dialog.pFlags.pinned && !justReturn) {\r\n      topDate = this.generateDialogPinnedDate(dialog);\r\n      isPinned = true;\r\n    } else {\r\n      if(!message) {\r\n        message = this.appMessagesManager.getMessageByPeer(dialog.peerId, dialog.top_message);\r\n      }\r\n      \r\n      topDate = (message as Message.message).date || topDate;\r\n\r\n      const channelId = this.appPeersManager.isChannel(dialog.peerId) && dialog.peerId.toChatId();\r\n      if(channelId) {\r\n        const channel: Chat.channel = this.appChatsManager.getChat(channelId);\r\n        if(!topDate || (channel.date && channel.date > topDate)) {\r\n          topDate = channel.date;\r\n        }\r\n      }\r\n  \r\n      if(dialog.draft?._ === 'draftMessage' && dialog.draft.date > topDate) {\r\n        topDate = dialog.draft.date;\r\n      }\r\n    }\r\n\r\n    if(!topDate) {\r\n      topDate = tsNow(true);\r\n    }\r\n\r\n    const index = this.generateDialogIndex(topDate, isPinned);\r\n    if(justReturn) {\r\n      return index;\r\n    }\r\n\r\n    dialog.index = index;\r\n  }\r\n\r\n  public generateDialogPinnedDateByIndex(pinnedIndex: number) {\r\n    return 0x7fff0000 + (pinnedIndex & 0xFFFF); // 0xFFFF - потому что в папках может быть бесконечное число пиннедов\r\n  }\r\n\r\n  public generateDialogPinnedDate(dialog: Dialog) {\r\n    const order = this.pinnedOrders[dialog.folder_id];\r\n\r\n    const foundIndex = order.indexOf(dialog.peerId);\r\n    let pinnedIndex = foundIndex;\r\n    if(foundIndex === -1) {\r\n      pinnedIndex = order.push(dialog.peerId) - 1;\r\n      this.savePinnedOrders();\r\n    }\r\n\r\n    return this.generateDialogPinnedDateByIndex(pinnedIndex);\r\n  }\r\n\r\n  /* public generateDialog(peerId: PeerId) {\r\n    const dialog: Dialog = {\r\n      _: 'dialog',\r\n      pFlags: {},\r\n      peer: this.appPeersManager.getOutputPeer(peerId),\r\n      top_message: 0,\r\n      read_inbox_max_id: 0,\r\n      read_outbox_max_id: 0,\r\n      unread_count: 0,\r\n      unread_mentions_count: 0,\r\n      notify_settings: {\r\n        _: 'peerNotifySettings',\r\n      },\r\n    };\r\n\r\n    return dialog;\r\n  } */\r\n\r\n  public setDialogToState(dialog: Dialog) {\r\n    const {peerId, pts} = dialog;\r\n    const historyStorage = this.appMessagesManager.getHistoryStorage(peerId);\r\n    const messagesStorage = this.appMessagesManager.getMessagesStorage(peerId);\r\n    const history = historyStorage.history.slice;\r\n    let incomingMessage: MyMessage;\r\n    for(let i = 0, length = history.length; i < length; ++i) {\r\n      const mid = history[i];\r\n      const message: MyMessage = this.appMessagesManager.getMessageFromStorage(messagesStorage, mid);\r\n      if(!message.pFlags.is_outgoing && !message.deleted/*  || peerId === SERVICE_PEER_ID */) {\r\n        incomingMessage = message;\r\n  \r\n        const fromId = message.viaBotId || message.fromId;\r\n        if(fromId !== peerId) {\r\n          this.appStateManager.requestPeerSingle(fromId, 'topMessage', peerId);\r\n        }\r\n  \r\n        break;\r\n      }\r\n    }\r\n\r\n    dialog.topMessage = incomingMessage;\r\n\r\n    // DO NOT TOUCH THESE LINES, SOME REAL MAGIC HERE.\r\n    // * Read service chat when refreshing page with outgoing & getting new service outgoing message\r\n    /* if(incomingMessage && dialog.read_inbox_max_id >= dialog.top_message) {\r\n      dialog.unread_count = 0;\r\n    }\r\n\r\n    dialog.read_inbox_max_id = this.appMessagesIdsManager.clearMessageId(dialog.read_inbox_max_id);\r\n    dialog.read_outbox_max_id = this.appMessagesIdsManager.clearMessageId(dialog.read_outbox_max_id); */\r\n    // CAN TOUCH NOW\r\n\r\n    if(peerId.isAnyChat() && pts) {\r\n      const newPts = this.apiUpdatesManager.getChannelState(peerId.toChatId(), pts).pts;\r\n      dialog.pts = newPts;\r\n    }\r\n\r\n    this.storage.set({\r\n      [peerId]: dialog\r\n    });\r\n\r\n    this.appStateManager.requestPeerSingle(peerId, 'dialog');\r\n\r\n    /* for(let id in this.appMessagesManager.filtersStorage.filters) {\r\n      const filter = this.appMessagesManager.filtersStorage.filters[id];\r\n\r\n      if(this.appMessagesManager.filtersStorage.testDialogForFilter(dialog, filter)) {\r\n        \r\n      }\r\n    } */\r\n  }\r\n\r\n  public pushDialog(dialog: Dialog, offsetDate?: number, ignoreOffsetDate?: boolean, saveGlobalOffset?: boolean) {\r\n    const {folder_id, peerId} = dialog;\r\n    const dialogs = this.getFolderDialogs(folder_id, false);\r\n    const pos = dialogs.findIndex(d => d.peerId === peerId);\r\n    if(pos !== -1) {\r\n      dialogs.splice(pos, 1);\r\n    }\r\n    \r\n    //if(!this.dialogs[peerId]) {\r\n      this.dialogs[peerId] = dialog;\r\n      \r\n      this.setDialogToState(dialog);\r\n    //}\r\n\r\n    if(offsetDate === undefined) {\r\n      offsetDate = this.getDialogOffsetDate(dialog);\r\n    }\r\n\r\n    this.processDialogForFilters(dialog);\r\n\r\n    if(offsetDate && !dialog.pFlags.pinned) {\r\n      if(saveGlobalOffset) {\r\n        const savedGlobalOffsetDate = this.dialogsOffsetDate[GLOBAL_FOLDER_ID];\r\n        if(!savedGlobalOffsetDate || offsetDate < savedGlobalOffsetDate) {\r\n          this.dialogsOffsetDate[GLOBAL_FOLDER_ID] = offsetDate;\r\n        }\r\n      }\r\n\r\n      const savedOffsetDate = this.dialogsOffsetDate[folder_id];\r\n      if(!savedOffsetDate || offsetDate < savedOffsetDate) {\r\n        // if(pos !== -1) {\r\n        if(!ignoreOffsetDate && !this.isDialogsLoaded(folder_id)) {\r\n          this.clearDialogFromState(dialog, true);\r\n          return;\r\n        }\r\n  \r\n        this.dialogsOffsetDate[folder_id] = offsetDate;\r\n      }\r\n    }\r\n\r\n    if(pos === -1) {\r\n      this.prepareFolderUnreadCountModifyingByDialog(folder_id, dialog, true);\r\n    }\r\n\r\n    /* const newPos =  */insertInDescendSortedArray(dialogs, dialog, 'index', -1);\r\n    /* if(pos !== -1 && pos !== newPos) {\r\n      rootScope.dispatchEvent('dialog_order', {dialog, pos: newPos});\r\n    } */\r\n  }\r\n\r\n  public dropDialog(peerId: PeerId): ReturnType<DialogsStorage['getDialog']> {\r\n    const foundDialog = this.getDialog(peerId, undefined, false);\r\n    const [dialog, index] = foundDialog;\r\n    if(dialog) {\r\n      delete this.dialogs[peerId];\r\n\r\n      const folder = this.getFolder(dialog.folder_id);\r\n      folder.dialogs.splice(index, 1);\r\n      const wasPinned = indexOfAndSplice(this.pinnedOrders[dialog.folder_id], peerId) !== undefined;\r\n      \r\n      this.processDialogForFilters(dialog);\r\n\r\n      this.dialogsIndex.indexObject(peerId, '');\r\n\r\n      if(wasPinned) {\r\n        this.savePinnedOrders();\r\n      }\r\n\r\n      this.clearDialogFromState(dialog, false);\r\n    }\r\n\r\n    return foundDialog;\r\n  }\r\n\r\n  public clearDialogFromState(dialog: Dialog, keepLocal: boolean) {\r\n    const peerId = dialog.peerId;\r\n    this.appStateManager.releaseSinglePeer(peerId, 'topMessage');\r\n    this.appStateManager.releaseSinglePeer(peerId, 'dialog');\r\n    this.storage.delete(peerId, keepLocal);\r\n  }\r\n\r\n  public dropDialogWithEvent(peerId: PeerId) {\r\n    const dropped = this.dropDialog(peerId);\r\n    if(dropped.length) {\r\n      rootScope.dispatchEvent('dialog_drop', {peerId, dialog: dropped[0]});\r\n    }\r\n\r\n    return dropped;\r\n  }\r\n\r\n  /**\r\n   * leaving chat, leaving channel, deleting private dialog\r\n   */\r\n  public dropDialogOnDeletion(peerId: PeerId) {\r\n    this.dropDialogWithEvent(peerId);\r\n    rootScope.dispatchEvent('peer_deleted', peerId);\r\n  }\r\n\r\n  public applyDialogs(dialogsResult: MessagesPeerDialogs.messagesPeerDialogs) {\r\n    // * В эту функцию попадут только те диалоги, в которых есть read_inbox_max_id и read_outbox_max_id, в отличие от тех, что будут в getTopMessages\r\n\r\n    // ! fix 'dialogFolder', maybe there is better way to do it, this only can happen by 'messages.getPinnedDialogs' by folder_id: 0\r\n    forEachReverse(dialogsResult.dialogs, (dialog, idx) => {\r\n      if(dialog._ === 'dialogFolder') {\r\n        dialogsResult.dialogs.splice(idx, 1);\r\n      }\r\n    });\r\n\r\n    this.appUsersManager.saveApiUsers(dialogsResult.users);\r\n    this.appChatsManager.saveApiChats(dialogsResult.chats);\r\n    this.appMessagesManager.saveMessages(dialogsResult.messages);\r\n\r\n    // this.appMessagesManager.log('applyConversation', dialogsResult);\r\n\r\n    const updatedDialogs: {[peerId: PeerId]: Dialog} = {};\r\n    (dialogsResult.dialogs as Dialog[]).forEach((dialog) => {\r\n      const peerId = this.appPeersManager.getPeerId(dialog.peer);\r\n      let topMessage = dialog.top_message;\r\n\r\n      const topPendingMessage = this.appMessagesManager.pendingTopMsgs[peerId];\r\n      if(topPendingMessage) {\r\n        if(!topMessage \r\n          || (this.appMessagesManager.getMessageByPeer(peerId, topPendingMessage) as MyMessage).date > (this.appMessagesManager.getMessageByPeer(peerId, topMessage) as MyMessage).date) {\r\n          dialog.top_message = topMessage = topPendingMessage;\r\n          this.appMessagesManager.getHistoryStorage(peerId).maxId = topPendingMessage;\r\n        }\r\n      }\r\n\r\n      /* const d = Object.assign({}, dialog);\r\n      if(peerId === 239602833) {\r\n        this.log.error('applyConversation lun', dialog, d);\r\n      } */\r\n\r\n      if(topMessage || (dialog.draft && dialog.draft._ === 'draftMessage')) {\r\n        this.saveDialog(dialog);\r\n        updatedDialogs[peerId] = dialog;\r\n      } else {\r\n        this.dropDialogWithEvent(peerId);\r\n      }\r\n\r\n      const updates = this.appMessagesManager.newUpdatesAfterReloadToHandle[peerId];\r\n      if(updates !== undefined) {\r\n        for(const update of updates) {\r\n          updates.delete(update);\r\n          this.apiUpdatesManager.saveUpdate(update);\r\n        }\r\n\r\n        if(!updates.size) {\r\n          delete this.appMessagesManager.newUpdatesAfterReloadToHandle[peerId];\r\n        }\r\n      }\r\n    });\r\n\r\n    if(Object.keys(updatedDialogs).length) {\r\n      rootScope.dispatchEvent('dialogs_multiupdate', updatedDialogs);\r\n    }\r\n  }\r\n\r\n  public getDialogOffsetDate(dialog: Dialog) {\r\n    return this.appMessagesManager.getMessageByPeer(dialog.peerId, dialog.top_message).date || 0;\r\n  }\r\n\r\n  /**\r\n   * Won't save migrated from peer, forbidden peers, left and kicked\r\n   */\r\n  public saveDialog(dialog: Dialog, folderId = dialog.folder_id ?? 0, ignoreOffsetDate?: boolean, saveGlobalOffset?: boolean) {\r\n    const peerId = this.appPeersManager.getPeerId(dialog.peer);\r\n    if(!peerId) {\r\n      console.error('saveConversation no peerId???', dialog, folderId);\r\n      return;\r\n    }\r\n\r\n    if(dialog._ !== 'dialog'/*  || peerId === 239602833 */) {\r\n      console.error('saveConversation not regular dialog', dialog, Object.assign({}, dialog));\r\n    }\r\n    \r\n    const channelId = this.appPeersManager.isChannel(peerId) ? peerId.toChatId() : NULL_PEER_ID;\r\n\r\n    if(peerId.isAnyChat()) {\r\n      const chat: Chat = this.appChatsManager.getChat(peerId.toChatId());\r\n      // ! chatForbidden stays for chat where you're kicked\r\n      if(\r\n        chat._ === 'channelForbidden' \r\n        // || chat._ === 'chatForbidden' \r\n        || (chat as Chat.chat).pFlags.left \r\n        // || (chat as any).pFlags.kicked\r\n      ) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    const peerText = this.appPeersManager.getPeerSearchText(peerId);\r\n    this.dialogsIndex.indexObject(peerId, peerText);\r\n\r\n    const wasDialogBefore = this.getDialogOnly(peerId);\r\n\r\n    let mid: number, message: MyMessage;\r\n    if(dialog.top_message) {\r\n      mid = this.appMessagesIdsManager.generateMessageId(dialog.top_message);//dialog.top_message;\r\n\r\n      // preserve outgoing message\r\n      const wasTopMessage = wasDialogBefore?.top_message && this.appMessagesManager.getMessageByPeer(peerId, wasDialogBefore.top_message) as MyMessage;\r\n      if(wasTopMessage?.pFlags?.is_outgoing && wasDialogBefore.top_message >= mid) {\r\n        mid = wasDialogBefore.top_message;\r\n      }\r\n\r\n      message = this.appMessagesManager.getMessageByPeer(peerId, mid);\r\n    } else {\r\n      mid = this.appMessagesManager.generateTempMessageId(peerId);\r\n      message = {\r\n        _: 'message',\r\n        id: mid,\r\n        mid,\r\n        from_id: this.appPeersManager.getOutputPeer(this.appUsersManager.getSelf().id.toPeerId(false)),\r\n        peer_id: this.appPeersManager.getOutputPeer(peerId),\r\n        deleted: true,\r\n        pFlags: {out: true},\r\n        date: 0,\r\n        message: ''\r\n      };\r\n      this.appMessagesManager.saveMessages([message], {isOutgoing: true});\r\n    }\r\n\r\n    if(!message?.pFlags) {\r\n      this.appMessagesManager.log.error('saveConversation no message:', dialog, message);\r\n    }\r\n\r\n    if(!channelId && peerId.isAnyChat()) {\r\n      const chat = this.appChatsManager.getChat(peerId.toChatId());\r\n      if(chat && chat.migrated_to && chat.pFlags.deactivated) {\r\n        const migratedToPeer = this.appPeersManager.getPeerId(chat.migrated_to);\r\n        this.appMessagesManager.migratedFromTo[peerId] = migratedToPeer;\r\n        this.appMessagesManager.migratedToFrom[migratedToPeer] = peerId;\r\n        dialog.migratedTo = migratedToPeer;\r\n        //return;\r\n      }\r\n    }\r\n\r\n    dialog.top_message = mid;\r\n    // dialog.unread_count = wasDialogBefore && dialog.read_inbox_max_id === this.appMessagesIdsManager.getServerMessageId(wasDialogBefore.read_inbox_max_id) ? wasDialogBefore.unread_count : dialog.unread_count;\r\n    dialog.read_inbox_max_id = this.appMessagesIdsManager.generateMessageId(wasDialogBefore && !dialog.read_inbox_max_id ? wasDialogBefore.read_inbox_max_id : dialog.read_inbox_max_id);\r\n    dialog.read_outbox_max_id = this.appMessagesIdsManager.generateMessageId(wasDialogBefore && !dialog.read_outbox_max_id ? wasDialogBefore.read_outbox_max_id : dialog.read_outbox_max_id);\r\n\r\n    if(dialog.folder_id === undefined) {\r\n      if(dialog._ === 'dialog') {\r\n        // ! СЛОЖНО ! СМОТРИ В getTopMessages\r\n        dialog.folder_id = wasDialogBefore ? wasDialogBefore.folder_id : folderId;\r\n      }/*  else if(dialog._ === 'dialogFolder') {\r\n        dialog.folder_id = dialog.folder.id;\r\n      } */\r\n    }\r\n\r\n    dialog.draft = this.appDraftsManager.saveDraft(peerId, 0, dialog.draft);\r\n    dialog.peerId = peerId;\r\n\r\n    // Because we saved message without dialog present\r\n    if(message.pFlags.is_outgoing) {\r\n      const isOut = message.pFlags.out;\r\n      if(mid > dialog[isOut ? 'read_outbox_max_id' : 'read_inbox_max_id']) {\r\n        message.pFlags.unread = true;\r\n\r\n        if(!dialog.unread_count && !isOut) {\r\n          ++dialog.unread_count;\r\n        }\r\n      } else {\r\n        delete message.pFlags.unread;\r\n      }\r\n    }\r\n\r\n    const historyStorage = this.appMessagesManager.getHistoryStorage(peerId);\r\n    const slice = historyStorage.history.slice;\r\n    /* if(historyStorage === undefined) { // warning\r\n      historyStorage.history.push(mid);\r\n    } else  */if(!slice.length) {\r\n      historyStorage.history.unshift(mid);\r\n      historyStorage.count ||= 1;\r\n      if(this.appMessagesManager.mergeReplyKeyboard(historyStorage, message)) {\r\n        rootScope.dispatchEvent('history_reply_markup', {peerId});\r\n      }\r\n    } else if(!slice.isEnd(SliceEnd.Bottom)) { // * this will probably never happen, however, if it does, then it will fix slice with top_message\r\n      const slice = historyStorage.history.insertSlice([mid]);\r\n      slice.setEnd(SliceEnd.Bottom);\r\n      historyStorage.count ||= 1;\r\n      if(this.appMessagesManager.mergeReplyKeyboard(historyStorage, message)) {\r\n        rootScope.dispatchEvent('history_reply_markup', {peerId});\r\n      }\r\n    }\r\n\r\n    historyStorage.maxId = mid;\r\n    historyStorage.readMaxId = dialog.read_inbox_max_id;\r\n    historyStorage.readOutboxMaxId = dialog.read_outbox_max_id;\r\n\r\n    this.appNotificationsManager.savePeerSettings({\r\n      peerId, \r\n      settings: dialog.notify_settings\r\n    });\r\n\r\n    if(channelId && dialog.pts) {\r\n      this.apiUpdatesManager.addChannelState(channelId, dialog.pts);\r\n    }\r\n\r\n    this.generateIndexForDialog(dialog);\r\n\r\n    defineNotNumerableProperties(dialog, [\r\n      'index_0',\r\n      'index_1',\r\n      'index_2',\r\n      'index_3',\r\n      'index_4',\r\n      'index_5',\r\n      'index_6',\r\n      'index_7',\r\n      'index_8',\r\n      'index_9',\r\n      'index_10'\r\n    ]);\r\n\r\n    if(wasDialogBefore) {\r\n      safeReplaceObject(wasDialogBefore, dialog);\r\n    }\r\n\r\n    this.pushDialog(dialog, message.date, ignoreOffsetDate, saveGlobalOffset);\r\n  }\r\n\r\n  public getDialogIndexKey(filterId: number) {\r\n    const indexStr = filterId > 1 ? \r\n      `index_${this.appMessagesManager.filtersStorage.getFilter(filterId).orderIndex}` as const : \r\n      'index' as const;\r\n\r\n    return indexStr;\r\n  }\r\n\r\n  public getDialogs(query = '', offsetIndex?: number, limit = 20, folderId = 0, skipMigrated = false): {\r\n    cached: boolean,\r\n    promise: Promise<{\r\n      dialogs: Dialog[],\r\n      count: number,\r\n      isTopEnd: boolean,\r\n      isEnd: boolean\r\n    }>\r\n  } {\r\n    const ret: {\r\n      cached: boolean,\r\n      promise: Promise<{\r\n        dialogs: Dialog[],\r\n        count: number,\r\n        isTopEnd: boolean,\r\n        isEnd: boolean\r\n      }>\r\n    } = {} as any;\r\n\r\n    if(folderId > 1) {\r\n      const promises: Promise<any>[] = [];\r\n\r\n      const fillContactsResult = this.appUsersManager.fillContacts();\r\n      if(!fillContactsResult.cached) {\r\n        promises.push(fillContactsResult.promise);\r\n      }\r\n\r\n      const reloadMissingDialogsPromise = this.appMessagesManager.filtersStorage.reloadMissingPeerIds(folderId);\r\n      if(reloadMissingDialogsPromise) {\r\n        promises.push(reloadMissingDialogsPromise);\r\n      }\r\n\r\n      if(promises.length) {\r\n        ret.cached = false;\r\n        ret.promise = Promise.all(promises).then(() => {\r\n          return this.getDialogs(query, offsetIndex, limit, folderId, skipMigrated).promise;\r\n        });\r\n\r\n        return ret;\r\n      }\r\n    }\r\n\r\n    // let's load only first pages by certain folderId. next pages will load without folder filtering\r\n    const realFolderId = folderId > 1 || this.getOffsetDate(folderId) ? GLOBAL_FOLDER_ID : folderId;\r\n    let curDialogStorage = this.getFolderDialogs(folderId, skipMigrated);\r\n\r\n    const indexStr = this.getDialogIndexKey(folderId);\r\n\r\n    if(query) {\r\n      if(!limit || this.cachedResults.query !== query || this.cachedResults.folderId !== folderId) {\r\n        this.cachedResults.query = query;\r\n        this.cachedResults.folderId = folderId;\r\n\r\n        const results = this.dialogsIndex.search(query);\r\n\r\n        const dialogs: Dialog[] = [];\r\n        for(const peerId in this.dialogs) {\r\n          const dialog = this.dialogs[peerId];\r\n          if(results.has(dialog.peerId) && dialog.folder_id === folderId) {\r\n            dialogs.push(dialog);\r\n          }\r\n        }\r\n\r\n        dialogs.sort((d1, d2) => d2[indexStr] - d1[indexStr]);\r\n        this.cachedResults.dialogs = dialogs;\r\n        this.cachedResults.count = dialogs.length;\r\n      }\r\n\r\n      curDialogStorage = this.cachedResults.dialogs;\r\n    } else {\r\n      this.cachedResults.query = '';\r\n    }\r\n\r\n    let offset = 0;\r\n    if(offsetIndex > 0) {\r\n      for(let length = curDialogStorage.length; offset < length; ++offset) {\r\n        if(offsetIndex > curDialogStorage[offset][indexStr]) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    const loadedAll = this.isDialogsLoaded(realFolderId);\r\n    const isEnoughDialogs = curDialogStorage.length >= (offset + limit);\r\n    if(query || loadedAll || isEnoughDialogs) {\r\n      const dialogs = curDialogStorage.slice(offset, offset + limit);\r\n      ret.cached = true;\r\n      ret.promise = Promise.resolve({\r\n        dialogs,\r\n        count: loadedAll ? curDialogStorage.length : null,\r\n        isTopEnd: curDialogStorage.length && ((dialogs[0] && dialogs[0] === curDialogStorage[0]) || curDialogStorage[0][indexStr] < offsetIndex),\r\n        isEnd: (query || loadedAll) && (offset + limit) >= curDialogStorage.length\r\n      });\r\n\r\n      return ret;\r\n    }\r\n\r\n    ret.cached = false;\r\n    ret.promise = this.appMessagesManager.getTopMessages(limit, realFolderId).then(result => {\r\n      //const curDialogStorage = this[folderId];\r\n      if(skipMigrated) {\r\n        curDialogStorage = this.getFolderDialogs(folderId, skipMigrated);\r\n      }\r\n\r\n      offset = 0;\r\n      if(offsetIndex > 0) {\r\n        for(let length = curDialogStorage.length; offset < length; ++offset) {\r\n          if(offsetIndex > curDialogStorage[offset][indexStr]) {\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      //this.log.warn(offset, offset + limit, curDialogStorage.dialogs.length, this.dialogs.length);\r\n\r\n      const dialogs = curDialogStorage.slice(offset, offset + limit);\r\n      return {\r\n        dialogs,\r\n        count: result.count === undefined ? curDialogStorage.length : result.count,\r\n        isTopEnd: curDialogStorage.length && ((dialogs[0] && dialogs[0] === curDialogStorage[0]) || curDialogStorage[0][indexStr] < offsetIndex),\r\n        // isEnd: this.isDialogsLoaded(realFolderId) && (offset + limit) >= curDialogStorage.length\r\n        isEnd: result.isEnd\r\n      };\r\n    });\r\n\r\n    return ret;\r\n  }\r\n\r\n  // only 0 and 1 folders\r\n  private onUpdateFolderPeers = (update: Update.updateFolderPeers) => {\r\n    //this.log('updateFolderPeers', update);\r\n    const peers = update.folder_peers;\r\n\r\n    peers.forEach((folderPeer) => {\r\n      const {folder_id, peer} = folderPeer;\r\n\r\n      const peerId = this.appPeersManager.getPeerId(peer);\r\n      const dialog = this.dropDialog(peerId)[0];\r\n      if(dialog) {\r\n        if(dialog.pFlags?.pinned) {\r\n          this.handleDialogUnpinning(dialog, folder_id);\r\n        }\r\n\r\n        dialog.folder_id = folder_id;\r\n        this.generateIndexForDialog(dialog);\r\n        this.pushDialog(dialog); // need for simultaneously updatePinnedDialogs\r\n      }\r\n\r\n      this.appMessagesManager.scheduleHandleNewDialogs(peerId, dialog);\r\n    });\r\n  };\r\n\r\n  private onUpdateDialogPinned = (update: Update.updateDialogPinned) => {\r\n    const folderId = update.folder_id ?? 0;\r\n    //this.log('updateDialogPinned', update);\r\n    const peerId = this.appPeersManager.getPeerId((update.peer as DialogPeer.dialogPeer).peer);\r\n    const dialog = this.getDialogOnly(peerId);\r\n\r\n    // этот код внизу никогда не сработает, в папках за пиннед отвечает updateDialogFilter\r\n    /* if(update.folder_id > 1) {\r\n      const filter = this.filtersStorage.filters[update.folder_id];\r\n      if(update.pFlags.pinned) {\r\n        filter.pinned_peers.unshift(peerId);\r\n      } else {\r\n        filter.pinned_peers.findAndSplice(p => p === peerId);\r\n      }\r\n    } */\r\n\r\n    if(dialog) {\r\n      if(!update.pFlags.pinned) {\r\n        this.handleDialogUnpinning(dialog, folderId);\r\n      } else { // means set\r\n        dialog.pFlags.pinned = true;\r\n      }\r\n\r\n      this.generateIndexForDialog(dialog);\r\n    } \r\n\r\n    this.appMessagesManager.scheduleHandleNewDialogs(peerId, dialog);\r\n  };\r\n\r\n  private onUpdatePinnedDialogs = (update: Update.updatePinnedDialogs) => {\r\n    const folderId = update.folder_id ?? 0;\r\n        \r\n    const handleOrder = (order: PeerId[]) => {\r\n      this.pinnedOrders[folderId].length = 0;\r\n      order.reverse(); // index must be higher\r\n      order.forEach((peerId) => {\r\n        newPinned[peerId] = true;\r\n  \r\n        const dialog = this.getDialogOnly(peerId);\r\n        this.appMessagesManager.scheduleHandleNewDialogs(peerId, dialog);\r\n        if(!dialog) {\r\n          return;\r\n        }\r\n  \r\n        dialog.pFlags.pinned = true;\r\n        this.generateIndexForDialog(dialog);\r\n      });\r\n      \r\n      const dialogs = this.getFolderDialogs(folderId, false);\r\n      for(const dialog of dialogs) {\r\n        if(!dialog.pFlags.pinned) {\r\n          break;\r\n        }\r\n\r\n        const peerId = dialog.peerId;\r\n        if(!newPinned[peerId]) {\r\n          this.appMessagesManager.scheduleHandleNewDialogs(peerId);\r\n        }\r\n      }\r\n    };\r\n\r\n    //this.log('updatePinnedDialogs', update);\r\n    const newPinned: {[peerId: PeerId]: true} = {};\r\n    if(!update.order) {\r\n      apiManager.invokeApi('messages.getPinnedDialogs', {\r\n        folder_id: folderId\r\n      }).then((dialogsResult) => {\r\n        // * for test reordering and rendering\r\n        // dialogsResult.dialogs.reverse();\r\n\r\n        this.applyDialogs(dialogsResult);\r\n\r\n        handleOrder(dialogsResult.dialogs.map(d => d.peerId));\r\n\r\n        /* dialogsResult.dialogs.forEach((dialog) => {\r\n          newPinned[dialog.peerId] = true;\r\n        });\r\n\r\n        this.dialogsStorage.getFolder(folderId).forEach((dialog) => {\r\n          const peerId = dialog.peerId;\r\n          if(dialog.pFlags.pinned && !newPinned[peerId]) {\r\n            this.newDialogsToHandle[peerId] = {reload: true};\r\n            this.scheduleHandleNewDialogs();\r\n          }\r\n        }); */\r\n      });\r\n\r\n      return;\r\n    }\r\n\r\n    //this.log('before order:', this.dialogsStorage[0].map(d => d.peerId));\r\n\r\n    handleOrder(update.order.map(peer => this.appPeersManager.getPeerId((peer as DialogPeer.dialogPeer).peer)));\r\n  };\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport type { DialogFilter, Update } from \"../../layer\";\r\nimport type { ArgumentTypes, Modify } from \"../../types\";\r\nimport type { AppPeersManager } from \"../appManagers/appPeersManager\";\r\nimport type { AppUsersManager } from \"../appManagers/appUsersManager\";\r\n//import type { ApiManagerProxy } from \"../mtproto/mtprotoworker\";\r\nimport type _rootScope from \"../rootScope\";\r\nimport type {AppMessagesManager, Dialog} from '../appManagers/appMessagesManager';\r\nimport type {AppNotificationsManager} from \"../appManagers/appNotificationsManager\";\r\nimport type { ApiUpdatesManager } from \"../appManagers/apiUpdatesManager\";\r\nimport type { AppStateManager } from \"../appManagers/appStateManager\";\r\nimport apiManager from \"../mtproto/mtprotoworker\";\r\nimport forEachReverse from \"../../helpers/array/forEachReverse\";\r\nimport copy from \"../../helpers/object/copy\";\r\nimport safeReplaceObject from \"../../helpers/object/safeReplaceObject\";\r\nimport findAndSplice from \"../../helpers/array/findAndSplice\";\r\n\r\nexport type MyDialogFilter = Modify<DialogFilter, {\r\n  /* pinned_peers: PeerId[],\r\n  include_peers: PeerId[],\r\n  exclude_peers: PeerId[], */\r\n  pinnedPeerIds: PeerId[],\r\n  includePeerIds: PeerId[],\r\n  excludePeerIds: PeerId[]\r\n}>;\r\n\r\nconst convertment = [\r\n  ['pinned_peers', 'pinnedPeerIds'], \r\n  ['exclude_peers', 'excludePeerIds'], \r\n  ['include_peers', 'includePeerIds']\r\n] as ['pinned_peers' | 'exclude_peers' | 'include_peers', 'pinnedPeerIds' | 'excludePeerIds' | 'includePeerIds'][];\r\n\r\n// ! because 0 index is 'All Chats'\r\nconst START_ORDER_INDEX = 1;\r\n\r\nexport default class FiltersStorage {\r\n  public filters: {[filterId: string]: MyDialogFilter};\r\n  private orderIndex: number;\r\n  private reloadedPeerIds: Set<PeerId>;\r\n\r\n  constructor(private appMessagesManager: AppMessagesManager,\r\n    private appPeersManager: AppPeersManager, \r\n    private appUsersManager: AppUsersManager, \r\n    private appNotificationsManager: AppNotificationsManager, \r\n    private appStateManager: AppStateManager,\r\n    private apiUpdatesManager: ApiUpdatesManager, \r\n    /* private apiManager: ApiManagerProxy, */ \r\n    private rootScope: typeof _rootScope) {\r\n    this.clear(true);\r\n    this.filters = {};\r\n\r\n    this.appStateManager.getState().then((state) => {\r\n      safeReplaceObject(this.filters, state.filters);\r\n\r\n      for(const filterId in this.filters) {\r\n        const filter = this.filters[filterId];\r\n        if(filter.hasOwnProperty('orderIndex') && filter.orderIndex >= this.orderIndex) {\r\n          this.orderIndex = filter.orderIndex + 1;\r\n        }\r\n\r\n        /* this.appMessagesManager.dialogsStorage.folders[+filterId] = {\r\n          dialogs: []\r\n        }; */\r\n      }\r\n    });\r\n\r\n    rootScope.addMultipleEventsListeners({\r\n      updateDialogFilter: this.onUpdateDialogFilter,\r\n\r\n      updateDialogFilters: (update) => {\r\n        //console.warn('updateDialogFilters', update);\r\n\r\n        const oldFilters = copy(this.filters);\r\n\r\n        this.getDialogFilters(true).then(filters => {\r\n          for(const _filterId in oldFilters) {\r\n            const filterId = +_filterId;\r\n            if(!filters.find(filter => filter.id === filterId)) { // * deleted\r\n              this.onUpdateDialogFilter({_: 'updateDialogFilter', id: filterId});\r\n            }\r\n          }\r\n\r\n          this.onUpdateDialogFilterOrder({_: 'updateDialogFilterOrder', order: filters.map(filter => filter.id)});\r\n        });\r\n      },\r\n\r\n      updateDialogFilterOrder: this.onUpdateDialogFilterOrder\r\n    });\r\n\r\n    // delete peers when dialog is being dropped\r\n    /* rootScope.addEventListener('peer_deleted', (peerId) => {\r\n      for(const filterId in this.filters) {\r\n        const filter = this.filters[filterId];\r\n        let modified = false;\r\n        [filter.pinned_peers, filter.include_peers, filter.exclude_peers].forEach(arr => {\r\n          forEachReverse(arr, (inputPeer, idx) => {\r\n            if(this.appPeersManager.getPeerId(inputPeer) === peerId) {\r\n              arr.splice(idx, 1);\r\n              modified = true;\r\n            }\r\n          });\r\n        });\r\n\r\n        if(modified) {\r\n          this.saveDialogFilter(filter, true);\r\n        }\r\n      }\r\n    }); */\r\n  }\r\n\r\n  public clear(init = false) {\r\n    if(!init) {\r\n      safeReplaceObject(this.filters, {});\r\n      this.reloadedPeerIds.clear();\r\n    } else {\r\n      this.filters = {};\r\n      this.reloadedPeerIds = new Set();\r\n    }\r\n\r\n    this.orderIndex = START_ORDER_INDEX;\r\n  }\r\n\r\n  private onUpdateDialogFilter = (update: Update.updateDialogFilter) => {\r\n    if(update.filter) {\r\n      this.saveDialogFilter(update.filter as any);\r\n    } else if(this.filters[update.id]) { // Папка удалена\r\n      //this.getDialogFilters(true);\r\n      this.rootScope.dispatchEvent('filter_delete', this.filters[update.id]);\r\n      delete this.filters[update.id];\r\n    }\r\n\r\n    this.appStateManager.pushToState('filters', this.filters);\r\n  };\r\n\r\n  private onUpdateDialogFilterOrder = (update: Update.updateDialogFilterOrder) => {\r\n    //console.log('updateDialogFilterOrder', update);\r\n\r\n    this.orderIndex = START_ORDER_INDEX;\r\n    update.order.forEach((filterId, idx) => {\r\n      const filter = this.filters[filterId];\r\n      delete filter.orderIndex;\r\n      this.setOrderIndex(filter);\r\n    });\r\n\r\n    this.rootScope.dispatchEvent('filter_order', update.order);\r\n\r\n    this.appStateManager.pushToState('filters', this.filters);\r\n  };\r\n\r\n  public testDialogForFilter(dialog: Dialog, filter: MyDialogFilter) {\r\n    const peerId = dialog.peerId;\r\n\r\n    // * check whether dialog exists\r\n    if(!this.appMessagesManager.getDialogOnly(peerId)) {\r\n      return false;\r\n    }\r\n\r\n    // exclude_peers\r\n    if(filter.excludePeerIds.includes(peerId)) {\r\n      return false;\r\n    }\r\n\r\n    // include_peers\r\n    if(filter.includePeerIds.includes(peerId)) {\r\n      return true;\r\n    }\r\n\r\n    const pFlags = filter.pFlags;\r\n\r\n    // exclude_archived\r\n    if(pFlags.exclude_archived && dialog.folder_id === 1) {\r\n      return false;\r\n    }\r\n\r\n    // exclude_read\r\n    if(pFlags.exclude_read && !this.appMessagesManager.isDialogUnread(dialog)) {\r\n      return false;\r\n    }\r\n\r\n    // exclude_muted\r\n    if(pFlags.exclude_muted && this.appNotificationsManager.isPeerLocalMuted(peerId) && !(dialog.unread_mentions_count && dialog.unread_count)) {\r\n      return false;\r\n    }\r\n\r\n    if(this.appPeersManager.isAnyChat(peerId)) {\r\n      // broadcasts\r\n      if(pFlags.broadcasts && this.appPeersManager.isBroadcast(peerId)) {\r\n        return true;\r\n      }\r\n\r\n      // groups\r\n      if(pFlags.groups && this.appPeersManager.isAnyGroup(peerId)) {\r\n        return true;\r\n      }\r\n    } else {\r\n      const userId = peerId.toUserId();\r\n      \r\n      // bots\r\n      if(this.appUsersManager.isBot(userId)) {\r\n        return !!pFlags.bots;\r\n      }\r\n      \r\n      // non_contacts\r\n      if(pFlags.non_contacts && !this.appUsersManager.isContact(userId)) {\r\n        return true;\r\n      }\r\n\r\n      // contacts\r\n      if(pFlags.contacts && this.appUsersManager.isContact(userId)) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  public testDialogForFilterId(dialog: Dialog, filterId: number) {\r\n    return this.testDialogForFilter(dialog, this.filters[filterId]);\r\n  }\r\n\r\n  public getFilter(filterId: number) {\r\n    return this.filters[filterId];\r\n  }\r\n\r\n  public toggleDialogPin(peerId: PeerId, filterId: number) {\r\n    const filter = this.filters[filterId];\r\n\r\n    const index = filter.pinnedPeerIds.indexOf(peerId);\r\n    const wasPinned = index !== -1;\r\n\r\n    if(wasPinned) {\r\n      filter.pinned_peers.splice(index, 1);\r\n      filter.pinnedPeerIds.splice(index, 1);\r\n    }\r\n    \r\n    if(!wasPinned) {\r\n      if(filter.pinned_peers.length >= this.rootScope.config.pinned_infolder_count_max) {\r\n        return Promise.reject({type: 'PINNED_DIALOGS_TOO_MUCH'});\r\n      }\r\n      \r\n      filter.pinned_peers.unshift(this.appPeersManager.getInputPeerById(peerId));\r\n      filter.pinnedPeerIds.unshift(peerId);\r\n    }\r\n    \r\n    return this.updateDialogFilter(filter);\r\n  }\r\n\r\n  public createDialogFilter(filter: MyDialogFilter, prepend?: boolean) {\r\n    const maxId = Math.max(1, ...Object.keys(this.filters).map(i => +i));\r\n    filter = copy(filter);\r\n    filter.id = maxId + 1;\r\n    return this.updateDialogFilter(filter, undefined, prepend);\r\n  }\r\n\r\n  public updateDialogFilter(filter: MyDialogFilter, remove = false, prepend = false) {\r\n    const flags = remove ? 0 : 1;\r\n\r\n    return apiManager.invokeApi('messages.updateDialogFilter', {\r\n      flags,\r\n      id: filter.id,\r\n      filter: remove ? undefined : this.getOutputDialogFilter(filter)\r\n    }).then((bool: boolean) => { // возможно нужна проверка и откат, если результат не ТРУ\r\n      //console.log('updateDialogFilter bool:', bool);\r\n\r\n      if(bool) {\r\n        /* if(!this.filters[filter.id]) {\r\n          this.saveDialogFilter(filter);\r\n        }\r\n\r\n        rootScope.$broadcast('filter_update', filter); */\r\n\r\n        this.onUpdateDialogFilter({\r\n          _: 'updateDialogFilter',\r\n          id: filter.id,\r\n          filter: remove ? undefined : filter as any\r\n        });\r\n\r\n        if(prepend) {\r\n          const f: MyDialogFilter[] = [];\r\n          for(const filterId in this.filters) {\r\n            const filter = this.filters[filterId];\r\n            ++filter.orderIndex;\r\n            f.push(filter);\r\n          }\r\n\r\n          filter.orderIndex = START_ORDER_INDEX;\r\n\r\n          const order = f.sort((a, b) => a.orderIndex - b.orderIndex).map(filter => filter.id);\r\n          this.onUpdateDialogFilterOrder({\r\n            _: 'updateDialogFilterOrder',\r\n            order\r\n          });\r\n        }\r\n      }\r\n\r\n      return bool;\r\n    });\r\n  }\r\n\r\n  public getOutputDialogFilter(filter: MyDialogFilter) {\r\n    const c = copy(filter);\r\n    /* convertment.forEach(([from, to]) => {\r\n      c[from] = c[to].map((peerId) => this.appPeersManager.getInputPeerById(peerId));\r\n    }); */\r\n\r\n    this.filterIncludedPinnedPeers(filter);\r\n\r\n    return c;\r\n  }\r\n\r\n  private filterIncludedPinnedPeers(filter: MyDialogFilter) {\r\n    forEachReverse(filter.includePeerIds, (peerId, idx) => {\r\n      if(filter.pinnedPeerIds.includes(peerId)) {\r\n        filter.include_peers.splice(idx, 1);\r\n        filter.includePeerIds.splice(idx, 1);\r\n      }\r\n    });\r\n  }\r\n\r\n  // private spliceMissingPeerIds(filterId: number, type: ArgumentTypes<FiltersStorage['reloadMissingPeerIds']>[1], missingPeerIds: PeerId[]) {\r\n  //   const filter = this.getFilter(filterId);\r\n  //   const peers = filter && filter[type];\r\n  //   if(!peers?.length) {\r\n  //     return;\r\n  //   }\r\n\r\n  //   let spliced = false;\r\n  //   missingPeerIds.forEach((peerId) => {\r\n  //     const inputPeer = findAndSplice(peers, (inputPeer) => this.appPeersManager.getPeerId(inputPeer) === peerId);\r\n  //     if(inputPeer) {\r\n  //       spliced = true;\r\n  //     }\r\n  //   });\r\n\r\n  //   if(spliced) {\r\n  //     this.onUpdateDialogFilter({\r\n  //       _: 'updateDialogFilter',\r\n  //       id: filterId,\r\n  //       filter\r\n  //     });\r\n  //   }\r\n  // }\r\n\r\n  public reloadMissingPeerIds(filterId: number, type: 'pinned_peers' | 'include_peers' | 'exclude_peers' = 'pinned_peers') {\r\n    const filter = this.getFilter(filterId);\r\n    const peers = filter && filter[type];\r\n    if(!peers?.length) {\r\n      return;\r\n    }\r\n\r\n    // const missingPeerIds: PeerId[] = [];\r\n    const reloadDialogs = peers.filter((inputPeer) => {\r\n      const peerId = this.appPeersManager.getPeerId(inputPeer);\r\n      const isAlreadyReloaded = this.reloadedPeerIds.has(peerId);\r\n      const dialog = this.appMessagesManager.getDialogOnly(peerId);\r\n      // if(isAlreadyReloaded && !dialog) {\r\n      //   missingPeerIds.push(peerId);\r\n      // }\r\n\r\n      const reload = !isAlreadyReloaded && !dialog;\r\n      return reload;\r\n    });\r\n\r\n    if(!reloadDialogs.length) {\r\n      // if(missingPeerIds.length) {\r\n      //   this.spliceMissingPeerIds(filterId, type, missingPeerIds);\r\n      // }\r\n\r\n      return;\r\n    }\r\n\r\n    const reloadPromises = reloadDialogs.map((inputPeer) => {\r\n      const peerId = this.appPeersManager.getPeerId(inputPeer);\r\n      const promise = this.appMessagesManager.reloadConversation(inputPeer)\r\n      .then((dialog) => {\r\n        this.reloadedPeerIds.add(peerId);\r\n\r\n        return dialog ? undefined : peerId;\r\n      });\r\n\r\n      return promise;\r\n    });\r\n\r\n    const reloadPromise = Promise.all(reloadPromises).then((missingPeerIds) => {\r\n      missingPeerIds = missingPeerIds.filter(Boolean);\r\n      if(!missingPeerIds.length) {\r\n        return;\r\n      }\r\n\r\n      // this.spliceMissingPeerIds(filterId, type, missingPeerIds);\r\n    });\r\n\r\n    return reloadPromise;\r\n  }\r\n\r\n  public async getDialogFilters(overwrite = false): Promise<MyDialogFilter[]> {\r\n    const keys = Object.keys(this.filters);\r\n    if(keys.length && !overwrite) {\r\n      return keys.map(filterId => this.filters[filterId]).sort((a, b) => a.orderIndex - b.orderIndex);\r\n    }\r\n\r\n    const filters: MyDialogFilter[] = await apiManager.invokeApiSingle('messages.getDialogFilters') as any;\r\n    for(const filter of filters) {\r\n      this.saveDialogFilter(filter, overwrite);\r\n    }\r\n\r\n    //console.log(this.filters);\r\n    return filters;\r\n  }\r\n\r\n  public saveDialogFilter(filter: MyDialogFilter, update = true) {\r\n    // defineNotNumerableProperties(filter, ['includePeerIds', 'excludePeerIds', 'pinnedPeerIds']);\r\n\r\n    convertment.forEach(([from, to]) => {\r\n      filter[to] = filter[from].map((peer) => this.appPeersManager.getPeerId(peer));\r\n    });\r\n\r\n    this.filterIncludedPinnedPeers(filter);\r\n    \r\n    filter.include_peers = filter.pinned_peers.concat(filter.include_peers);\r\n    filter.includePeerIds = filter.pinnedPeerIds.concat(filter.includePeerIds);\r\n\r\n    const oldFilter = this.filters[filter.id];\r\n    if(oldFilter) {\r\n      Object.assign(oldFilter, filter);\r\n    } else {\r\n      this.filters[filter.id] = filter;\r\n    }\r\n    \r\n    this.setOrderIndex(filter);\r\n    \r\n    if(update) {\r\n      this.rootScope.dispatchEvent('filter_update', filter);\r\n    } else if(!oldFilter) {\r\n      this.rootScope.dispatchEvent('filter_new', filter);\r\n    }\r\n  }\r\n\r\n  public setOrderIndex(filter: MyDialogFilter) {\r\n    if(filter.hasOwnProperty('orderIndex')) {\r\n      if(filter.orderIndex >= this.orderIndex) {\r\n        this.orderIndex = filter.orderIndex + 1;\r\n      }\r\n    } else {\r\n      filter.orderIndex = this.orderIndex++ as DialogFilter['orderIndex'];\r\n    }\r\n\r\n    this.appStateManager.pushToState('filters', this.filters);\r\n  }\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n * \r\n * Originally from:\r\n * https://github.com/zhukov/webogram\r\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\r\n * https://github.com/zhukov/webogram/blob/master/LICENSE\r\n */\r\n\r\nimport { LazyLoadQueueBase } from \"../../components/lazyLoadQueue\";\r\nimport ProgressivePreloader from \"../../components/preloader\";\r\nimport deferredPromise, { CancellablePromise } from \"../../helpers/cancellablePromise\";\r\nimport { formatDateAccordingToTodayNew, formatTime, tsNow } from \"../../helpers/date\";\r\nimport { createPosterForVideo } from \"../../helpers/files\";\r\nimport { randomLong } from \"../../helpers/random\";\r\nimport { Chat, ChatFull, Dialog as MTDialog, DialogPeer, DocumentAttribute, InputMedia, InputMessage, InputPeerNotifySettings, InputSingleMedia, Message, MessageAction, MessageEntity, MessageFwdHeader, MessageMedia, MessageReplies, MessageReplyHeader, MessagesDialogs, MessagesFilter, MessagesMessages, MethodDeclMap, NotifyPeer, PeerNotifySettings, PhotoSize, SendMessageAction, Update, Photo, Updates, ReplyMarkup, InputPeer, InputPhoto, InputDocument, InputGeoPoint, WebPage, GeoPoint, ReportReason, MessagesGetDialogs, InputChannel, InputDialogPeer, ReactionCount, MessagePeerReaction, MessagesSearchCounter, Peer, MessageReactions } from \"../../layer\";\r\nimport { ArgumentTypes, InvokeApiOptions } from \"../../types\";\r\nimport I18n, { FormatterArguments, i18n, join, langPack, LangPackKey, UNSUPPORTED_LANG_PACK_KEY, _i18n } from \"../langPack\";\r\nimport { logger, LogTypes } from \"../logger\";\r\nimport type { ApiFileManager } from '../mtproto/apiFileManager';\r\n//import apiManager from '../mtproto/apiManager';\r\nimport apiManager from '../mtproto/mtprotoworker';\r\nimport referenceDatabase, { ReferenceContext } from \"../mtproto/referenceDatabase\";\r\nimport serverTimeManager from \"../mtproto/serverTimeManager\";\r\nimport { RichTextProcessor } from \"../richtextprocessor\";\r\nimport rootScope from \"../rootScope\";\r\nimport DialogsStorage, { GLOBAL_FOLDER_ID } from \"../storages/dialogs\";\r\nimport FiltersStorage from \"../storages/filters\";\r\n//import { telegramMeWebService } from \"../mtproto/mtproto\";\r\nimport apiUpdatesManager from \"./apiUpdatesManager\";\r\nimport appChatsManager, { ChatRights } from \"./appChatsManager\";\r\nimport appDocsManager, { MyDocument } from \"./appDocsManager\";\r\nimport appDownloadManager from \"./appDownloadManager\";\r\nimport appPeersManager from \"./appPeersManager\";\r\nimport appPhotosManager, { MyPhoto } from \"./appPhotosManager\";\r\nimport appPollsManager from \"./appPollsManager\";\r\nimport appStateManager from \"./appStateManager\";\r\nimport appUsersManager from \"./appUsersManager\";\r\nimport appWebPagesManager from \"./appWebPagesManager\";\r\nimport appDraftsManager, { MyDraftMessage } from \"./appDraftsManager\";\r\nimport { getFileNameByLocation } from \"../../helpers/fileName\";\r\nimport appProfileManager from \"./appProfileManager\";\r\nimport DEBUG, { MOUNT_CLASS_TO } from \"../../config/debug\";\r\nimport SlicedArray, { Slice, SliceEnd } from \"../../helpers/slicedArray\";\r\nimport appNotificationsManager, { NotifyOptions } from \"./appNotificationsManager\";\r\nimport PeerTitle from \"../../components/peerTitle\";\r\nimport htmlToDocumentFragment from \"../../helpers/dom/htmlToDocumentFragment\";\r\nimport htmlToSpan from \"../../helpers/dom/htmlToSpan\";\r\nimport { MUTE_UNTIL, NULL_PEER_ID, REPLIES_HIDDEN_CHANNEL_ID, REPLIES_PEER_ID, SERVICE_PEER_ID } from \"../mtproto/mtproto_config\";\r\nimport formatCallDuration from \"../../helpers/formatCallDuration\";\r\nimport appAvatarsManager from \"./appAvatarsManager\";\r\nimport telegramMeWebManager from \"../mtproto/telegramMeWebManager\";\r\nimport { getMiddleware } from \"../../helpers/middleware\";\r\nimport assumeType from \"../../helpers/assumeType\";\r\nimport appMessagesIdsManager from \"./appMessagesIdsManager\";\r\nimport type { MediaSize } from \"../../helpers/mediaSizes\";\r\nimport IMAGE_MIME_TYPES_SUPPORTED from \"../../environment/imageMimeTypesSupport\";\r\nimport VIDEO_MIME_TYPES_SUPPORTED from \"../../environment/videoMimeTypesSupport\";\r\nimport './appGroupCallsManager';\r\nimport appGroupCallsManager from \"./appGroupCallsManager\";\r\nimport appReactionsManager from \"./appReactionsManager\";\r\nimport { getRestrictionReason, isRestricted } from \"../../helpers/restrictions\";\r\nimport copy from \"../../helpers/object/copy\";\r\nimport getObjectKeysAndSort from \"../../helpers/object/getObjectKeysAndSort\";\r\nimport forEachReverse from \"../../helpers/array/forEachReverse\";\r\nimport indexOfAndSplice from \"../../helpers/array/indexOfAndSplice\";\r\nimport deepEqual from \"../../helpers/object/deepEqual\";\r\nimport escapeRegExp from \"../../helpers/string/escapeRegExp\";\r\nimport limitSymbols from \"../../helpers/string/limitSymbols\";\r\nimport splitStringByLength from \"../../helpers/string/splitStringByLength\";\r\nimport debounce from \"../../helpers/schedulers/debounce\";\r\nimport setInnerHTML from \"../../helpers/dom/setInnerHTML\";\r\n\r\n//console.trace('include');\r\n// TODO: если удалить диалог находясь в папке, то он не удалится из папки и будет виден в настройках\r\n\r\nconst APITIMEOUT = 0;\r\nconst DO_NOT_READ_HISTORY = false;\r\n\r\nexport type HistoryStorage = {\r\n  count: number | null,\r\n  history: SlicedArray<number>,\r\n\r\n  maxId?: number,\r\n  readPromise?: Promise<void>,\r\n  readMaxId?: number,\r\n  readOutboxMaxId?: number,\r\n  triedToReadMaxId?: number,\r\n\r\n  maxOutId?: number,\r\n  replyMarkup?: Exclude<ReplyMarkup, ReplyMarkup.replyInlineMarkup>\r\n};\r\n\r\nexport type HistoryResult = {\r\n  count: number,\r\n  history: Slice<number>,\r\n  offsetIdOffset?: number,\r\n};\r\n\r\nexport type Dialog = MTDialog.dialog;\r\n\r\nexport type MyMessage = Message.message | Message.messageService;\r\nexport type MyInputMessagesFilter = 'inputMessagesFilterEmpty' \r\n  | 'inputMessagesFilterPhotos' \r\n  | 'inputMessagesFilterPhotoVideo' \r\n  | 'inputMessagesFilterVideo' \r\n  | 'inputMessagesFilterDocument' \r\n  | 'inputMessagesFilterVoice' \r\n  | 'inputMessagesFilterRoundVoice' \r\n  | 'inputMessagesFilterRoundVideo' \r\n  | 'inputMessagesFilterMusic' \r\n  | 'inputMessagesFilterUrl' \r\n  | 'inputMessagesFilterMyMentions'\r\n  | 'inputMessagesFilterChatPhotos'\r\n  | 'inputMessagesFilterPinned';\r\n\r\nexport type PinnedStorage = Partial<{\r\n  promise: Promise<PinnedStorage>,\r\n  count: number,\r\n  maxId: number\r\n}>;\r\nexport type MessagesStorage = Map<number, any>;\r\n\r\nexport type MyMessageActionType = Message.messageService['action']['_'];\r\n\r\ntype PendingAfterMsg = Partial<InvokeApiOptions & {\r\n  afterMessageId: string,\r\n  messageId: string\r\n}>;\r\n\r\ntype MapValueType<A> = A extends Map<any, infer V> ? V : never;\r\n\r\nexport type BatchUpdates = {\r\n  'messages_reactions': AppMessagesManager['batchUpdateReactions'],\r\n  'messages_views': AppMessagesManager['batchUpdateViews']\r\n};\r\n\r\nexport class AppMessagesManager {\r\n  private messagesStorageByPeerId: {[peerId: string]: MessagesStorage};\r\n  public groupedMessagesStorage: {[groupId: string]: MessagesStorage}; // will be used for albums\r\n  private scheduledMessagesStorage: {[peerId: PeerId]: MessagesStorage};\r\n  private historiesStorage: {\r\n    [peerId: PeerId]: HistoryStorage\r\n  };\r\n  private threadsStorage: {\r\n    [peerId: PeerId]: {\r\n      [threadId: string]: HistoryStorage\r\n    }\r\n  };\r\n  private searchesStorage: {\r\n    [peerId: PeerId]: Partial<{\r\n      [inputFilter in MyInputMessagesFilter]: {\r\n        count?: number,\r\n        history: number[]\r\n      }\r\n    }>\r\n  };\r\n  public pinnedMessages: {[peerId: PeerId]: PinnedStorage};\r\n\r\n  public threadsServiceMessagesIdsStorage: {[peerId_threadId: string]: number};\r\n  private threadsToReplies: {\r\n    [peerId_threadId: string]: string;\r\n  };\r\n\r\n  private pendingByRandomId: {\r\n    [randomId: string]: {\r\n      peerId: PeerId,\r\n      tempId: number,\r\n      threadId: number,\r\n      storage: MessagesStorage\r\n    }\r\n  } = {};\r\n  private pendingByMessageId: {[mid: string]: Long} = {};\r\n  private pendingAfterMsgs: {[peerId: PeerId]: PendingAfterMsg} = {};\r\n  public pendingTopMsgs: {[peerId: PeerId]: number} = {};\r\n  private tempFinalizeCallbacks: {\r\n    [tempId: string]: {\r\n      [callbackName: string]: Partial<{\r\n        deferred: CancellablePromise<void>, \r\n        callback: (message: MyMessage) => Promise<any>\r\n      }>\r\n    }\r\n  } = {};\r\n  \r\n  private sendSmthLazyLoadQueue = new LazyLoadQueueBase(10);\r\n\r\n  private needSingleMessages: Map<PeerId, Map<number, CancellablePromise<Message>>> = new Map();\r\n  private fetchSingleMessagesPromise: Promise<void> = null;\r\n\r\n  private maxSeenId = 0;\r\n\r\n  public migratedFromTo: {[peerId: PeerId]: PeerId} = {};\r\n  public migratedToFrom: {[peerId: PeerId]: PeerId} = {};\r\n\r\n  private newMessagesHandleTimeout = 0;\r\n  private newMessagesToHandle: {[peerId: PeerId]: Set<number>} = {};\r\n  private newDialogsHandlePromise: Promise<any>;\r\n  private newDialogsToHandle: {[peerId: PeerId]: Dialog} = {};\r\n  public newUpdatesAfterReloadToHandle: {[peerId: PeerId]: Set<Update>} = {};\r\n\r\n  private notificationsHandlePromise = 0;\r\n  private notificationsToHandle: {[peerId: PeerId]: {\r\n    fwdCount: number,\r\n    fromId: PeerId,\r\n    topMessage?: MyMessage\r\n  }} = {};\r\n\r\n  private reloadConversationsPromise: Promise<void>;\r\n  private reloadConversationsPeers: Map<PeerId, {inputDialogPeer: InputDialogPeer, promise: CancellablePromise<Dialog>}> = new Map();\r\n\r\n  public log = logger('MESSAGES', LogTypes.Error | LogTypes.Debug | LogTypes.Log | LogTypes.Warn);\r\n\r\n  public dialogsStorage: DialogsStorage;\r\n  public filtersStorage: FiltersStorage;\r\n\r\n  private groupedTempId = 0;\r\n\r\n  private typings: {[peerId: PeerId]: {action: SendMessageAction, timeout?: number}} = {};\r\n\r\n  private middleware: ReturnType<typeof getMiddleware>;\r\n\r\n  private unreadMentions: {[peerId: PeerId]: SlicedArray<number>} = {};\r\n  private goToNextMentionPromises: {[peerId: PeerId]: Promise<any>} = {};\r\n  \r\n  private batchUpdates: {\r\n    [k in keyof BatchUpdates]?: {\r\n      callback: BatchUpdates[k],\r\n      batch: ArgumentTypes<BatchUpdates[k]>[0]\r\n    }\r\n  } = {};\r\n  private batchUpdatesDebounced: () => Promise<void>;\r\n\r\n  constructor() {\r\n    this.clear();\r\n\r\n    rootScope.addMultipleEventsListeners({\r\n      updateMessageID: this.onUpdateMessageId,\r\n\r\n      updateNewDiscussionMessage: this.onUpdateNewMessage,\r\n      updateNewMessage: this.onUpdateNewMessage,\r\n      updateNewChannelMessage: this.onUpdateNewMessage,\r\n\r\n      updateDialogUnreadMark: this.onUpdateDialogUnreadMark,\r\n\r\n      updateEditMessage: this.onUpdateEditMessage,\r\n      updateEditChannelMessage: this.onUpdateEditMessage,\r\n\r\n      updateMessageReactions: this.onUpdateMessageReactions,\r\n\r\n      updateReadChannelDiscussionInbox: this.onUpdateReadHistory,\r\n      updateReadChannelDiscussionOutbox: this.onUpdateReadHistory,\r\n      updateReadHistoryInbox: this.onUpdateReadHistory,\r\n      updateReadHistoryOutbox: this.onUpdateReadHistory,\r\n      updateReadChannelInbox: this.onUpdateReadHistory,\r\n      updateReadChannelOutbox: this.onUpdateReadHistory,\r\n\r\n      updateChannelReadMessagesContents: this.onUpdateReadMessagesContents,\r\n      updateReadMessagesContents: this.onUpdateReadMessagesContents,\r\n\r\n      updateChannelAvailableMessages: this.onUpdateChannelAvailableMessages,\r\n\r\n      updateDeleteMessages: this.onUpdateDeleteMessages,\r\n      updateDeleteChannelMessages: this.onUpdateDeleteMessages,\r\n\r\n      updateChannel: this.onUpdateChannel,\r\n\r\n      updateChannelReload: this.onUpdateChannelReload,\r\n\r\n      updateChannelMessageViews: this.onUpdateChannelMessageViews,\r\n\r\n      updateServiceNotification: this.onUpdateServiceNotification,\r\n\r\n      updatePinnedMessages: this.onUpdatePinnedMessages,\r\n      updatePinnedChannelMessages: this.onUpdatePinnedMessages,\r\n\r\n      updateNotifySettings: this.onUpdateNotifySettings,\r\n\r\n      updateNewScheduledMessage: this.onUpdateNewScheduledMessage,\r\n\r\n      updateDeleteScheduledMessages: this.onUpdateDeleteScheduledMessages\r\n    });\r\n\r\n    // ! Invalidate notify settings, can optimize though\r\n    rootScope.addEventListener('notify_peer_type_settings', ({key, settings}) => {\r\n      const dialogs = this.dialogsStorage.getFolderDialogs(0).concat(this.dialogsStorage.getFolderDialogs(1));\r\n      let filterFunc: (dialog: Dialog) => boolean;\r\n      if(key === 'notifyUsers') filterFunc = (dialog) => dialog.peerId.isUser();\r\n      else if(key === 'notifyBroadcasts') filterFunc = (dialog) => dialog.peerId.isBroadcast();\r\n      else filterFunc = (dialog) => appPeersManager.isAnyGroup(dialog.peerId);\r\n\r\n      dialogs\r\n      .filter(filterFunc)\r\n      .forEach(dialog => {\r\n        rootScope.dispatchEvent('dialog_notify_settings', dialog);\r\n      });\r\n    });\r\n\r\n    rootScope.addEventListener('webpage_updated', ({id, msgs}) => {\r\n      msgs.forEach(({peerId, mid, isScheduled}) => {\r\n        const storage = isScheduled ? this.getScheduledMessagesStorage(peerId) : this.getMessagesStorage(peerId);\r\n        const message = this.getMessageFromStorage(storage, mid) as Message.message;\r\n        if(!message) return;\r\n        message.media = {\r\n          _: 'messageMediaWebPage', \r\n          webpage: appWebPagesManager.getWebPage(id)\r\n        };\r\n\r\n        rootScope.dispatchEvent('message_edit', {\r\n          storage,\r\n          peerId,\r\n          mid\r\n        });\r\n      });\r\n    });\r\n\r\n    rootScope.addEventListener('draft_updated', ({peerId, threadId, draft}) => {\r\n      if(threadId) return;\r\n\r\n      const dialog = this.getDialogOnly(peerId);\r\n      if(dialog) {\r\n        if(!threadId) {\r\n          dialog.draft = draft;\r\n\r\n          let drop = false;\r\n          if(!draft && !appMessagesIdsManager.getServerMessageId(dialog.top_message)) {\r\n            this.dialogsStorage.dropDialog(peerId);\r\n            drop = true;\r\n          } else {\r\n            this.dialogsStorage.generateIndexForDialog(dialog);\r\n            this.dialogsStorage.pushDialog(dialog);\r\n          }\r\n\r\n          rootScope.dispatchEvent('dialog_draft', {\r\n            peerId,\r\n            dialog,\r\n            drop,\r\n            draft,\r\n            index: dialog.index\r\n          });\r\n        }\r\n      } else {\r\n        this.reloadConversation(peerId);\r\n      }\r\n    });\r\n\r\n    rootScope.addEventListener('poll_update', ({poll}) => {\r\n      const set = appPollsManager.pollToMessages[poll.id];\r\n      if(set) {\r\n        for(const key of set) {\r\n          const [peerId, mid] = key.split('_');\r\n\r\n          const message = this.getMessageByPeer(peerId.toPeerId(), +mid);\r\n          this.setDialogToStateIfMessageIsTop(message);\r\n        }\r\n      }\r\n    });\r\n    \r\n    appStateManager.getState().then(state => {\r\n      if(state.maxSeenMsgId) {\r\n        this.maxSeenId = state.maxSeenMsgId;\r\n      }\r\n    });\r\n\r\n    this.batchUpdatesDebounced = debounce(() => {\r\n      for(const event in this.batchUpdates) {\r\n        const details = this.batchUpdates[event as keyof BatchUpdates];\r\n        delete this.batchUpdates[event as keyof BatchUpdates];\r\n\r\n        // @ts-ignore\r\n        const result = details.callback(details.batch);\r\n        if(result && (!(result instanceof Array) || result.length)) {\r\n          // @ts-ignore\r\n          rootScope.dispatchEvent(event as keyof BatchUpdates, result);\r\n        }\r\n      }\r\n    }, 33, false, true);\r\n  }\r\n\r\n  public clear() {\r\n    if(this.middleware) {\r\n      this.middleware.clean();\r\n    } else {\r\n      this.middleware = getMiddleware();\r\n    }\r\n\r\n    this.messagesStorageByPeerId = {};\r\n    this.groupedMessagesStorage = {};\r\n    this.scheduledMessagesStorage = {};\r\n    this.historiesStorage = {};\r\n    this.threadsStorage = {};\r\n    this.searchesStorage = {};\r\n    this.pinnedMessages = {};\r\n    this.threadsServiceMessagesIdsStorage = {};\r\n    this.threadsToReplies = {};\r\n\r\n    this.dialogsStorage && this.dialogsStorage.clear();\r\n    this.filtersStorage && this.filtersStorage.clear();\r\n  }\r\n\r\n  public construct() {\r\n    this.dialogsStorage = new DialogsStorage(this, appChatsManager, appPeersManager, appUsersManager, appDraftsManager, appNotificationsManager, appStateManager, apiUpdatesManager, serverTimeManager, appMessagesIdsManager);\r\n    this.filtersStorage = new FiltersStorage(this, appPeersManager, appUsersManager, appNotificationsManager, appStateManager, apiUpdatesManager, /* apiManager, */ rootScope);\r\n  }\r\n\r\n  public getInputEntities(entities: MessageEntity[]) {\r\n    const sendEntites = copy(entities);\r\n    sendEntites.forEach((entity) => {\r\n      if(entity._ === 'messageEntityMentionName') {\r\n        (entity as any as MessageEntity.inputMessageEntityMentionName)._ = 'inputMessageEntityMentionName';\r\n        (entity as any as MessageEntity.inputMessageEntityMentionName).user_id = appUsersManager.getUserInput(entity.user_id);\r\n      }\r\n    });\r\n    return sendEntites;\r\n  }\r\n\r\n  public invokeAfterMessageIsSent(tempId: number, callbackName: string, callback: (message: MyMessage) => Promise<any>) {\r\n    const finalize = this.tempFinalizeCallbacks[tempId] ?? (this.tempFinalizeCallbacks[tempId] = {});\r\n    const obj = finalize[callbackName] ?? (finalize[callbackName] = {deferred: deferredPromise<void>()});\r\n\r\n    obj.callback = callback;\r\n\r\n    return obj.deferred;\r\n  }\r\n\r\n  public editMessage(message: any, text: string, options: Partial<{\r\n    noWebPage: true,\r\n    newMedia: any,\r\n    scheduleDate: number,\r\n    entities: MessageEntity[]\r\n  }> = {}): Promise<void> {\r\n    /* if(!this.canEditMessage(messageId)) {\r\n      return Promise.reject({type: 'MESSAGE_EDIT_FORBIDDEN'});\r\n    } */\r\n\r\n    const {mid, peerId} = message;\r\n\r\n    if(message.pFlags.is_outgoing) {\r\n      return this.invokeAfterMessageIsSent(mid, 'edit', (message) => {\r\n        //this.log('invoke editMessage callback', message);\r\n        return this.editMessage(message, text, options);\r\n      });\r\n    }\r\n\r\n    let entities = options.entities || [];\r\n    if(text) {\r\n      text = RichTextProcessor.parseMarkdown(text, entities);\r\n    }\r\n\r\n    const schedule_date = options.scheduleDate || (message.pFlags.is_scheduled ? message.date : undefined);\r\n    return apiManager.invokeApi('messages.editMessage', {\r\n      peer: appPeersManager.getInputPeerById(peerId),\r\n      id: message.id,\r\n      message: text,\r\n      media: options.newMedia,\r\n      entities: entities.length ? this.getInputEntities(entities) : undefined,\r\n      no_webpage: options.noWebPage,\r\n      schedule_date\r\n    }).then((updates) => {\r\n      apiUpdatesManager.processUpdateMessage(updates);\r\n    }, (error) => {\r\n      this.log.error('editMessage error:', error);\r\n      \r\n      if(error && error.type === 'MESSAGE_NOT_MODIFIED') {\r\n        error.handled = true;\r\n        return;\r\n      }\r\n      if(error && error.type === 'MESSAGE_EMPTY') {\r\n        error.handled = true;\r\n      }\r\n      return Promise.reject(error);\r\n    });\r\n  }\r\n\r\n  public sendText(peerId: PeerId, text: string, options: Partial<{\r\n    entities: MessageEntity[],\r\n    replyToMsgId: number,\r\n    threadId: number,\r\n    viaBotId: BotId,\r\n    queryId: string,\r\n    resultId: string,\r\n    noWebPage: true,\r\n    replyMarkup: ReplyMarkup,\r\n    clearDraft: true,\r\n    webPage: WebPage,\r\n    scheduleDate: number,\r\n    silent: true,\r\n    sendAsPeerId: PeerId,\r\n  }> = {}) {\r\n    if(!text.trim()) {\r\n      return Promise.resolve();\r\n    }\r\n\r\n    //this.checkSendOptions(options);\r\n\r\n    if(options.threadId && !options.replyToMsgId) {\r\n      options.replyToMsgId = options.threadId;\r\n    }\r\n\r\n    const MAX_LENGTH = rootScope.config.message_length_max;\r\n    if(text.length > MAX_LENGTH) {\r\n      const splitted = splitStringByLength(text, MAX_LENGTH);\r\n      text = splitted[0];\r\n\r\n      if(splitted.length > 1) {\r\n        delete options.webPage;\r\n      }\r\n\r\n      for(let i = 1; i < splitted.length; ++i) {\r\n        setTimeout(() => {\r\n          this.sendText(peerId, splitted[i], options);\r\n        }, i);\r\n      }\r\n    }\r\n\r\n    peerId = appPeersManager.getPeerMigratedTo(peerId) || peerId;\r\n\r\n    let entities = options.entities || [];\r\n    if(!options.viaBotId) {\r\n      text = RichTextProcessor.parseMarkdown(text, entities);\r\n      //entities = RichTextProcessor.mergeEntities(entities, RichTextProcessor.parseEntities(text));\r\n    }\r\n\r\n    let sendEntites = this.getInputEntities(entities);\r\n    if(!sendEntites.length) {\r\n      sendEntites = undefined;\r\n    }\r\n\r\n    const message = this.generateOutgoingMessage(peerId, options);\r\n    message.entities = entities;\r\n    message.message = text;\r\n\r\n    const replyToMsgId = options.replyToMsgId ? appMessagesIdsManager.getServerMessageId(options.replyToMsgId) : undefined;\r\n    const isChannel = appPeersManager.isChannel(peerId);\r\n\r\n    if(options.webPage) {\r\n      message.media = {\r\n        _: 'messageMediaWebPage',\r\n        webpage: options.webPage\r\n      };\r\n    }\r\n\r\n    const toggleError = (on: boolean) => {\r\n      if(on) {\r\n        message.error = true;\r\n      } else {\r\n        delete message.error;\r\n      }\r\n      rootScope.dispatchEvent('messages_pending');\r\n    };\r\n\r\n    message.send = () => {\r\n      toggleError(false);\r\n      const sentRequestOptions: PendingAfterMsg = {};\r\n      if(this.pendingAfterMsgs[peerId]) {\r\n        sentRequestOptions.afterMessageId = this.pendingAfterMsgs[peerId].messageId;\r\n      }\r\n\r\n      const sendAs = options.sendAsPeerId ? appPeersManager.getInputPeerById(options.sendAsPeerId) : undefined\r\n      let apiPromise: any;\r\n      if(options.viaBotId) {\r\n        apiPromise = apiManager.invokeApiAfter('messages.sendInlineBotResult', {\r\n          peer: appPeersManager.getInputPeerById(peerId),\r\n          random_id: message.random_id,\r\n          reply_to_msg_id: replyToMsgId || undefined,\r\n          query_id: options.queryId,\r\n          id: options.resultId,\r\n          clear_draft: options.clearDraft,\r\n          send_as: sendAs\r\n        }, sentRequestOptions);\r\n      } else {\r\n        apiPromise = apiManager.invokeApiAfter('messages.sendMessage', {\r\n          no_webpage: options.noWebPage,\r\n          peer: appPeersManager.getInputPeerById(peerId),\r\n          message: text,\r\n          random_id: message.random_id,\r\n          reply_to_msg_id: replyToMsgId || undefined,\r\n          entities: sendEntites,\r\n          clear_draft: options.clearDraft,\r\n          schedule_date: options.scheduleDate || undefined,\r\n          silent: options.silent,\r\n          send_as: sendAs\r\n        }, sentRequestOptions);\r\n      }\r\n\r\n      /* function is<T>(value: any, condition: boolean): value is T {\r\n        return condition;\r\n      } */\r\n\r\n      //this.log('sendText', message.mid);\r\n      this.pendingAfterMsgs[peerId] = sentRequestOptions;\r\n\r\n      return apiPromise.then((updates: Updates) => {\r\n        //this.log('sendText sent', message.mid);\r\n        //if(is<Updates.updateShortSentMessage>(updates, updates._ === 'updateShortSentMessage')) {\r\n        if(updates._ === 'updateShortSentMessage') {\r\n          //assumeType<Updates.updateShortSentMessage>(updates);\r\n\r\n          // * fix copying object with promise\r\n          const promise = message.promise;\r\n          delete message.promise;\r\n          const newMessage = copy(message);\r\n          message.promise = promise;\r\n\r\n          newMessage.date = updates.date;\r\n          newMessage.id = updates.id;\r\n          newMessage.media = updates.media;\r\n          newMessage.entities = updates.entities;\r\n          this.wrapMessageEntities(newMessage);\r\n          if(updates.pFlags.out) {\r\n            newMessage.pFlags.out = true;\r\n          }\r\n\r\n          // * override with new updates\r\n          updates = {\r\n            _: 'updates',\r\n            users: [],\r\n            chats: [],\r\n            seq: 0,\r\n            date: undefined,\r\n            updates: [{\r\n              _: 'updateMessageID',\r\n              random_id: message.random_id,\r\n              id: newMessage.id\r\n            }, {\r\n              _: options.scheduleDate ? 'updateNewScheduledMessage' : (isChannel ? 'updateNewChannelMessage' : 'updateNewMessage'),\r\n              message: newMessage,\r\n              pts: updates.pts,\r\n              pts_count: updates.pts_count\r\n            }]\r\n          };\r\n        } else if((updates as Updates.updates).updates) {\r\n          (updates as Updates.updates).updates.forEach((update) => {\r\n            if(update._ === 'updateDraftMessage') {\r\n              update.local = true;\r\n            }\r\n          });\r\n        }\r\n        // Testing bad situations\r\n        // var upd = angular.copy(updates)\r\n        // updates.updates.splice(0, 1)\r\n\r\n        apiUpdatesManager.processUpdateMessage(updates);\r\n\r\n        // $timeout(function () {\r\n        // ApiUpdatesManager.processUpdateMessage(upd)\r\n        // }, 5000)\r\n        message.promise.resolve();\r\n      }, (error: any) => {\r\n        toggleError(true);\r\n        message.promise.reject(error);\r\n      }).finally(() => {\r\n        if(this.pendingAfterMsgs[peerId] === sentRequestOptions) {\r\n          delete this.pendingAfterMsgs[peerId];\r\n        }\r\n      });\r\n    };\r\n\r\n    this.beforeMessageSending(message, {\r\n      isScheduled: !!options.scheduleDate || undefined, \r\n      threadId: options.threadId,\r\n      clearDraft: options.clearDraft\r\n    });\r\n\r\n    return message.promise;\r\n  }\r\n\r\n  public sendFile(peerId: PeerId, file: File | Blob | MyDocument, options: Partial<{\r\n    isRoundMessage: true,\r\n    isVoiceMessage: true,\r\n    isGroupedItem: true,\r\n    isMedia: true,\r\n\r\n    replyToMsgId: number,\r\n    sendAsPeerId: PeerId,\r\n    threadId: number,\r\n    groupId: string,\r\n    caption: string,\r\n    entities: MessageEntity[],\r\n    width: number,\r\n    height: number,\r\n    objectURL: string,\r\n    thumb: {\r\n      blob: Blob,\r\n      url: string,\r\n      size: MediaSize\r\n    },\r\n    duration: number,\r\n    background: true,\r\n    silent: true,\r\n    clearDraft: true,\r\n    scheduleDate: number,\r\n    noSound: boolean,\r\n\r\n    waveform: Uint8Array,\r\n  }> = {}) {\r\n    peerId = appPeersManager.getPeerMigratedTo(peerId) || peerId;\r\n\r\n    //this.checkSendOptions(options);\r\n\r\n    const message = this.generateOutgoingMessage(peerId, options);\r\n    const replyToMsgId = options.replyToMsgId ? appMessagesIdsManager.getServerMessageId(options.replyToMsgId) : undefined;\r\n\r\n    let attachType: 'document' | 'audio' | 'video' | 'voice' | 'photo', apiFileName: string;\r\n\r\n    const fileType = 'mime_type' in file ? file.mime_type : file.type;\r\n    const fileName = file instanceof File ? file.name : '';\r\n    const isDocument = !(file instanceof File) && !(file instanceof Blob);\r\n    let caption = options.caption || '';\r\n\r\n    this.log('sendFile', file, fileType);\r\n\r\n    const entities = options.entities || [];\r\n    if(caption) {\r\n      caption = RichTextProcessor.parseMarkdown(caption, entities);\r\n    }\r\n\r\n    const attributes: DocumentAttribute[] = [];\r\n\r\n    const isPhoto = IMAGE_MIME_TYPES_SUPPORTED.has(fileType);\r\n\r\n    let photo: MyPhoto, document: MyDocument;\r\n\r\n    let actionName: Extract<SendMessageAction['_'], 'sendMessageUploadAudioAction' | 'sendMessageUploadDocumentAction' | 'sendMessageUploadPhotoAction' | 'sendMessageUploadVideoAction'>;\r\n    if(isDocument) { // maybe it's a sticker or gif\r\n      attachType = 'document';\r\n      apiFileName = '';\r\n    } else if(fileType.indexOf('audio/') === 0 || ['video/ogg'].indexOf(fileType) >= 0) {\r\n      attachType = 'audio';\r\n      apiFileName = 'audio.' + (fileType.split('/')[1] === 'ogg' ? 'ogg' : 'mp3');\r\n      actionName = 'sendMessageUploadAudioAction';\r\n\r\n      if(options.isVoiceMessage) {\r\n        attachType = 'voice';\r\n        message.pFlags.media_unread = true;\r\n      }\r\n\r\n      let attribute: DocumentAttribute.documentAttributeAudio = {\r\n        _: 'documentAttributeAudio',\r\n        pFlags: {\r\n          voice: options.isVoiceMessage\r\n        },\r\n        waveform: options.waveform,\r\n        duration: options.duration || 0\r\n      };\r\n\r\n      attributes.push(attribute);\r\n    } else if(!options.isMedia) {\r\n      attachType = 'document';\r\n      apiFileName = 'document.' + fileType.split('/')[1];\r\n      actionName = 'sendMessageUploadDocumentAction';\r\n    } else if(isPhoto) {\r\n      attachType = 'photo';\r\n      apiFileName = 'photo.' + fileType.split('/')[1];\r\n      actionName = 'sendMessageUploadPhotoAction';\r\n\r\n      const photoSize = {\r\n        _: 'photoSize',\r\n        w: options.width,\r\n        h: options.height,\r\n        type: 'full',\r\n        location: null,\r\n        size: file.size\r\n      } as PhotoSize.photoSize;\r\n\r\n      photo = {\r\n        _: 'photo',\r\n        id: '' + message.id,\r\n        sizes: [photoSize],\r\n        w: options.width,\r\n        h: options.height\r\n      } as any;\r\n\r\n      const cacheContext = appDownloadManager.getCacheContext(photo, photoSize.type);\r\n      cacheContext.downloaded = file.size;\r\n      cacheContext.url = options.objectURL || '';\r\n      \r\n      photo = appPhotosManager.savePhoto(photo);\r\n    } else if(VIDEO_MIME_TYPES_SUPPORTED.has(fileType)) {\r\n      attachType = 'video';\r\n      apiFileName = 'video.mp4';\r\n      actionName = 'sendMessageUploadVideoAction';\r\n\r\n      const videoAttribute: DocumentAttribute.documentAttributeVideo = {\r\n        _: 'documentAttributeVideo',\r\n        pFlags: {\r\n          round_message: options.isRoundMessage,\r\n          supports_streaming: true\r\n        }, \r\n        duration: options.duration,\r\n        w: options.width,\r\n        h: options.height\r\n      };\r\n\r\n      attributes.push(videoAttribute);\r\n\r\n      // * must follow after video attribute\r\n      if(options.noSound && \r\n        file.size > (10 * 1024) && \r\n        file.size < (10 * 1024 * 1024)) {\r\n        attributes.push({\r\n          _: 'documentAttributeAnimated'\r\n        });\r\n      }\r\n    } else {\r\n      attachType = 'document';\r\n      apiFileName = 'document.' + fileType.split('/')[1];\r\n      actionName = 'sendMessageUploadDocumentAction';\r\n    }\r\n\r\n    attributes.push({_: 'documentAttributeFilename', file_name: fileName || apiFileName});\r\n\r\n    if((['document', 'video', 'audio', 'voice'] as (typeof attachType)[]).indexOf(attachType) !== -1 && !isDocument) {\r\n      const thumbs: PhotoSize[] = [];\r\n      document = {\r\n        _: 'document',\r\n        id: '' + message.id,\r\n        duration: options.duration,\r\n        attributes,\r\n        w: options.width,\r\n        h: options.height,\r\n        thumbs,\r\n        mime_type: fileType,\r\n        size: file.size\r\n      } as any;\r\n\r\n      if(options.objectURL) {\r\n        const cacheContext = appDownloadManager.getCacheContext(document);\r\n        cacheContext.downloaded = file.size;\r\n        cacheContext.url = options.objectURL;\r\n      }\r\n\r\n      let thumb: PhotoSize.photoSize;\r\n      if(isPhoto) {\r\n        attributes.push({\r\n          _: 'documentAttributeImageSize',\r\n          w: options.width,\r\n          h: options.height\r\n        });\r\n\r\n        thumb = {\r\n          _: 'photoSize',\r\n          w: options.width,\r\n          h: options.height,\r\n          type: 'full',\r\n          size: file.size\r\n        };\r\n      } else if(attachType === 'video') {\r\n        if(options.thumb) {\r\n          thumb = {\r\n            _: 'photoSize',\r\n            w: options.thumb.size.width,\r\n            h: options.thumb.size.height,\r\n            type: 'local-thumb',\r\n            size: options.thumb.blob.size\r\n          };\r\n\r\n          const thumbCacheContext = appDownloadManager.getCacheContext(document, thumb.type);\r\n          thumbCacheContext.downloaded = thumb.size;\r\n          thumbCacheContext.url = options.thumb.url;\r\n        }\r\n      }\r\n\r\n      if(thumb) {\r\n        thumbs.push(thumb);\r\n      }\r\n\r\n      /* if(thumbs.length) {\r\n        const thumb = thumbs[0] as PhotoSize.photoSize;\r\n        const docThumb = appPhotosManager.getDocumentCachedThumb(document.id);\r\n        docThumb.downloaded = thumb.size;\r\n        docThumb.url = thumb.url;\r\n      } */\r\n      \r\n      document = appDocsManager.saveDoc(document);\r\n    }\r\n\r\n    this.log('sendFile', attachType, apiFileName, file.type, options);\r\n\r\n    const preloader = isDocument ? undefined : new ProgressivePreloader({\r\n      attachMethod: 'prepend',\r\n      tryAgainOnFail: false,\r\n      isUpload: true\r\n    });\r\n\r\n    const sentDeferred = deferredPromise<InputMedia>();\r\n\r\n    if(preloader) {\r\n      preloader.attachPromise(sentDeferred);\r\n      sentDeferred.cancel = () => {\r\n        const error = new Error('Download canceled');\r\n        error.name = 'AbortError';\r\n        sentDeferred.reject(error);\r\n      };\r\n\r\n      sentDeferred.catch(err => {\r\n        if(err.name === 'AbortError' && !uploaded) {\r\n          this.log('cancelling upload', media);\r\n\r\n          this.cancelPendingMessage(message.random_id);\r\n          this.setTyping(peerId, {_: 'sendMessageCancelAction'});\r\n\r\n          if(uploadPromise?.cancel) {\r\n            uploadPromise.cancel();\r\n          }\r\n        }\r\n      });\r\n    }\r\n\r\n    const media = isDocument ? undefined : {\r\n      _: photo ? 'messageMediaPhoto' : 'messageMediaDocument',\r\n      pFlags: {},\r\n      preloader,\r\n      photo,\r\n      document,\r\n      promise: sentDeferred\r\n    };\r\n\r\n    message.entities = entities;\r\n    message.message = caption;\r\n    message.media = isDocument ? {\r\n      _: 'messageMediaDocument',\r\n      pFlags: {},\r\n      document: file \r\n    } as MessageMedia.messageMediaDocument : media as any;\r\n\r\n    const toggleError = (on: boolean) => {\r\n      if(on) {\r\n        message.error = true;\r\n      } else {\r\n        delete message.error;\r\n      }\r\n\r\n      rootScope.dispatchEvent('messages_pending');\r\n    };\r\n\r\n    let uploaded = false,\r\n      uploadPromise: ReturnType<ApiFileManager['uploadFile']> = null;\r\n\r\n    message.send = () => {\r\n      if(isDocument) {\r\n        const {id, access_hash, file_reference} = file as MyDocument;\r\n\r\n        const inputMedia: InputMedia = {\r\n          _: 'inputMediaDocument',\r\n          id: {\r\n            _: 'inputDocument',\r\n            id,\r\n            access_hash,\r\n            file_reference\r\n          }\r\n        };\r\n        \r\n        sentDeferred.resolve(inputMedia);\r\n      } else if(file instanceof File || file instanceof Blob) {\r\n        const load = () => {\r\n          if(!uploaded || message.error) {\r\n            uploaded = false;\r\n            uploadPromise = appDownloadManager.upload(file);\r\n            sentDeferred.notifyAll({done: 0, total: file.size});\r\n          }\r\n\r\n          let thumbUploadPromise: typeof uploadPromise;\r\n          if(attachType === 'video' && options.objectURL) {\r\n            thumbUploadPromise = new Promise((resolve, reject) => {\r\n              const thumbPromise = options.thumb && options.thumb.blob ? Promise.resolve(options.thumb) : createPosterForVideo(options.objectURL);\r\n              thumbPromise.then(thumb => {\r\n                if(!thumb) {\r\n                  resolve(null);\r\n                } else {\r\n                  appDownloadManager.upload(thumb.blob).then(resolve, reject);\r\n                }\r\n              }, reject);\r\n            });\r\n          }\r\n  \r\n          uploadPromise && uploadPromise.then(async(inputFile) => {\r\n            /* if(DEBUG) {\r\n              this.log('appMessagesManager: sendFile uploaded:', inputFile);\r\n            } */\r\n\r\n            // @ts-ignore\r\n            delete message.media.preloader;\r\n\r\n            inputFile.name = apiFileName;\r\n            uploaded = true;\r\n            let inputMedia: InputMedia;\r\n            switch(attachType) {\r\n              case 'photo':\r\n                inputMedia = {\r\n                  _: 'inputMediaUploadedPhoto', \r\n                  file: inputFile,\r\n                };\r\n                break;\r\n\r\n              default:\r\n                inputMedia = {\r\n                  _: 'inputMediaUploadedDocument', \r\n                  file: inputFile, \r\n                  mime_type: fileType, \r\n                  pFlags: {\r\n                    force_file: actionName === 'sendMessageUploadDocumentAction' ? true : undefined,\r\n                    // nosound_video: options.noSound ? true : undefined\r\n                  },\r\n                  attributes\r\n                };\r\n            }\r\n\r\n            if(thumbUploadPromise) {\r\n              try {\r\n                const inputFile = await thumbUploadPromise;\r\n                (inputMedia as InputMedia.inputMediaUploadedDocument).thumb = inputFile;\r\n              } catch(err) {\r\n                this.log.error('sendFile thumb upload error:', err);\r\n              }\r\n            }\r\n            \r\n            sentDeferred.resolve(inputMedia);\r\n          }, (/* error */) => {\r\n            toggleError(true);\r\n          });\r\n  \r\n          uploadPromise.addNotifyListener((progress: {done: number, total: number}) => {\r\n            /* if(DEBUG) {\r\n              this.log('upload progress', progress);\r\n            } */\r\n\r\n            const percents = Math.max(1, Math.floor(100 * progress.done / progress.total));\r\n            if(actionName) {\r\n              this.setTyping(peerId, {_: actionName, progress: percents | 0});\r\n            }\r\n            sentDeferred.notifyAll(progress);\r\n          });\r\n\r\n          return sentDeferred;\r\n        };\r\n\r\n        if(options.isGroupedItem) {\r\n          load();\r\n        } else {\r\n          this.sendSmthLazyLoadQueue.push({\r\n            load\r\n          });\r\n        }\r\n      }\r\n\r\n      return sentDeferred;\r\n    };\r\n\r\n    this.beforeMessageSending(message, {\r\n      isGroupedItem: options.isGroupedItem, \r\n      isScheduled: !!options.scheduleDate || undefined, \r\n      threadId: options.threadId,\r\n      clearDraft: options.clearDraft\r\n    });\r\n\r\n    if(!options.isGroupedItem) {\r\n      sentDeferred.then(inputMedia => {\r\n        this.setTyping(peerId, {_: 'sendMessageCancelAction'});\r\n\r\n        return apiManager.invokeApi('messages.sendMedia', {\r\n          background: options.background,\r\n          peer: appPeersManager.getInputPeerById(peerId),\r\n          media: inputMedia,\r\n          message: caption,\r\n          random_id: message.random_id,\r\n          reply_to_msg_id: replyToMsgId,\r\n          schedule_date: options.scheduleDate,\r\n          silent: options.silent,\r\n          entities,\r\n          clear_draft: options.clearDraft,\r\n          send_as: options.sendAsPeerId ? appPeersManager.getInputPeerById(options.sendAsPeerId) : undefined\r\n        }).then((updates) => {\r\n          apiUpdatesManager.processUpdateMessage(updates);\r\n        }, (error) => {\r\n          if(attachType === 'photo' &&\r\n            error.code === 400 &&\r\n            (error.type === 'PHOTO_INVALID_DIMENSIONS' ||\r\n            error.type === 'PHOTO_SAVE_FILE_INVALID')) {\r\n            error.handled = true;\r\n            attachType = 'document';\r\n            message.send();\r\n            return;\r\n          }\r\n\r\n          toggleError(true);\r\n          throw error;\r\n        });\r\n      });\r\n\r\n      sentDeferred.then(message.promise.resolve, message.promise.reject);\r\n    }\r\n\r\n    return {message, promise: sentDeferred};\r\n  }\r\n\r\n  public async sendAlbum(peerId: PeerId, files: File[], options: Partial<{\r\n    isMedia: true,\r\n    entities: MessageEntity[],\r\n    replyToMsgId: number,\r\n    sendAsPeerId: PeerId,\r\n    threadId: number,\r\n    caption: string,\r\n    sendFileDetails: Partial<{\r\n      duration: number,\r\n      width: number,\r\n      height: number,\r\n      objectURL: string,\r\n      thumbBlob: Blob,\r\n      thumbURL: string\r\n    }>[],\r\n    silent: true,\r\n    clearDraft: true,\r\n    scheduleDate: number\r\n  }> = {}) {\r\n    //this.checkSendOptions(options);\r\n\r\n    if(options.threadId && !options.replyToMsgId) {\r\n      options.replyToMsgId = options.threadId;\r\n    }\r\n\r\n    if(files.length === 1) {\r\n      return this.sendFile(peerId, files[0], {...options, ...options.sendFileDetails[0]});\r\n    }\r\n\r\n    peerId = appPeersManager.getPeerMigratedTo(peerId) || peerId;\r\n    const replyToMsgId = options.replyToMsgId ? appMessagesIdsManager.getServerMessageId(options.replyToMsgId) : undefined;\r\n\r\n    let caption = options.caption || '';\r\n    let entities = options.entities || [];\r\n    if(caption) {\r\n      caption = RichTextProcessor.parseMarkdown(caption, entities);\r\n    }\r\n\r\n    this.log('sendAlbum', files, options);\r\n\r\n    const groupId = '' + ++this.groupedTempId;\r\n\r\n    const messages = files.map((file, idx) => {\r\n      const details = options.sendFileDetails[idx];\r\n      const o: Parameters<AppMessagesManager['sendFile']>[2] = {\r\n        isGroupedItem: true,\r\n        isMedia: options.isMedia,\r\n        scheduleDate: options.scheduleDate,\r\n        silent: options.silent,\r\n        replyToMsgId,\r\n        threadId: options.threadId,\r\n        sendAsPeerId: options.sendAsPeerId,\r\n        groupId,\r\n        ...details\r\n      };\r\n\r\n      if(idx === 0) {\r\n        o.caption = caption;\r\n        o.entities = entities;\r\n        //o.replyToMsgId = replyToMsgId;\r\n      }\r\n\r\n      return this.sendFile(peerId, file, o).message;\r\n    });\r\n\r\n    if(options.clearDraft) {\r\n      setTimeout(() => {\r\n        appDraftsManager.clearDraft(peerId, options.threadId);\r\n      }, 0);\r\n    }\r\n    \r\n    // * test pending\r\n    //return;\r\n\r\n    const toggleError = (message: any, on: boolean) => {\r\n      if(on) {\r\n        message.error = true;\r\n      } else {\r\n        delete message.error;\r\n      }\r\n\r\n      rootScope.dispatchEvent('messages_pending');\r\n    };\r\n\r\n    const inputPeer = appPeersManager.getInputPeerById(peerId);\r\n    const invoke = (multiMedia: InputSingleMedia[]) => {\r\n      this.setTyping(peerId, {_: 'sendMessageCancelAction'});\r\n\r\n      const deferred = deferredPromise<void>();\r\n      this.sendSmthLazyLoadQueue.push({\r\n        load: () => {\r\n          return apiManager.invokeApi('messages.sendMultiMedia', {\r\n            peer: inputPeer,\r\n            multi_media: multiMedia,\r\n            reply_to_msg_id: replyToMsgId,\r\n            schedule_date: options.scheduleDate,\r\n            silent: options.silent,\r\n            clear_draft: options.clearDraft,\r\n            send_as: options.sendAsPeerId ? appPeersManager.getInputPeerById(options.sendAsPeerId) : undefined\r\n          }).then((updates) => {\r\n            apiUpdatesManager.processUpdateMessage(updates);\r\n            deferred.resolve();\r\n          }, (error) => {\r\n            messages.forEach(message => toggleError(message, true));\r\n            deferred.reject(error);\r\n          });\r\n        }\r\n      });\r\n\r\n      return deferred;\r\n    };\r\n\r\n    const promises: Promise<InputSingleMedia>[] = messages.map((message) => {\r\n      return (message.send() as Promise<InputMedia>).then((inputMedia) => {\r\n        return apiManager.invokeApi('messages.uploadMedia', {\r\n          peer: inputPeer,\r\n          media: inputMedia\r\n        });\r\n      })\r\n      .then(messageMedia => {\r\n        let inputMedia: InputMedia;\r\n        if(messageMedia._ === 'messageMediaPhoto') {\r\n          const photo = appPhotosManager.savePhoto(messageMedia.photo);\r\n          inputMedia = appPhotosManager.getMediaInput(photo);\r\n        } else if(messageMedia._ === 'messageMediaDocument') {\r\n          const doc = appDocsManager.saveDoc(messageMedia.document);\r\n          inputMedia = appDocsManager.getMediaInput(doc);\r\n        }\r\n\r\n        const inputSingleMedia: InputSingleMedia = {\r\n          _: 'inputSingleMedia',\r\n          media: inputMedia,\r\n          random_id: message.random_id,\r\n          message: caption,\r\n          entities\r\n        };\r\n\r\n        // * only 1 caption for all inputs\r\n        if(caption) {\r\n          caption = '';\r\n          entities = [];\r\n        }\r\n\r\n        return inputSingleMedia;\r\n      }).catch((err: any) => {\r\n        if(err.name === 'AbortError') {\r\n          return null;\r\n        }\r\n\r\n        this.log.error('sendAlbum upload item error:', err, message);\r\n        toggleError(message, true);\r\n        throw err;\r\n      });\r\n    });\r\n\r\n    return Promise.all(promises).then(inputs => {\r\n      return invoke(inputs.filter(Boolean));\r\n    });\r\n  }\r\n\r\n  public sendContact(peerId: PeerId, contactPeerId: PeerId) {\r\n    return this.sendOther(peerId, appUsersManager.getContactMediaInput(contactPeerId));\r\n  }\r\n\r\n  public sendOther(peerId: PeerId, inputMedia: InputMedia, options: Partial<{\r\n    replyToMsgId: number,\r\n    threadId: number,\r\n    viaBotId: BotId,\r\n    replyMarkup: ReplyMarkup,\r\n    clearDraft: true,\r\n    queryId: string\r\n    resultId: string,\r\n    scheduleDate: number,\r\n    silent: true,\r\n    geoPoint: GeoPoint,\r\n    sendAsPeerId: PeerId,\r\n  }> = {}) {\r\n    peerId = appPeersManager.getPeerMigratedTo(peerId) || peerId;\r\n\r\n    //this.checkSendOptions(options);\r\n    const message = this.generateOutgoingMessage(peerId, options);\r\n    const replyToMsgId = options.replyToMsgId ? appMessagesIdsManager.getServerMessageId(options.replyToMsgId) : undefined;\r\n\r\n    let media: MessageMedia;\r\n    switch(inputMedia._) {\r\n      case 'inputMediaPoll': {\r\n        const pollId = '' + message.id;\r\n        inputMedia.poll.id = pollId;\r\n        appPollsManager.savePoll(inputMedia.poll, {\r\n          _: 'pollResults',\r\n          flags: 4,\r\n          total_voters: 0,\r\n          pFlags: {},\r\n          recent_voters: []\r\n        });\r\n\r\n        const {poll, results} = appPollsManager.getPoll(pollId);\r\n        media = {\r\n          _: 'messageMediaPoll',\r\n          poll,\r\n          results\r\n        };\r\n\r\n        break;\r\n      }\r\n\r\n      case 'inputMediaPhoto': {\r\n        media = {\r\n          _: 'messageMediaPhoto',\r\n          photo: appPhotosManager.getPhoto((inputMedia.id as InputPhoto.inputPhoto).id)\r\n        };\r\n        break;\r\n      }\r\n\r\n      case 'inputMediaDocument': {\r\n        const doc = appDocsManager.getDoc((inputMedia.id as InputDocument.inputDocument).id);\r\n        /* if(doc.sticker && doc.stickerSetInput) {\r\n          appStickersManager.pushPopularSticker(doc.id);\r\n        } */\r\n        media = {\r\n          _: 'messageMediaDocument',\r\n          document: doc\r\n        };\r\n        break;\r\n      }\r\n\r\n      case 'inputMediaContact': {\r\n        media = {\r\n          _: 'messageMediaContact',\r\n          phone_number: inputMedia.phone_number,\r\n          first_name: inputMedia.first_name,\r\n          last_name: inputMedia.last_name,\r\n          user_id: inputMedia.user_id ?? '0',\r\n          vcard: inputMedia.vcard\r\n        };\r\n        break;\r\n      }\r\n\r\n      case 'inputMediaGeoPoint': {\r\n        media = {\r\n          _: 'messageMediaGeo',\r\n          geo: options.geoPoint\r\n        };\r\n        break;\r\n      }\r\n\r\n      case 'inputMediaVenue': {\r\n        media = {\r\n          _: 'messageMediaVenue',\r\n          geo: options.geoPoint,\r\n          title: inputMedia.title,\r\n          address: inputMedia.address,\r\n          provider: inputMedia.provider,\r\n          venue_id: inputMedia.venue_id,\r\n          venue_type: inputMedia.venue_type\r\n        };\r\n        break;\r\n      }\r\n      \r\n      // @ts-ignore\r\n      case 'messageMediaPending': {\r\n        media = inputMedia;\r\n        break;\r\n      }\r\n    }\r\n\r\n    message.media = media;\r\n\r\n    let toggleError = (on: boolean) => {\r\n      /* const historyMessage = this.messagesForHistory[messageId];\r\n      if (on) {\r\n        message.error = true\r\n        if (historyMessage) {\r\n          historyMessage.error = true\r\n        }\r\n      } else {\r\n        delete message.error\r\n        if (historyMessage) {\r\n          delete historyMessage.error\r\n        }\r\n      } */\r\n      rootScope.dispatchEvent('messages_pending');\r\n    };\r\n\r\n    message.send = () => {\r\n      const sentRequestOptions: PendingAfterMsg = {};\r\n      if(this.pendingAfterMsgs[peerId]) {\r\n        sentRequestOptions.afterMessageId = this.pendingAfterMsgs[peerId].messageId;\r\n      }\r\n\r\n      const sendAs = options.sendAsPeerId ? appPeersManager.getInputPeerById(options.sendAsPeerId) : undefined;\r\n      let apiPromise: Promise<any>;\r\n      if(options.viaBotId) {\r\n        apiPromise = apiManager.invokeApiAfter('messages.sendInlineBotResult', {\r\n          peer: appPeersManager.getInputPeerById(peerId),\r\n          random_id: message.random_id,\r\n          reply_to_msg_id: replyToMsgId || undefined,\r\n          query_id: options.queryId,\r\n          id: options.resultId,\r\n          clear_draft: options.clearDraft,\r\n          schedule_date: options.scheduleDate,\r\n          silent: options.silent,\r\n          send_as: sendAs\r\n        }, sentRequestOptions);\r\n      } else {\r\n        apiPromise = apiManager.invokeApiAfter('messages.sendMedia', {\r\n          peer: appPeersManager.getInputPeerById(peerId),\r\n          media: inputMedia,\r\n          random_id: message.random_id,\r\n          reply_to_msg_id: replyToMsgId || undefined,\r\n          message: '',\r\n          clear_draft: options.clearDraft,\r\n          schedule_date: options.scheduleDate,\r\n          silent: options.silent,\r\n          send_as: sendAs\r\n        }, sentRequestOptions);\r\n      }\r\n\r\n      this.pendingAfterMsgs[peerId] = sentRequestOptions;\r\n\r\n      return apiPromise.then((updates) => {\r\n        if(updates.updates) {\r\n          updates.updates.forEach((update: Update) => {\r\n            if(update._ === 'updateDraftMessage') {\r\n              update.local = true;\r\n            }\r\n          });\r\n        }\r\n\r\n        apiUpdatesManager.processUpdateMessage(updates);\r\n      }, (error) => {\r\n        toggleError(true);\r\n      }).finally(() => {\r\n        if(this.pendingAfterMsgs[peerId] === sentRequestOptions) {\r\n          delete this.pendingAfterMsgs[peerId];\r\n        }\r\n      });\r\n    };\r\n\r\n    this.beforeMessageSending(message, {\r\n      isScheduled: !!options.scheduleDate || undefined, \r\n      threadId: options.threadId,\r\n      clearDraft: options.clearDraft\r\n    });\r\n\r\n    return message.promise;\r\n  }\r\n\r\n  /* private checkSendOptions(options: Partial<{\r\n    scheduleDate: number\r\n  }>) {\r\n    if(options.scheduleDate) {\r\n      const minTimestamp = (Date.now() / 1000 | 0) + 10;\r\n      if(options.scheduleDate <= minTimestamp) {\r\n        delete options.scheduleDate;\r\n      }\r\n    }\r\n  } */\r\n\r\n  private beforeMessageSending(message: Message.message, options: Partial<{\r\n    isGroupedItem: true, \r\n    isScheduled: true, \r\n    threadId: number, \r\n    clearDraft: true\r\n  }> = {}) {\r\n    const messageId = message.id;\r\n    const peerId = this.getMessagePeer(message);\r\n    const storage = options.isScheduled ? this.getScheduledMessagesStorage(peerId) : this.getMessagesStorage(peerId);\r\n\r\n    if(options.isScheduled) {\r\n      //if(!options.isGroupedItem) {\r\n      this.saveMessages([message], {storage, isScheduled: true, isOutgoing: true});\r\n      setTimeout(() => {\r\n        rootScope.dispatchEvent('scheduled_new', {peerId, mid: messageId});\r\n      }, 0);\r\n    } else {\r\n      /* if(options.threadId && this.threadsStorage[peerId]) {\r\n        delete this.threadsStorage[peerId][options.threadId];\r\n      } */\r\n      const storages: HistoryStorage[] = [\r\n        this.getHistoryStorage(peerId),\r\n        options.threadId ? this.getHistoryStorage(peerId, options.threadId) : undefined\r\n      ];\r\n\r\n      for(const storage of storages) {\r\n        if(storage) {\r\n          storage.history.unshift(messageId);\r\n        }\r\n      }\r\n\r\n      //if(!options.isGroupedItem) {\r\n      this.saveMessages([message], {storage, isOutgoing: true});\r\n      this.setDialogTopMessage(message);\r\n      setTimeout(() => {\r\n        rootScope.dispatchEvent('history_append', {storage, peerId, mid: messageId});\r\n      }, 0);\r\n    }\r\n\r\n    this.pendingByRandomId[message.random_id] = {\r\n      peerId, \r\n      tempId: messageId, \r\n      threadId: options.threadId, \r\n      storage\r\n    };\r\n\r\n    if(!options.isGroupedItem && message.send) {\r\n      setTimeout(() => {\r\n        if(options.clearDraft) {\r\n          appDraftsManager.clearDraft(peerId, options.threadId);\r\n        }\r\n\r\n        message.send();\r\n      }, 0);\r\n    }\r\n  }\r\n\r\n  private generateOutgoingMessage(peerId: PeerId, options: Partial<{\r\n    scheduleDate: number,\r\n    replyToMsgId: number,\r\n    sendAsPeerId: PeerId, \r\n    threadId: number,\r\n    viaBotId: BotId,\r\n    groupId: string,\r\n    replyMarkup: ReplyMarkup,\r\n  }>) {\r\n    if(options.threadId && !options.replyToMsgId) {\r\n      options.replyToMsgId = options.threadId;\r\n    }\r\n\r\n    let postAuthor: string;\r\n    const isBroadcast = appPeersManager.isBroadcast(peerId);\r\n    if(isBroadcast) {\r\n      const chat = appPeersManager.getPeer(peerId) as Chat.channel;\r\n      if(chat.pFlags.signatures) {\r\n        const user = appUsersManager.getSelf();\r\n        const fullName = user.first_name + (user.last_name ? ' ' + user.last_name : '');\r\n        postAuthor = fullName;\r\n      }\r\n    }\r\n\r\n    const message: Message.message = {\r\n      _: 'message',\r\n      id: this.generateTempMessageId(peerId),\r\n      from_id: options.sendAsPeerId ? appPeersManager.getOutputPeer(options.sendAsPeerId) : this.generateFromId(peerId),\r\n      peer_id: appPeersManager.getOutputPeer(peerId),\r\n      post_author: postAuthor, \r\n      pFlags: this.generateFlags(peerId),\r\n      date: options.scheduleDate || (tsNow(true) + serverTimeManager.serverTimeOffset),\r\n      message: '',\r\n      grouped_id: options.groupId,\r\n      random_id: randomLong(),\r\n      reply_to: this.generateReplyHeader(options.replyToMsgId, options.threadId),\r\n      via_bot_id: options.viaBotId,\r\n      reply_markup: options.replyMarkup,\r\n      replies: this.generateReplies(peerId),\r\n      views: isBroadcast && 1,\r\n      pending: true,\r\n      promise: options.groupId === undefined ? deferredPromise() : undefined\r\n    };\r\n\r\n    return message;\r\n  }\r\n\r\n  private generateReplyHeader(replyToMsgId: number, replyToTopId?: number) {\r\n    const header = {\r\n      _: 'messageReplyHeader',\r\n      reply_to_msg_id: replyToMsgId || replyToTopId,\r\n    } as MessageReplyHeader;\r\n\r\n    if(replyToTopId && header.reply_to_msg_id !== replyToTopId) {\r\n      header.reply_to_top_id = replyToTopId;\r\n    }\r\n\r\n    return header;\r\n  }\r\n\r\n  private generateReplies(peerId: PeerId) {\r\n    let replies: MessageReplies.messageReplies;\r\n    if(appPeersManager.isBroadcast(peerId)) {\r\n      const channelFull = appProfileManager.getCachedFullChat(peerId.toChatId()) as ChatFull.channelFull;\r\n      if(channelFull?.linked_chat_id) {\r\n        replies = {\r\n          _: 'messageReplies',\r\n          flags: 1,\r\n          pFlags: {\r\n            comments: true\r\n          },\r\n          channel_id: channelFull.linked_chat_id,\r\n          replies: 0,\r\n          replies_pts: 0\r\n        };\r\n      }\r\n    }\r\n\r\n    return replies;\r\n  }\r\n\r\n  /**\r\n   * Generate correct from_id according to anonymous or broadcast\r\n   */\r\n  private generateFromId(peerId: PeerId) {\r\n    if(peerId.isAnyChat() && (peerId.isBroadcast() || this.isAnonymousSending(peerId))) {\r\n      return undefined;\r\n    } else {\r\n      return appPeersManager.getOutputPeer(appUsersManager.getSelf().id.toPeerId());\r\n    }\r\n  }\r\n\r\n  private generateFlags(peerId: PeerId) {\r\n    const pFlags: Message.message['pFlags'] = {};\r\n    const fromId = appUsersManager.getSelf().id;\r\n    if(peerId !== fromId) {\r\n      pFlags.out = true;\r\n\r\n      if(!appPeersManager.isChannel(peerId) && !appUsersManager.isBot(peerId)) {\r\n        pFlags.unread = true;\r\n      }\r\n    }\r\n\r\n    if(appPeersManager.isBroadcast(peerId)) {\r\n      pFlags.post = true;\r\n    }\r\n\r\n    return pFlags;\r\n  }\r\n\r\n  private generateForwardHeader(peerId: PeerId, originalMessage: Message.message) {\r\n    const myId = appUsersManager.getSelf().id.toPeerId();\r\n    const fromId = originalMessage.fromId;\r\n    if(fromId === myId && originalMessage.peerId === myId && !originalMessage.fwd_from) {\r\n      return;\r\n    }\r\n\r\n    const fwdHeader: MessageFwdHeader.messageFwdHeader = {\r\n      _: 'messageFwdHeader',\r\n      flags: 0,\r\n      date: originalMessage.date\r\n    };\r\n\r\n    let isUserHidden = false;\r\n    if(originalMessage.fwd_from) {\r\n      fwdHeader.from_id = originalMessage.fwd_from.from_id;\r\n      fwdHeader.from_name = originalMessage.fwd_from.from_name;\r\n      fwdHeader.post_author = originalMessage.fwd_from.post_author;\r\n    } else {\r\n      fwdHeader.post_author = originalMessage.post_author;\r\n      \r\n      if(fromId.isUser()) {\r\n        const userFull = appProfileManager.getCachedFullUser(fromId.toUserId());\r\n        if(userFull?.private_forward_name) {\r\n          fwdHeader.from_name = userFull.private_forward_name;\r\n          isUserHidden = true;\r\n        }\r\n      }\r\n\r\n      if(!isUserHidden) {\r\n        fwdHeader.from_id = appPeersManager.getOutputPeer(fromId);\r\n      }\r\n    }\r\n\r\n    if(appPeersManager.isBroadcast(originalMessage.peerId)) {\r\n      if(originalMessage.post_author) {\r\n        fwdHeader.post_author = originalMessage.post_author;\r\n      }\r\n\r\n      fwdHeader.channel_post = originalMessage.id;\r\n    }\r\n    \r\n    if(peerId === myId && !isUserHidden) {\r\n      fwdHeader.saved_from_msg_id = originalMessage.id;\r\n      fwdHeader.saved_from_peer = appPeersManager.getOutputPeer(originalMessage.peerId);\r\n    }\r\n\r\n    return fwdHeader;\r\n  }\r\n\r\n  public generateFakeAvatarMessage(peerId: PeerId, photo: Photo) {\r\n    const maxId = Number.MAX_SAFE_INTEGER;\r\n    const message: Message.messageService = {\r\n      _: 'messageService',\r\n      pFlags: {},\r\n      action: {\r\n        _: 'messageActionChannelEditPhoto',\r\n        photo\r\n      },\r\n      id: maxId,\r\n      peer_id: appPeersManager.getOutputPeer(peerId),\r\n      mid: maxId,\r\n      peerId,\r\n      date: (photo as Photo.photo).date,\r\n      fromId: peerId\r\n    };\r\n\r\n    this.getMessagesStorage(peerId).set(maxId, message);\r\n    return message;\r\n  }\r\n\r\n  public isAnonymousSending(peerId: PeerId): boolean {\r\n    return peerId.isAnyChat() && appPeersManager.getPeer(peerId).admin_rights?.pFlags?.anonymous;\r\n  }\r\n\r\n  public setDialogTopMessage(message: MyMessage, dialog: MTDialog.dialog = this.getDialogOnly(message.peerId)) {\r\n    if(dialog) {\r\n      dialog.top_message = message.mid;\r\n      \r\n      const historyStorage = this.getHistoryStorage(message.peerId);\r\n      historyStorage.maxId = message.mid;\r\n\r\n      this.dialogsStorage.generateIndexForDialog(dialog, false, message);\r\n\r\n      this.scheduleHandleNewDialogs(message.peerId, dialog);\r\n    }\r\n  }\r\n\r\n  public cancelPendingMessage(randomId: string) {\r\n    const pendingData = this.pendingByRandomId[randomId];\r\n\r\n    /* if(DEBUG) {\r\n      this.log('cancelPendingMessage', randomId, pendingData);\r\n    } */\r\n\r\n    if(pendingData) {\r\n      const {peerId, tempId, storage} = pendingData;\r\n      const historyStorage = this.getHistoryStorage(peerId);\r\n\r\n      apiUpdatesManager.processLocalUpdate({\r\n        _: 'updateDeleteMessages',\r\n        messages: [tempId],\r\n        pts: undefined,\r\n        pts_count: undefined\r\n      });\r\n\r\n      historyStorage.history.delete(tempId);\r\n\r\n      delete this.pendingByRandomId[randomId];\r\n      storage.delete(tempId);\r\n\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /* public async refreshConversations() {\r\n    const limit = 200, outDialogs: Dialog[] = [];\r\n    for(let folderId = 0; folderId < 2; ++folderId) {\r\n      let offsetDate = 0;\r\n      for(;;) {\r\n        const {dialogs, isEnd} = await this.getTopMessages(limit, folderId, offsetDate);\r\n  \r\n        if(dialogs.length) {\r\n          outDialogs.push(...dialogs as Dialog[]);\r\n          const dialog = dialogs[dialogs.length - 1];\r\n\r\n          // * get peerId and mid manually, because dialog can be migrated peer and it won't be saved\r\n          const peerId = appPeersManager.getPeerId(dialog.peer);\r\n          const mid = appMessagesIdsManager.generateMessageId(dialog.top_message);\r\n          offsetDate = this.getMessageByPeer(peerId, mid).date;\r\n\r\n          if(!offsetDate) {\r\n            console.error('refreshConversations: got no offsetDate', dialog);\r\n            break;\r\n          }\r\n        }\r\n        \r\n        if(isEnd) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    let obj: {[peerId: string]: Dialog} = {};\r\n    outDialogs.forEach(dialog => {\r\n      obj[dialog.peerId] = dialog;\r\n    });\r\n    rootScope.dispatchEvent('dialogs_multiupdate', obj);\r\n\r\n    return outDialogs;\r\n  } */\r\n\r\n  public async fillConversations(): Promise<void> {\r\n    const middleware = this.middleware.get();\r\n    while(!this.dialogsStorage.isDialogsLoaded(GLOBAL_FOLDER_ID)) {\r\n      const result = await this.getTopMessages(100, GLOBAL_FOLDER_ID);\r\n      if(!middleware() || result.isEnd) {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  /* public async getConversationsAll(query = '', folderId = 0) {\r\n    const limit = 200, outDialogs: Dialog[] = [];\r\n    for(; folderId < 2; ++folderId) {\r\n      let offsetIndex = 0;\r\n      for(;;) {\r\n        const {dialogs} = await appMessagesManager.getConversations(query, offsetIndex, limit, folderId).promise;\r\n  \r\n        if(dialogs.length) {\r\n          outDialogs.push(...dialogs);\r\n          offsetIndex = dialogs[dialogs.length - 1].index || 0;\r\n        } else {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    return outDialogs;\r\n  } */\r\n\r\n  public getConversations(query = '', offsetIndex?: number, limit?: number, folderId = 0, skipMigrated?: boolean) {\r\n    return this.dialogsStorage.getDialogs(query, offsetIndex, limit, folderId, skipMigrated);\r\n  }\r\n\r\n  public getReadMaxIdIfUnread(peerId: PeerId, threadId?: number) {\r\n    const historyStorage = this.getHistoryStorage(peerId, threadId);\r\n    if(threadId) {\r\n      const chatHistoryStorage = this.getHistoryStorage(peerId);\r\n      const readMaxId = Math.max(chatHistoryStorage.readMaxId ?? 0, historyStorage.readMaxId);\r\n      const message = this.getMessageByPeer(peerId, historyStorage.maxId); // usually message is missing, so pFlags.out won't be there anyway\r\n      return !message.pFlags.out && readMaxId < historyStorage.maxId ? readMaxId : 0;\r\n    } else {\r\n      const message = this.getMessageByPeer(peerId, historyStorage.maxId);\r\n      const readMaxId = peerId.isUser() ? Math.max(historyStorage.readMaxId, historyStorage.readOutboxMaxId) : historyStorage.readMaxId;\r\n      return !message.pFlags.out && readMaxId < historyStorage.maxId ? readMaxId : 0;\r\n    }\r\n  }\r\n\r\n  // public lolSet = new Set();\r\n  public getTopMessages(limit: number, folderId: number, offsetDate?: number) {\r\n    //const dialogs = this.dialogsStorage.getFolder(folderId);\r\n    let offsetId = 0;\r\n    let offsetPeerId: PeerId;\r\n    let offsetIndex = 0;\r\n\r\n    if(offsetDate === undefined) {\r\n      offsetDate = this.dialogsStorage.getOffsetDate(folderId);\r\n    }\r\n\r\n    if(offsetDate) {\r\n      offsetIndex = offsetDate * 0x10000;\r\n      offsetDate += serverTimeManager.serverTimeOffset;\r\n    }\r\n\r\n    const useLimit = 100;\r\n    const middleware = this.middleware.get();\r\n\r\n    // ! ВНИМАНИЕ: ОЧЕНЬ СЛОЖНАЯ ЛОГИКА:\r\n    // ! если делать запрос сначала по папке 0, потом по папке 1, по индексу 0 в массиве будет один и тот же диалог, с dialog.pFlags.pinned, ЛОЛ???\r\n    // ! т.е., с запросом folder_id: 1, и exclude_pinned: 0, в результате будут ещё и закреплённые с папки 0\r\n    const params: MessagesGetDialogs = {\r\n      folder_id: folderId,\r\n      offset_date: offsetDate,\r\n      offset_id: offsetId,\r\n      offset_peer: appPeersManager.getInputPeerById(offsetPeerId),\r\n      limit: useLimit,\r\n      hash: '0'\r\n    };\r\n\r\n    return apiManager.invokeApiSingle('messages.getDialogs', params, {\r\n      //timeout: APITIMEOUT,\r\n      noErrorBox: true\r\n    }).then((dialogsResult) => {\r\n      if(!middleware() || dialogsResult._ === 'messages.dialogsNotModified') return null;\r\n\r\n      if(DEBUG) {\r\n        this.log('messages.getDialogs result:', dialogsResult.dialogs, {...dialogsResult.dialogs[0]});\r\n      }\r\n\r\n      /* if(!offsetDate) {\r\n        telegramMeWebService.setAuthorized(true);\r\n      } */\r\n\r\n      // can reset pinned order here\r\n      if(!offsetId && !offsetDate && !offsetPeerId && folderId !== GLOBAL_FOLDER_ID) {\r\n        this.dialogsStorage.resetPinnedOrder(folderId);\r\n      }\r\n\r\n      if(!offsetDate) {\r\n        telegramMeWebManager.setAuthorized(true);\r\n      }\r\n\r\n      appUsersManager.saveApiUsers(dialogsResult.users);\r\n      appChatsManager.saveApiChats(dialogsResult.chats);\r\n      this.saveMessages(dialogsResult.messages);\r\n\r\n      /* if(folderId === 0 && !offsetDate) {\r\n        const found = dialogsResult.dialogs.find(dialog => appPeersManager.getPeerId(dialog.peer) === -1325963535);\r\n        if(!found) {\r\n          debugger;\r\n        }\r\n      } */\r\n\r\n      let maxSeenIdIncremented = offsetDate ? true : false;\r\n      let hasPrepend = false;\r\n      const noIdsDialogs: {[peerId: PeerId]: Dialog} = {};\r\n      const setFolderId = folderId === GLOBAL_FOLDER_ID ? 0 : folderId;\r\n      const saveGlobalOffset = folderId === GLOBAL_FOLDER_ID;\r\n      forEachReverse((dialogsResult.dialogs as Dialog[]), dialog => {\r\n        //const d = Object.assign({}, dialog);\r\n        // ! нужно передавать folderId, так как по папке !== 0 нет свойства folder_id\r\n        if(dialog.folder_id === undefined) {\r\n          dialog.folder_id = setFolderId;\r\n        }\r\n\r\n        this.dialogsStorage.saveDialog(dialog, undefined, true, saveGlobalOffset);\r\n\r\n        if(!maxSeenIdIncremented &&\r\n          !appPeersManager.isChannel(dialog.peerId || appPeersManager.getPeerId(dialog.peer))) {\r\n          this.incrementMaxSeenId(dialog.top_message);\r\n          maxSeenIdIncremented = true;\r\n        }\r\n\r\n        if(dialog.peerId === undefined) {\r\n          return;\r\n        }\r\n\r\n        // if(!folderId && !dialog.folder_id) {\r\n        //   this.lolSet.add(dialog.peerId);\r\n        // }\r\n\r\n        /* if(dialog.peerId === -1213511294) {\r\n          this.log.error('lun bot', folderId, d);\r\n        } */\r\n\r\n        if(offsetIndex && dialog.index > offsetIndex) {\r\n          this.scheduleHandleNewDialogs(dialog.peerId, dialog);\r\n          hasPrepend = true;\r\n        }\r\n\r\n        // ! это может случиться, если запрос идёт не по папке 0, а по 1. почему-то read'ов нет\r\n        // ! в итоге, чтобы получить 1 диалог, делается первый запрос по папке 0, потом запрос для архивных по папке 1, и потом ещё перезагрузка архивного диалога\r\n        if(!appMessagesIdsManager.getServerMessageId(dialog.read_inbox_max_id) && !appMessagesIdsManager.getServerMessageId(dialog.read_outbox_max_id)) {\r\n          noIdsDialogs[dialog.peerId] = dialog;\r\n\r\n          this.log.error('noIdsDialogs', dialog, params);\r\n\r\n          /* if(dialog.peerId === -1213511294) {\r\n            this.log.error('lun bot', folderId);\r\n          } */\r\n        }\r\n      });\r\n\r\n      const keys = Object.keys(noIdsDialogs);\r\n      if(keys.length) {\r\n        //setTimeout(() => { // test bad situation\r\n          const peerIds = keys.map(key => key.toPeerId());\r\n          const promises = peerIds.map(peerId => this.reloadConversation(peerId));\r\n          Promise.all(promises).then(() => {\r\n            rootScope.dispatchEvent('dialogs_multiupdate', noIdsDialogs);\r\n  \r\n            for(let i = 0; i < peerIds.length; ++i) {\r\n              rootScope.dispatchEvent('dialog_unread', {peerId: peerIds[i]});\r\n            }\r\n          });\r\n        //}, 10e3);\r\n      }\r\n\r\n      const count = (dialogsResult as MessagesDialogs.messagesDialogsSlice).count;\r\n\r\n      // exclude empty draft dialogs\r\n      const folderDialogs = this.dialogsStorage.getFolderDialogs(folderId, false);\r\n      let dialogsLength = 0;\r\n      for(let i = 0, length = folderDialogs.length; i < length; ++i) {\r\n        if(appMessagesIdsManager.getServerMessageId(folderDialogs[i].top_message)) {\r\n          ++dialogsLength;\r\n        }\r\n      }\r\n\r\n      const isEnd = /* limit > dialogsResult.dialogs.length || */ \r\n        !count || \r\n        dialogsLength >= count ||\r\n        !dialogsResult.dialogs.length;\r\n      if(isEnd) {\r\n        this.dialogsStorage.setDialogsLoaded(folderId, true);\r\n      }\r\n\r\n      if(hasPrepend) {\r\n        this.scheduleHandleNewDialogs();\r\n      } else {\r\n        rootScope.dispatchEvent('dialogs_multiupdate', {});\r\n      }\r\n\r\n      const dialogs = (dialogsResult as MessagesDialogs.messagesDialogsSlice).dialogs;\r\n      const slicedDialogs = limit === useLimit ? dialogs : dialogs.slice(0, limit);\r\n      return {\r\n        isEnd: isEnd && slicedDialogs[slicedDialogs.length - 1] === dialogs[dialogs.length - 1], \r\n        count, \r\n        dialogs: slicedDialogs\r\n      };\r\n    });\r\n  }\r\n\r\n  public forwardMessages(peerId: PeerId, fromPeerId: PeerId, mids: number[], options: Partial<{\r\n    withMyScore: true,\r\n    silent: true,\r\n    scheduleDate: number,\r\n    dropAuthor: boolean,\r\n    dropCaptions: boolean,\r\n    sendAsPeerId: PeerId,\r\n  }> = {}) {\r\n    peerId = appPeersManager.getPeerMigratedTo(peerId) || peerId;\r\n    mids = mids.slice().sort((a, b) => a - b);\r\n\r\n    for(let i = 0, length = mids.length; i < length; ++i) {\r\n      const mid = mids[i];\r\n      const originalMessage: Message.message = this.getMessageByPeer(fromPeerId, mid);\r\n      if(originalMessage.pFlags.is_outgoing) { // this can happen when forwarding a changelog\r\n        this.sendText(peerId, originalMessage.message, {\r\n          entities: originalMessage.entities,\r\n          scheduleDate: options.scheduleDate,\r\n          silent: options.silent\r\n        });\r\n\r\n        mids.splice(i--, 1);\r\n      }\r\n    }\r\n\r\n    if(!mids.length) {\r\n      return Promise.resolve();\r\n    }\r\n\r\n    if(options.dropCaptions) {\r\n      options.dropAuthor = true;\r\n    }\r\n\r\n    const groups: {\r\n      [groupId: string]: {\r\n        tempId: string,\r\n        messages: Message.message[]\r\n      }\r\n    } = {};\r\n\r\n    const newMids: number[] = [];\r\n    const newMessages = mids.map((mid) => {\r\n      const originalMessage: Message.message = this.getMessageByPeer(fromPeerId, mid);\r\n      const message: Message.message = this.generateOutgoingMessage(peerId, options);\r\n      newMids.push(message.id);\r\n\r\n      const keys: Array<keyof Message.message> = [\r\n        'entities', \r\n        'media', \r\n        // 'reply_markup'\r\n      ];\r\n\r\n      if(!options.dropAuthor) {\r\n        message.fwd_from = this.generateForwardHeader(peerId, originalMessage);\r\n        keys.push('views', 'forwards');\r\n\r\n        if(message.fwd_from?.from_name && peerId === rootScope.myId) {\r\n          delete message.from_id;\r\n        }\r\n      }\r\n\r\n      if(!options.dropCaptions || !originalMessage.media) {\r\n        keys.push('message');\r\n      }\r\n\r\n      const replyToMid = originalMessage.reply_to?.reply_to_msg_id;\r\n      const replyToMessageIdx = mids.indexOf(replyToMid);\r\n      if(replyToMid && replyToMessageIdx !== -1) {\r\n        const newReplyToMid = newMids[replyToMessageIdx];\r\n        message.reply_to = {\r\n          _: 'messageReplyHeader',\r\n          reply_to_msg_id: newReplyToMid\r\n        };\r\n\r\n        /* this.invokeAfterMessageIsSent(newReplyToMid, 'reply', async(originalMessage) => {\r\n          message.reply_to.reply_to_msg_id = originalMessage.mid;\r\n        }); */\r\n      }\r\n\r\n      keys.forEach(key => {\r\n        // @ts-ignore\r\n        message[key] = originalMessage[key];\r\n      });\r\n\r\n      const document = (message.media as MessageMedia.messageMediaDocument)?.document as MyDocument;\r\n      if(document) {\r\n        const types: MyDocument['type'][] = ['round', 'voice'];\r\n        if(types.includes(document.type)) {\r\n          (message as MyMessage).pFlags.media_unread = true;\r\n        }\r\n      }\r\n\r\n      if(originalMessage.grouped_id) {\r\n        const group = groups[originalMessage.grouped_id] ?? (groups[originalMessage.grouped_id] = {tempId: '' + ++this.groupedTempId, messages: []});\r\n        group.messages.push(message);\r\n      }\r\n\r\n      return message;\r\n    });\r\n\r\n    for(const groupId in groups) {\r\n      const group = groups[groupId];\r\n      if(group.messages.length > 1) {\r\n        group.messages.forEach(message => {\r\n          message.grouped_id = group.tempId;\r\n        });\r\n      }\r\n    }\r\n\r\n    newMessages.forEach(message => {\r\n      this.beforeMessageSending(message, {\r\n        isScheduled: !!options.scheduleDate || undefined\r\n      });\r\n    });\r\n\r\n    const sentRequestOptions: PendingAfterMsg = {};\r\n    if(this.pendingAfterMsgs[peerId]) {\r\n      sentRequestOptions.afterMessageId = this.pendingAfterMsgs[peerId].messageId;\r\n    }\r\n\r\n    const promise = /* true ? Promise.resolve() :  */apiManager.invokeApiAfter('messages.forwardMessages', {\r\n      from_peer: appPeersManager.getInputPeerById(fromPeerId),\r\n      id: mids.map(mid => appMessagesIdsManager.getServerMessageId(mid)),\r\n      random_id: newMessages.map(message => message.random_id),\r\n      to_peer: appPeersManager.getInputPeerById(peerId),\r\n      with_my_score: options.withMyScore,\r\n      silent: options.silent,\r\n      schedule_date: options.scheduleDate,\r\n      drop_author: options.dropAuthor,\r\n      drop_media_captions: options.dropCaptions,\r\n      send_as: options.sendAsPeerId ? appPeersManager.getInputPeerById(options.sendAsPeerId) : undefined\r\n    }, sentRequestOptions).then((updates) => {\r\n      this.log('forwardMessages updates:', updates);\r\n      apiUpdatesManager.processUpdateMessage(updates);\r\n    }).finally(() => {\r\n      if(this.pendingAfterMsgs[peerId] === sentRequestOptions) {\r\n        delete this.pendingAfterMsgs[peerId];\r\n      }\r\n    });\r\n\r\n    this.pendingAfterMsgs[peerId] = sentRequestOptions;\r\n    return promise;\r\n  }\r\n\r\n  public generateEmptyMessage(mid: number): Message.messageEmpty {\r\n    return {\r\n      _: 'messageEmpty',\r\n      id: appMessagesIdsManager.getServerMessageId(mid),\r\n      mid,\r\n      deleted: true,\r\n      pFlags: {}\r\n    };\r\n  }\r\n\r\n  public getMessageFromStorage(storage: MessagesStorage, mid: number) {\r\n    return storage && storage.get(mid) || this.generateEmptyMessage(mid);\r\n  }\r\n\r\n  private createMessageStorage() {\r\n    const storage: MessagesStorage = new Map();\r\n    \r\n    /* let num = 0;\r\n    Object.defineProperty(storage, 'num', {\r\n      get: () => ++num,\r\n      set: (_num: number) => num = _num, \r\n      enumerable: false\r\n    });\r\n\r\n    Object.defineProperty(storage, 'generateIndex', {\r\n      value: (message: any) => {\r\n        if(message.index === undefined) {\r\n          message.index = (message.date * 0x10000) + (storage.num & 0xFFFF);\r\n        }\r\n      },\r\n      enumerable: false\r\n    }); */\r\n\r\n    return storage;\r\n  }\r\n\r\n  public getMessagesStorage(peerId: PeerId) {\r\n    return this.messagesStorageByPeerId[peerId] ?? (this.messagesStorageByPeerId[peerId] = this.createMessageStorage());\r\n  }\r\n\r\n  public getMessageById(messageId: number) {\r\n    for(const peerId in this.messagesStorageByPeerId) {\r\n      if(appPeersManager.isChannel(peerId.toPeerId())) {\r\n        continue;\r\n      }\r\n\r\n      const message = this.messagesStorageByPeerId[peerId].get(messageId);\r\n      if(message) {\r\n        return message;\r\n      }\r\n    }\r\n\r\n    return this.getMessageFromStorage(null, messageId);\r\n  }\r\n\r\n  public getMessageByPeer(peerId: PeerId, messageId: number) {\r\n    if(!peerId) {\r\n      return this.getMessageById(messageId);\r\n    }\r\n\r\n    return this.getMessageFromStorage(this.getMessagesStorage(peerId), messageId);\r\n  }\r\n\r\n  public getMessagePeer(message: any): PeerId {\r\n    const toId = message.peer_id && appPeersManager.getPeerId(message.peer_id) || NULL_PEER_ID;\r\n\r\n    return toId;\r\n  }\r\n\r\n  public getDialogByPeerId(peerId: PeerId): [Dialog, number] | [] {\r\n    return this.dialogsStorage.getDialog(peerId);\r\n  }\r\n\r\n  public getDialogOnly(peerId: PeerId) {\r\n    return this.dialogsStorage.getDialogOnly(peerId);\r\n  }\r\n\r\n  public reloadConversation(inputPeer?: PeerId | InputPeer): CancellablePromise<Dialog>;\r\n  public reloadConversation(inputPeer: PeerId | InputPeer) {\r\n    let promise: CancellablePromise<Dialog>;\r\n    if(inputPeer !== undefined) {\r\n      const peerId = appPeersManager.getPeerId(inputPeer);\r\n      let obj = this.reloadConversationsPeers.get(peerId);\r\n      if(obj) {\r\n        promise = obj.promise;\r\n      }\r\n\r\n      if(promise) {\r\n        return promise;\r\n      }\r\n\r\n      promise = deferredPromise();\r\n      this.reloadConversationsPeers.set(peerId, obj = {\r\n        inputDialogPeer: appPeersManager.getInputDialogPeerById(inputPeer),\r\n        promise\r\n      });\r\n    }\r\n\r\n    if(this.reloadConversationsPromise) {\r\n      return promise || this.reloadConversationsPromise;\r\n    }\r\n\r\n    this.reloadConversationsPromise = new Promise((resolve, reject) => {\r\n      setTimeout(() => {\r\n        const inputDialogPeers: InputDialogPeer[] = [];\r\n        const promises: {[peerId: string]: typeof promise} = {};\r\n        for(const [peerId, {inputDialogPeer, promise}] of this.reloadConversationsPeers) {\r\n          inputDialogPeers.push(inputDialogPeer);\r\n          promises[peerId] = promise;\r\n        }\r\n\r\n        this.reloadConversationsPeers.clear();\r\n\r\n        const fullfillLeft = () => {\r\n          for(const peerId in promises) {\r\n            promises[peerId].resolve(undefined);\r\n          }\r\n        };\r\n\r\n        apiManager.invokeApi('messages.getPeerDialogs', {peers: inputDialogPeers}).then((result) => {\r\n          this.dialogsStorage.applyDialogs(result);\r\n\r\n          result.dialogs.forEach((dialog) => {\r\n            const peerId = dialog.peerId;\r\n            if(peerId) {\r\n              promises[peerId].resolve(dialog as Dialog);\r\n              delete promises[peerId];\r\n            }\r\n          });\r\n\r\n          // fullfillLeft();\r\n          // resolve();\r\n        }, (err) => {\r\n          // fullfillLeft();\r\n          // resolve();\r\n          // reject(err);\r\n        }).finally(() => {\r\n          fullfillLeft();\r\n          resolve();\r\n          \r\n          this.reloadConversationsPromise = null;\r\n\r\n          if(this.reloadConversationsPeers.size) {\r\n            this.reloadConversation();\r\n          }\r\n        });\r\n      }, 0);\r\n    });\r\n\r\n    return promise || this.reloadConversationsPromise;\r\n  }\r\n\r\n  private doFlushHistory(peer: InputPeer, just_clear?: boolean, revoke?: boolean): Promise<true> {\r\n    return apiManager.invokeApiSingle('messages.deleteHistory', {\r\n      just_clear,\r\n      revoke,\r\n      peer,\r\n      max_id: 0\r\n    }).then((affectedHistory) => {\r\n      apiUpdatesManager.processUpdateMessage({\r\n        _: 'updateShort',\r\n        update: {\r\n          _: 'updatePts',\r\n          pts: affectedHistory.pts,\r\n          pts_count: affectedHistory.pts_count\r\n        }\r\n      });\r\n\r\n      if(!affectedHistory.offset) {\r\n        return true;\r\n      }\r\n\r\n      return this.doFlushHistory(peer, just_clear, revoke);\r\n    });\r\n  }\r\n\r\n  public async flushHistory(peerId: PeerId, justClear?: boolean, revoke?: boolean) {\r\n    if(appPeersManager.isChannel(peerId)) {\r\n      const promise = this.getHistory(peerId, 0, 1);\r\n\r\n      const historyResult = promise instanceof Promise ? await promise : promise;\r\n\r\n      const channelId = peerId.toChatId();\r\n      const maxId = historyResult.history[0] || 0;\r\n      return apiManager.invokeApiSingle('channels.deleteHistory', {\r\n        channel: appChatsManager.getChannelInput(channelId),\r\n        max_id: appMessagesIdsManager.getServerMessageId(maxId)\r\n      }).then((bool) => {\r\n        if(bool) {\r\n          apiUpdatesManager.processLocalUpdate({\r\n            _: 'updateChannelAvailableMessages',\r\n            channel_id: channelId,\r\n            available_min_id: maxId\r\n          });\r\n        }\r\n\r\n        return bool;\r\n      });\r\n    }\r\n\r\n    return this.doFlushHistory(appPeersManager.getInputPeerById(peerId), justClear, revoke).then(() => {\r\n      [\r\n        this.historiesStorage, \r\n        this.threadsStorage, \r\n        this.searchesStorage, \r\n        this.pinnedMessages,\r\n        this.pendingAfterMsgs,\r\n        this.pendingTopMsgs\r\n      ].forEach(s => {\r\n        delete s[peerId];\r\n      });\r\n\r\n      const m = this.needSingleMessages.get(peerId);\r\n      if(m) {\r\n        m.clear();\r\n      }\r\n\r\n      [\r\n        this.messagesStorageByPeerId,\r\n        this.scheduledMessagesStorage\r\n      ].forEach(s => {\r\n        const ss = s[peerId];\r\n        if(ss) {\r\n          ss.clear();\r\n        }\r\n      });\r\n      \r\n      if(justClear) {\r\n        rootScope.dispatchEvent('dialog_flush', {peerId});\r\n      } else {\r\n        delete this.notificationsToHandle[peerId];\r\n        delete this.typings[peerId];\r\n        \r\n        const c = this.reloadConversationsPeers.get(peerId);\r\n        if(c) {\r\n          this.reloadConversationsPeers.delete(peerId);\r\n          c.promise.resolve(undefined);\r\n        }\r\n\r\n        this.dialogsStorage.dropDialogOnDeletion(peerId);\r\n      }\r\n    });\r\n  }\r\n\r\n  public onPeerDeleted(peerId: number) {\r\n\r\n  }\r\n\r\n  public hidePinnedMessages(peerId: PeerId) {\r\n    return Promise.all([\r\n      appStateManager.getState(),\r\n      this.getPinnedMessage(peerId)\r\n    ])\r\n    .then(([state, pinned]) => {\r\n      state.hiddenPinnedMessages[peerId] = pinned.maxId;\r\n      rootScope.dispatchEvent('peer_pinned_hidden', {peerId, maxId: pinned.maxId});\r\n    });\r\n  }\r\n\r\n  public getPinnedMessage(peerId: PeerId) {\r\n    const p = this.pinnedMessages[peerId] ?? (this.pinnedMessages[peerId] = {});\r\n    if(p.promise) return p.promise;\r\n    else if(p.maxId) return Promise.resolve(p);\r\n\r\n    return p.promise = this.getSearch({\r\n      peerId, \r\n      inputFilter: {_: 'inputMessagesFilterPinned'},\r\n      maxId: 0,\r\n      limit: 1\r\n    }).then(result => {\r\n      p.count = result.count;\r\n      p.maxId = result.history[0]?.mid;\r\n      return p;\r\n    }).finally(() => {\r\n      delete p.promise;\r\n    });\r\n  }\r\n\r\n  public updatePinnedMessage(peerId: PeerId, mid: number, unpin?: boolean, silent?: boolean, pm_oneside?: boolean) {\r\n    return apiManager.invokeApi('messages.updatePinnedMessage', {\r\n      peer: appPeersManager.getInputPeerById(peerId),\r\n      unpin,\r\n      silent,\r\n      pm_oneside,\r\n      id: appMessagesIdsManager.getServerMessageId(mid)\r\n    }).then(updates => {\r\n      //this.log('pinned updates:', updates);\r\n      apiUpdatesManager.processUpdateMessage(updates);\r\n    });\r\n  }\r\n\r\n  public unpinAllMessages(peerId: PeerId): Promise<boolean> {\r\n    return apiManager.invokeApiSingle('messages.unpinAllMessages', {\r\n      peer: appPeersManager.getInputPeerById(peerId)\r\n    }).then(affectedHistory => {\r\n      apiUpdatesManager.processUpdateMessage({\r\n        _: 'updateShort',\r\n        update: {\r\n          _: 'updatePts',\r\n          pts: affectedHistory.pts,\r\n          pts_count: affectedHistory.pts_count\r\n        }\r\n      });\r\n\r\n      if(!affectedHistory.offset) {\r\n        const storage = this.getMessagesStorage(peerId);\r\n        storage.forEach((message) => {\r\n          if(message.pFlags.pinned) {\r\n            delete message.pFlags.pinned;\r\n          }\r\n        });\r\n\r\n        rootScope.dispatchEvent('peer_pinned_messages', {peerId, unpinAll: true});\r\n        delete this.pinnedMessages[peerId];\r\n\r\n        return true;\r\n      }\r\n\r\n      return this.unpinAllMessages(peerId);\r\n    });\r\n  }\r\n\r\n  public getAlbumText(grouped_id: string) {\r\n    const group = this.groupedMessagesStorage[grouped_id];\r\n    let foundMessages = 0, message: string, totalEntities: MessageEntity[], entities: MessageEntity[];\r\n    for(const [mid, m] of group) {\r\n      if(m.message) {\r\n        if(++foundMessages > 1) break;\r\n        message = m.message;\r\n        totalEntities = m.totalEntities;\r\n        entities = m.entities;\r\n      }\r\n    }\r\n\r\n    if(foundMessages > 1) {\r\n      message = undefined;\r\n      totalEntities = undefined;\r\n      entities = undefined;\r\n    }\r\n\r\n    return {message, entities, totalEntities};\r\n  }\r\n\r\n  public getGroupsFirstMessage(message: Message.message): Message.message {\r\n    if(!message.grouped_id) return message;\r\n\r\n    const storage = this.groupedMessagesStorage[message.grouped_id];\r\n    let minMid = Number.MAX_SAFE_INTEGER;\r\n    for(const [mid, message] of storage) {\r\n      if(message.mid < minMid) {\r\n        minMid = message.mid;\r\n      }\r\n    }\r\n\r\n    return storage.get(minMid);\r\n  }\r\n\r\n  public getMidsByAlbum(grouped_id: string) {\r\n    return getObjectKeysAndSort(this.groupedMessagesStorage[grouped_id], 'asc');\r\n    //return Object.keys(this.groupedMessagesStorage[grouped_id]).map(id => +id).sort((a, b) => a - b);\r\n  }\r\n\r\n  public getMidsByMessage(message: Message) {\r\n    if((message as Message.message)?.grouped_id) return this.getMidsByAlbum((message as Message.message).grouped_id);\r\n    else return [message.mid];\r\n  }\r\n\r\n  public filterMessages(message: MyMessage, verify: (message: MyMessage) => boolean) {\r\n    const out: MyMessage[] = [];\r\n    if((message as Message.message).grouped_id) {\r\n      const storage = this.groupedMessagesStorage[(message as Message.message).grouped_id];\r\n      for(const [mid, message] of storage) {\r\n        if(verify(message)) {\r\n          out.push(message);\r\n        }\r\n      }\r\n    } else {\r\n      if(verify(message)) {\r\n        out.push(message);\r\n      }\r\n    }\r\n\r\n    return out;\r\n  }\r\n\r\n  public generateTempMessageId(peerId: PeerId) {\r\n    const dialog = this.getDialogOnly(peerId);\r\n    return appMessagesIdsManager.generateMessageId(dialog?.top_message || 0, true);\r\n  }\r\n\r\n  public saveMessage(message: Message, options: Partial<{\r\n    storage: MessagesStorage,\r\n    isScheduled: true,\r\n    isOutgoing: true,\r\n    //isNew: boolean, // * new - from update\r\n  }> = {}) {\r\n    if(message.pFlags === undefined) {\r\n      message.pFlags = {};\r\n    }\r\n\r\n    if(message._ === 'messageEmpty') {\r\n      message.deleted = true;\r\n      return;\r\n    }\r\n\r\n    // * exclude from state\r\n    // defineNotNumerableProperties(message, ['rReply', 'mid', 'savedFrom', 'fwdFromId', 'fromId', 'peerId', 'reply_to_mid', 'viaBotId']);\r\n\r\n    const peerId = this.getMessagePeer(message);\r\n    const storage = options.storage || this.getMessagesStorage(peerId);\r\n    const isChannel = message.peer_id._ === 'peerChannel';\r\n    const isBroadcast = isChannel && appChatsManager.isBroadcast(peerId.toChatId());\r\n    const isMessage = message._ === 'message';\r\n\r\n    if(options.isOutgoing) {\r\n      message.pFlags.is_outgoing = true;\r\n    }\r\n    \r\n    const mid = appMessagesIdsManager.generateMessageId(message.id);\r\n    message.mid = mid;\r\n\r\n    if(isMessage) {\r\n      if(options.isScheduled) {\r\n        message.pFlags.is_scheduled = true;\r\n      }\r\n\r\n      if(message.grouped_id) {\r\n        const storage = this.groupedMessagesStorage[message.grouped_id] ?? (this.groupedMessagesStorage[message.grouped_id] = new Map());\r\n        storage.set(mid, message);\r\n      }\r\n\r\n      if(message.via_bot_id) {\r\n        // ! WARNING\r\n        message.viaBotId = message.via_bot_id as any;\r\n      }\r\n    }\r\n\r\n    const dialog = this.getDialogOnly(peerId);\r\n    if(dialog && mid) {\r\n      if(mid > dialog[message.pFlags.out\r\n        ? 'read_outbox_max_id'\r\n        : 'read_inbox_max_id']) {\r\n        message.pFlags.unread = true;\r\n      }\r\n    }\r\n    // this.log(dT(), 'msg unread', mid, apiMessage.pFlags.out, dialog && dialog[apiMessage.pFlags.out ? 'read_outbox_max_id' : 'read_inbox_max_id'])\r\n\r\n    if(message.reply_to) {\r\n      if(message.reply_to.reply_to_msg_id) {\r\n        message.reply_to.reply_to_msg_id = message.reply_to_mid = appMessagesIdsManager.generateMessageId(message.reply_to.reply_to_msg_id);\r\n      } \r\n\r\n      if(message.reply_to.reply_to_top_id) message.reply_to.reply_to_top_id = appMessagesIdsManager.generateMessageId(message.reply_to.reply_to_top_id);\r\n    }\r\n\r\n    if(isMessage && message.replies) {\r\n      if(message.replies.max_id) message.replies.max_id = appMessagesIdsManager.generateMessageId(message.replies.max_id);\r\n      if(message.replies.read_max_id) message.replies.read_max_id = appMessagesIdsManager.generateMessageId(message.replies.read_max_id);\r\n    }\r\n\r\n    const overwriting = !!peerId;\r\n    if(!overwriting) {\r\n      message.date -= serverTimeManager.serverTimeOffset;\r\n    }\r\n    \r\n    //storage.generateIndex(message);\r\n    const myId = appUsersManager.getSelf().id.toPeerId();\r\n\r\n    const fwdHeader = isMessage && (message as Message.message).fwd_from as MessageFwdHeader;\r\n\r\n    message.peerId = peerId;\r\n    if(peerId === myId/*  && !message.from_id && !message.fwd_from */) {\r\n      message.fromId = fwdHeader ? (fwdHeader.from_id ? appPeersManager.getPeerId(fwdHeader.from_id) : NULL_PEER_ID) : myId;\r\n    } else {\r\n      //message.fromId = message.pFlags.post || (!message.pFlags.out && !message.from_id) ? peerId : appPeersManager.getPeerId(message.from_id);\r\n      message.fromId = message.pFlags.post || !message.from_id ? peerId : appPeersManager.getPeerId(message.from_id);\r\n    }\r\n\r\n    if(fwdHeader) {\r\n      //if(peerId === myID) {\r\n        if(fwdHeader.saved_from_msg_id) fwdHeader.saved_from_msg_id = appMessagesIdsManager.generateMessageId(fwdHeader.saved_from_msg_id);\r\n        if(fwdHeader.channel_post) fwdHeader.channel_post = appMessagesIdsManager.generateMessageId(fwdHeader.channel_post);\r\n\r\n        const peer = fwdHeader.saved_from_peer || fwdHeader.from_id;\r\n        const msgId = fwdHeader.saved_from_msg_id || fwdHeader.channel_post;\r\n        if(peer && msgId) {\r\n          const savedFromPeerId = appPeersManager.getPeerId(peer);\r\n          const savedFromMid = appMessagesIdsManager.generateMessageId(msgId);\r\n          message.savedFrom = savedFromPeerId + '_' + savedFromMid;\r\n        }\r\n\r\n        /* if(peerId.isAnyChat() || peerId === myID) {\r\n          message.fromId = appPeersManager.getPeerID(!message.from_id || deepEqual(message.from_id, fwdHeader.from_id) ? fwdHeader.from_id : message.from_id);\r\n        } */\r\n      /* } else {\r\n        apiMessage.fwdPostID = fwdHeader.channel_post;\r\n      } */\r\n\r\n      message.fwdFromId = appPeersManager.getPeerId(fwdHeader.from_id);\r\n\r\n      if(!overwriting) {\r\n        fwdHeader.date -= serverTimeManager.serverTimeOffset;\r\n      }\r\n    }\r\n\r\n    const mediaContext: ReferenceContext = {\r\n      type: 'message',\r\n      peerId,\r\n      messageId: mid\r\n    };\r\n\r\n    /* if(isMessage) {\r\n      const entities = message.entities;\r\n      if(entities && entities.find(entity => entity._ === 'messageEntitySpoiler')) {\r\n        message.media = {_: 'messageMediaUnsupported'};\r\n      }\r\n    } */\r\n\r\n    if(isMessage && message.media) {\r\n      let unsupported = false;\r\n      switch(message.media._) {\r\n        case 'messageMediaEmpty': {\r\n          delete message.media;\r\n          break;\r\n        }\r\n\r\n        case 'messageMediaPhoto': {\r\n          if(message.media.ttl_seconds) {\r\n            unsupported = true;\r\n          } else {\r\n            message.media.photo = appPhotosManager.savePhoto(message.media.photo, mediaContext);\r\n          }\r\n\r\n          if(!(message.media as MessageMedia.messageMediaPhoto).photo) { // * found this bug on test DC\r\n            delete message.media;\r\n          }\r\n          \r\n          break;\r\n        }\r\n          \r\n        case 'messageMediaPoll': {\r\n          const result = appPollsManager.savePoll(message.media.poll, message.media.results, message);\r\n          message.media.poll = result.poll;\r\n          message.media.results = result.results;\r\n          break;\r\n        }\r\n          \r\n        case 'messageMediaDocument': {\r\n          if(message.media.ttl_seconds) {\r\n            unsupported = true;\r\n          } else {\r\n            const originalDoc = message.media.document;\r\n            message.media.document = appDocsManager.saveDoc(originalDoc, mediaContext); // 11.04.2020 warning\r\n\r\n            if(!message.media.document && originalDoc._ !== 'documentEmpty') {\r\n              unsupported = true;\r\n            }\r\n          }\r\n\r\n          break;\r\n        }\r\n          \r\n        case 'messageMediaWebPage': {\r\n          const messageKey = appWebPagesManager.getMessageKeyForPendingWebPage(peerId, mid, options.isScheduled);\r\n          message.media.webpage = appWebPagesManager.saveWebPage(message.media.webpage, messageKey, mediaContext);\r\n          break;\r\n        }\r\n          \r\n        /*case 'messageMediaGame':\r\n          AppGamesManager.saveGame(apiMessage.media.game, apiMessage.mid, mediaContext);\r\n          apiMessage.media.handleMessage = true;\r\n          break; */\r\n\r\n        case 'messageMediaInvoice': {\r\n          unsupported = true;\r\n          message.media = {_: 'messageMediaUnsupported'};\r\n          break;\r\n        }\r\n\r\n        case 'messageMediaUnsupported': {\r\n          unsupported = true;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if(unsupported) {\r\n        message.media = {_: 'messageMediaUnsupported'};\r\n        message.message = '';\r\n        delete message.entities;\r\n        delete message.totalEntities;\r\n      }\r\n    }\r\n\r\n    if(!isMessage && message.action) {\r\n      const action = message.action as MessageAction;\r\n      let migrateFrom: PeerId;\r\n      let migrateTo: PeerId;\r\n      const suffix = message.fromId === appUsersManager.getSelf().id ? 'You' : '';\r\n\r\n      if((action as MessageAction.messageActionChatEditPhoto).photo) {\r\n        (action as MessageAction.messageActionChatEditPhoto).photo = appPhotosManager.savePhoto((action as MessageAction.messageActionChatEditPhoto).photo, mediaContext);\r\n      }\r\n\r\n      if((action as any).document) {\r\n        (action as any).document = appDocsManager.saveDoc((action as any).photo, mediaContext);\r\n      }\r\n\r\n      switch(action._) {\r\n        //case 'messageActionChannelEditPhoto':\r\n        case 'messageActionChatEditPhoto':\r\n          // action.photo = appPhotosManager.savePhoto(action.photo, mediaContext);\r\n          if((action.photo as Photo.photo)?.video_sizes) {\r\n            // @ts-ignore\r\n            action._ = isBroadcast ? 'messageActionChannelEditVideo' : 'messageActionChatEditVideo';\r\n          } else {\r\n            if(isBroadcast) { // ! messageActionChannelEditPhoto не существует в принципе, это используется для перевода.\r\n              // @ts-ignore\r\n              action._ = 'messageActionChannelEditPhoto';\r\n            }\r\n          }\r\n          break;\r\n        \r\n        case 'messageActionGroupCall': {\r\n          //assumeType<MessageAction.messageActionGroupCall>(action);\r\n\r\n          appGroupCallsManager.saveGroupCall(action.call);\r\n\r\n          let type: string;\r\n          if(action.duration === undefined) {\r\n            type = 'started';\r\n          } else {\r\n            type = 'ended'\r\n          }\r\n\r\n          if(!isBroadcast) {\r\n            type += '_by' + suffix;\r\n          }\r\n\r\n          // @ts-ignore\r\n          action.type = type;\r\n\r\n          break;\r\n        }\r\n\r\n        case 'messageActionChatEditTitle':\r\n          /* if(options.isNew) {\r\n            const chat = appChatsManager.getChat(peerId.toChatId());\r\n            chat.title = action.title;\r\n            appChatsManager.saveApiChat(chat, true);\r\n          } */\r\n          \r\n          if(isBroadcast) {\r\n            // @ts-ignore\r\n            action._ = 'messageActionChannelEditTitle';\r\n          }\r\n          break;\r\n\r\n        case 'messageActionChatDeletePhoto':\r\n          if(isBroadcast) {\r\n            // @ts-ignore\r\n            action._ = 'messageActionChannelDeletePhoto';\r\n          }\r\n          break;\r\n\r\n        case 'messageActionChatAddUser':\r\n          if(action.users.length === 1) {\r\n            // @ts-ignore\r\n            action.user_id = action.users[0];\r\n            // @ts-ignore\r\n            if(message.fromId === action.user_id) {\r\n              if(isChannel) {\r\n                // @ts-ignore\r\n                action._ = 'messageActionChatJoined' + suffix;\r\n              } else {\r\n                // @ts-ignore\r\n                action._ = 'messageActionChatReturn' + suffix;\r\n              }\r\n            }\r\n          } else if(action.users.length > 1) {\r\n            // @ts-ignore\r\n            action._ = 'messageActionChatAddUsers';\r\n          }\r\n          break;\r\n\r\n        case 'messageActionChatDeleteUser':\r\n          if(message.fromId === action.user_id) {\r\n            // @ts-ignore\r\n            action._ = 'messageActionChatLeave' + suffix;\r\n          }\r\n          break;\r\n\r\n        case 'messageActionChannelMigrateFrom':\r\n          migrateFrom = action.chat_id.toPeerId(true);\r\n          migrateTo = peerId;\r\n          break\r\n\r\n        case 'messageActionChatMigrateTo':\r\n          migrateFrom = peerId;\r\n          migrateTo = action.channel_id.toPeerId(true);\r\n          break;\r\n\r\n        case 'messageActionHistoryClear':\r\n          //apiMessage.deleted = true;\r\n          message.clear_history = true;\r\n          delete message.pFlags.out;\r\n          delete message.pFlags.unread;\r\n          break;\r\n\r\n        case 'messageActionPhoneCall':\r\n          // @ts-ignore\r\n          action.type = \r\n            (action.pFlags.video ? 'video_' : '') +\r\n            (action.duration !== undefined ? (message.pFlags.out ? 'out_' : 'in_') : '') +\r\n            (\r\n              action.duration !== undefined ? 'ok' : (\r\n                action.reason._ === 'phoneCallDiscardReasonMissed'\r\n                  ? 'missed'\r\n                  : 'cancelled'\r\n              )\r\n            );\r\n          break;\r\n      }\r\n      \r\n      if(migrateFrom &&\r\n          migrateTo &&\r\n          !this.migratedFromTo[migrateFrom] &&\r\n          !this.migratedToFrom[migrateTo]) {\r\n        this.migrateChecks(migrateFrom, migrateTo);\r\n      }\r\n    }\r\n\r\n    /* if(message.grouped_id) {\r\n      if(!groups) {\r\n        groups = new Set();\r\n      }\r\n\r\n      groups.add(message.grouped_id);\r\n    } else {\r\n      message.rReply = this.getRichReplyText(message);\r\n    } */\r\n\r\n    if(isMessage && message.message.length && !message.totalEntities) {\r\n      this.wrapMessageEntities(message);  \r\n    }\r\n\r\n    storage.set(mid, message);\r\n  }\r\n\r\n  public saveMessages(messages: any[], options: Partial<{\r\n    storage: MessagesStorage,\r\n    isScheduled: true,\r\n    isOutgoing: true,\r\n    //isNew: boolean, // * new - from update\r\n  }> = {}) {\r\n    if((messages as any).saved) return;\r\n    (messages as any).saved = true;\r\n    messages.forEach((message) => {\r\n      this.saveMessage(message, options);\r\n    });\r\n  }\r\n\r\n  private wrapMessageEntities(message: Message.message) {\r\n    const apiEntities = message.entities ? message.entities.slice() : [];\r\n    message.message = RichTextProcessor.fixEmoji(message.message, apiEntities);\r\n\r\n    const myEntities = RichTextProcessor.parseEntities(message.message);\r\n    message.totalEntities = RichTextProcessor.mergeEntities(apiEntities, myEntities); // ! only in this order, otherwise bold and emoji formatting won't work\r\n  }\r\n\r\n  public wrapMessageForReply(message: MyMessage | MyDraftMessage, text: string, usingMids: number[], plain: true, highlightWord?: string, withoutMediaType?: boolean): string;\r\n  public wrapMessageForReply(message: MyMessage | MyDraftMessage, text?: string, usingMids?: number[], plain?: false, highlightWord?: string, withoutMediaType?: boolean): DocumentFragment;\r\n  public wrapMessageForReply(message: MyMessage | MyDraftMessage, text: string = (message as Message.message).message, usingMids?: number[], plain?: boolean, highlightWord?: string, withoutMediaType?: boolean): DocumentFragment | string {\r\n    const parts: (Node | string)[] = [];\r\n\r\n    let hasAlbumKey = false;\r\n    const addPart = (langKey: LangPackKey, part?: string | HTMLElement | DocumentFragment) => {\r\n      if(langKey) {\r\n        if(part === undefined && hasAlbumKey) {\r\n          return;\r\n        }\r\n        \r\n        part = plain ? I18n.format(langKey, true) : i18n(langKey);\r\n      }\r\n      \r\n      if(plain) {\r\n        parts.push(part);\r\n      } else {\r\n        const el = document.createElement('i');\r\n        if(typeof(part) === 'string') el.innerHTML = part;\r\n        else el.append(part);\r\n        parts.push(el);\r\n      }\r\n    };\r\n\r\n    const isRestricted = this.isRestricted(message as any);\r\n\r\n    let entities = (message as Message.message).totalEntities;\r\n    if((message as Message.message).media && !isRestricted) {\r\n      assumeType<Message.message>(message);\r\n      let usingFullAlbum = true;\r\n      if(message.grouped_id) {\r\n        if(usingMids) {\r\n          const mids = this.getMidsByMessage(message);\r\n          if(usingMids.length === mids.length) {\r\n            for(const mid of mids) {\r\n              if(!usingMids.includes(mid)) {\r\n                usingFullAlbum = false;\r\n                break;\r\n              }\r\n            }\r\n          } else {\r\n            usingFullAlbum = false;\r\n          }\r\n        }\r\n\r\n        if(usingFullAlbum) {\r\n          const albumText = this.getAlbumText(message.grouped_id);\r\n          text = albumText.message;\r\n          entities = albumText.totalEntities;\r\n\r\n          if(!withoutMediaType) {\r\n            addPart('AttachAlbum');\r\n            hasAlbumKey = true;\r\n          }\r\n        }\r\n      } else {\r\n        usingFullAlbum = false;\r\n      }\r\n\r\n      if((!usingFullAlbum && !withoutMediaType) || !text) {\r\n        const media = message.media;\r\n        switch(media._) {\r\n          case 'messageMediaPhoto':\r\n            addPart('AttachPhoto');\r\n            break;\r\n          case 'messageMediaDice':\r\n            addPart(undefined, plain ? media.emoticon : RichTextProcessor.wrapEmojiText(media.emoticon));\r\n            break;\r\n          case 'messageMediaVenue': {\r\n            text = media.title;\r\n            addPart('AttachLocation');\r\n            break;\r\n          }\r\n          case 'messageMediaGeo':\r\n            addPart('AttachLocation');\r\n            break;\r\n          case 'messageMediaGeoLive':\r\n            addPart('AttachLiveLocation');\r\n            break;\r\n          case 'messageMediaPoll':\r\n            const f = '📊' + ' ' + (media.poll.question || 'poll');\r\n            addPart(undefined, plain ? f : RichTextProcessor.wrapEmojiText(f));\r\n            break;\r\n          case 'messageMediaContact':\r\n            addPart('AttachContact');\r\n            break;\r\n          case 'messageMediaGame': {\r\n            const f = '🎮' + ' ' + media.game.title;\r\n            addPart(undefined, plain ? f : RichTextProcessor.wrapEmojiText(f));\r\n            break;\r\n          }\r\n          case 'messageMediaDocument': {\r\n            const document = media.document as MyDocument;\r\n  \r\n            if(document.type === 'video') {\r\n              addPart('AttachVideo');\r\n            } else if(document.type === 'voice') {\r\n              addPart('AttachAudio');\r\n            } else if(document.type === 'gif') {\r\n              addPart('AttachGif');\r\n            } else if(document.type === 'round') {\r\n              addPart('AttachRound');\r\n            } else if(document.type === 'sticker') {\r\n              const i = parts.length;\r\n              if(document.stickerEmojiRaw) {\r\n                const f = document.stickerEmojiRaw + ' ';\r\n                addPart(undefined, plain ? f : RichTextProcessor.wrapEmojiText(f));\r\n              }\r\n              \r\n              addPart('AttachSticker');\r\n\r\n              // will combine two parts into one\r\n              const p = parts.splice(i, 2);\r\n              if(plain) parts.push((p[0] as string) + (p[1] as string));\r\n              else {\r\n                const span = window.document.createElement('span');\r\n                span.append(...p);\r\n                parts.push(span);\r\n              }\r\n\r\n              text = '';\r\n            } else if(document.type === 'audio') {\r\n              const attribute = document.attributes.find(attribute => attribute._ === 'documentAttributeAudio' && (attribute.title || attribute.performer)) as DocumentAttribute.documentAttributeAudio;\r\n              const f = '🎵' + ' ' + (attribute ? [attribute.title, attribute.performer].filter(Boolean).join(' - ') : document.file_name);\r\n              addPart(undefined, plain ? f : RichTextProcessor.wrapEmojiText(f));\r\n            } else {\r\n              addPart(undefined, plain ? document.file_name : RichTextProcessor.wrapEmojiText(document.file_name));\r\n            }\r\n  \r\n            break;\r\n          }\r\n\r\n          case 'messageMediaUnsupported': {\r\n            addPart(UNSUPPORTED_LANG_PACK_KEY);\r\n            break;\r\n          }\r\n  \r\n          default:\r\n            //messageText += media._;\r\n            ///////this.log.warn('Got unknown media type!', message);\r\n            break;\r\n        }\r\n      }\r\n\r\n      const length = parts.length;\r\n      for(let i = 1; i < length; i += 2) {\r\n        parts.splice(i, 0, ', ');\r\n      }\r\n\r\n      if(text && length) {\r\n        parts.push(', ');\r\n      }\r\n    }\r\n\r\n    if((message as Message.messageService).action) {\r\n      const actionWrapped = this.wrapMessageActionTextNew((message as Message.messageService), plain);\r\n      if(actionWrapped) {\r\n        addPart(undefined, actionWrapped);\r\n      }\r\n    }\r\n\r\n    if(isRestricted) {\r\n      text = getRestrictionReason((message as Message.message).restriction_reason).text;\r\n      entities = [];\r\n    }\r\n\r\n    if(text) {\r\n      text = limitSymbols(text, 100);\r\n\r\n      if(!entities) {\r\n        entities = [];\r\n      }\r\n\r\n      if(plain) {\r\n        parts.push(RichTextProcessor.wrapPlainText(text, entities));\r\n      } else {\r\n        // let entities = RichTextProcessor.parseEntities(text.replace(/\\n/g, ' '));\r\n\r\n        if(highlightWord) {\r\n          highlightWord = highlightWord.trim();\r\n          let found = false;\r\n          let match: any;\r\n          let regExp = new RegExp(escapeRegExp(highlightWord), 'gi');\r\n          entities = entities.slice(); // fix leaving highlight entity\r\n          while((match = regExp.exec(text)) !== null) {\r\n            entities.push({_: 'messageEntityHighlight', length: highlightWord.length, offset: match.index});\r\n            found = true;\r\n          }\r\n      \r\n          if(found) {\r\n            RichTextProcessor.sortEntities(entities);\r\n          }\r\n        }\r\n\r\n        const messageWrapped = RichTextProcessor.wrapRichText(text, {\r\n          noLinebreaks: true, \r\n          entities, \r\n          noLinks: true,\r\n          noTextFormat: true\r\n        });\r\n  \r\n        parts.push(htmlToDocumentFragment(messageWrapped));\r\n      }\r\n    }\r\n\r\n    if(plain) {\r\n      return parts.join('');\r\n    } else {\r\n      const fragment = document.createDocumentFragment();\r\n      fragment.append(...parts);\r\n      return fragment;\r\n    }\r\n  }\r\n\r\n  public wrapSenderToPeer(message: MyMessage) {\r\n    const senderTitle: HTMLElement = document.createElement('span');\r\n    senderTitle.classList.add('sender-title');\r\n    \r\n    const fromMe = message.fromId === rootScope.myId && message.peerId !== rootScope.myId;\r\n    senderTitle.append(\r\n      fromMe ? \r\n        i18n('FromYou') : \r\n        new PeerTitle({\r\n          ...this.getMessageSenderPeerIdOrName(message),\r\n          dialog: message.peerId === rootScope.myId\r\n        }).element\r\n      );\r\n\r\n    if(appPeersManager.isAnyGroup(message.peerId) || fromMe) {\r\n      const peerTitle = new PeerTitle({peerId: message.peerId}).element;\r\n      senderTitle.append(' ➝ ', peerTitle);\r\n    }\r\n\r\n    return senderTitle;\r\n  }\r\n\r\n  public getMessageSenderPeerIdOrName(message: MyMessage) {\r\n    if(message.fromId) {\r\n      return {\r\n        peerId: message.fromId\r\n      };\r\n    } else {\r\n      return {\r\n        fromName: (message as Message.message).fwd_from?.from_name\r\n      };\r\n    }\r\n  }\r\n\r\n  public wrapSentTime(message: MyMessage) {\r\n    const el: HTMLElement = document.createElement('span');\r\n    el.classList.add('sent-time');\r\n    el.append(formatDateAccordingToTodayNew(new Date(message.date * 1000)));\r\n\r\n    return el;\r\n  }\r\n\r\n  private wrapJoinVoiceChatAnchor(message: Message.messageService) {\r\n    const action = message.action as MessageAction.messageActionInviteToGroupCall;\r\n    const {onclick, url} = RichTextProcessor.wrapUrl(`tg://voicechat?chat_id=${message.peerId.toChatId()}&id=${action.call.id}&access_hash=${action.call.access_hash}`);\r\n    if(!onclick) {\r\n      return document.createElement('span');\r\n    }\r\n    \r\n    const a = document.createElement('a');\r\n    a.href = url;\r\n    a.setAttribute('onclick', onclick + '(this)');\r\n\r\n    return a;\r\n  }\r\n\r\n  private wrapMessageActionTextNewUnsafe(message: MyMessage, plain?: boolean) {\r\n    const element: HTMLElement = plain ? undefined : document.createElement('span');\r\n    const action = 'action' in message && message.action;\r\n\r\n    // this.log('message action:', action);\r\n\r\n    if((action as MessageAction.messageActionCustomAction).message) {\r\n      const unsafeMessage = (action as MessageAction.messageActionCustomAction).message;\r\n      if(plain) {\r\n        return RichTextProcessor.wrapPlainText(unsafeMessage);\r\n      } else {\r\n        setInnerHTML(element, RichTextProcessor.wrapRichText(unsafeMessage, {noLinebreaks: true}));\r\n        return element;\r\n      }\r\n    } else {\r\n      let _ = action._;\r\n      //let suffix = '';\r\n      let langPackKey: LangPackKey;\r\n      let args: any[];\r\n\r\n      const getNameDivHTML = (peerId: PeerId, plain: boolean) => {\r\n        return plain ? appPeersManager.getPeerTitle(peerId, plain) : (new PeerTitle({peerId})).element;\r\n      };\r\n\r\n      switch(action._) {\r\n        case 'messageActionPhoneCall': {\r\n          _ += '.' + (action as any).type;\r\n\r\n          args = [formatCallDuration(action.duration, plain)];\r\n          break;\r\n        }\r\n\r\n        case 'messageActionGroupCall': {\r\n          _ += '.' + (action as any).type;\r\n\r\n          args = [];\r\n          if(!_.endsWith('You') && !message.pFlags.post) {\r\n            args.push(getNameDivHTML(message.fromId, plain));\r\n          }\r\n\r\n          if(action.duration !== undefined) {\r\n            args.push(formatCallDuration(action.duration, plain));\r\n          } else {\r\n            args.push(this.wrapJoinVoiceChatAnchor(message as any));\r\n          }\r\n\r\n          break;\r\n        }\r\n\r\n        case 'messageActionInviteToGroupCall': {\r\n          const peerIds = [message.fromId, action.users[0].toPeerId()];\r\n          let a = 'Chat.Service.VoiceChatInvitation';\r\n          const myId = appUsersManager.getSelf().id;\r\n          if(peerIds[0] === myId) a += 'ByYou';\r\n          else if(peerIds[1] === myId) a += 'ForYou';\r\n          indexOfAndSplice(peerIds, myId);\r\n\r\n          langPackKey = a as LangPackKey;\r\n          args = peerIds.map(peerId => getNameDivHTML(peerId, plain));\r\n          args.push(this.wrapJoinVoiceChatAnchor(message as any));\r\n          break;\r\n        }\r\n\r\n        case 'messageActionGroupCallScheduled': {\r\n          const today = new Date();\r\n          const date = new Date(action.schedule_date * 1000);\r\n          const daysToStart = (date.getTime() - today.getTime()) / 86400e3;\r\n          const tomorrowDate = new Date(today);\r\n          tomorrowDate.setDate(tomorrowDate.getDate() + 1);\r\n\r\n          const isBroadcast = appPeersManager.isBroadcast(message.peerId);\r\n          langPackKey = isBroadcast ? 'ChatList.Service.VoiceChatScheduled.Channel' : 'ChatList.Service.VoiceChatScheduled';\r\n          args = [];\r\n          const myId = appUsersManager.getSelf().id;\r\n          if(message.fromId === myId) {\r\n            langPackKey += 'You';\r\n          } else if(!isBroadcast) {\r\n            args.push(getNameDivHTML(message.fromId, plain));\r\n          }\r\n\r\n          let k: LangPackKey, _args: FormatterArguments = [];\r\n          if(daysToStart < 1 && date.getDate() === today.getDate()) {\r\n            k = 'TodayAtFormattedWithToday';\r\n          } else if(daysToStart < 2 && date.getDate() === tomorrowDate.getDate()) {\r\n            k = 'Time.TomorrowAt';\r\n          } else {\r\n            k = 'formatDateAtTime';\r\n            _args.push(new I18n.IntlDateElement({\r\n              date, \r\n              options: {\r\n                day: '2-digit',\r\n                month: '2-digit',\r\n                year: '2-digit'\r\n              }\r\n            }).element);\r\n          }\r\n\r\n          _args.push(formatTime(date));\r\n          const t = i18n(k, _args);\r\n          args.push(t);\r\n\r\n          break;\r\n        }\r\n\r\n        case 'messageActionChatCreate': {\r\n          const myId = appUsersManager.getSelf().id;\r\n          if(message.fromId === myId) {\r\n            _ += 'You';\r\n          } else {\r\n            args = [getNameDivHTML(message.fromId, plain)];\r\n          }\r\n          \r\n          break;\r\n        }\r\n\r\n        case 'messageActionPinMessage': {\r\n          const peerId = message.peerId;\r\n          const pinnedMessage = this.getMessageByPeer(peerId, message.reply_to_mid);\r\n\r\n          args = [\r\n            getNameDivHTML(message.fromId, plain),\r\n          ];\r\n          \r\n          if(pinnedMessage.deleted/*  || true */) {\r\n            langPackKey = 'ActionPinnedNoText';\r\n\r\n            if(message.reply_to_mid) { // refresh original message\r\n              this.fetchMessageReplyTo(message).then(originalMessage => {\r\n                if(!originalMessage.deleted && !message.deleted) {\r\n                  rootScope.dispatchEvent('message_edit', {\r\n                    storage: this.getMessagesStorage(peerId),\r\n                    peerId: peerId,\r\n                    mid: message.mid\r\n                  });\r\n\r\n                  if(this.isMessageIsTopMessage(message)) {\r\n                    rootScope.dispatchEvent('dialogs_multiupdate', {\r\n                      [peerId]: this.getDialogOnly(peerId)\r\n                    });\r\n                  }\r\n                }\r\n              });\r\n            }\r\n          } else {\r\n            const a = document.createElement('i');\r\n            a.dataset.savedFrom = pinnedMessage.peerId + '_' + pinnedMessage.mid;\r\n            a.dir = 'auto';\r\n            a.append(this.wrapMessageForReply(pinnedMessage, undefined, undefined, plain as any));\r\n            args.push(a);\r\n          }\r\n\r\n          break;\r\n        }\r\n\r\n        case 'messageActionChatJoinedByRequest': {\r\n          const isBroadcast = appPeersManager.isBroadcast(message.peerId);\r\n          if(message.pFlags.out) {\r\n            langPackKey = isBroadcast ? 'RequestToJoinChannelApproved' : 'RequestToJoinGroupApproved';\r\n          } else {\r\n            langPackKey = isBroadcast ? 'ChatService.UserJoinedChannelByRequest' : 'ChatService.UserJoinedGroupByRequest';\r\n            args = [getNameDivHTML(message.fromId, plain)];\r\n          }\r\n          break;\r\n        }\r\n\r\n        case 'messageActionContactSignUp':\r\n        case 'messageActionChatReturn':\r\n        case 'messageActionChatLeave':\r\n        case 'messageActionChatJoined':\r\n        case 'messageActionChatEditPhoto':\r\n        case 'messageActionChatDeletePhoto':\r\n        case 'messageActionChatEditVideo':\r\n        case 'messageActionChatJoinedByLink':\r\n        case 'messageActionChannelEditVideo':\r\n        case 'messageActionChannelDeletePhoto': {\r\n          args = [getNameDivHTML(message.fromId, plain)];\r\n          break;\r\n        }\r\n\r\n        case 'messageActionChannelEditTitle':\r\n        case 'messageActionChatEditTitle': {\r\n          args = [];\r\n          if(action._ === 'messageActionChatEditTitle') {\r\n            args.push(getNameDivHTML(message.fromId, plain));\r\n          }\r\n\r\n          args.push(plain ? action.title : htmlToSpan(RichTextProcessor.wrapEmojiText(action.title)));\r\n          break;\r\n        }\r\n\r\n        case 'messageActionChatDeleteUser':\r\n        case 'messageActionChatAddUsers':\r\n        case 'messageActionChatAddUser': {\r\n          const users = (action as MessageAction.messageActionChatAddUser).users \r\n            || [(action as MessageAction.messageActionChatDeleteUser).user_id];\r\n\r\n          args = [getNameDivHTML(message.fromId, plain)];\r\n\r\n          if(users.length > 1) {\r\n            const joined = join(\r\n              users.map((userId: UserId) => getNameDivHTML(userId.toPeerId(), plain)),\r\n              false,\r\n              plain\r\n            );\r\n            \r\n            if(plain) {\r\n              args.push(...joined);\r\n            } else {\r\n              const fragment = document.createElement('span');\r\n              fragment.append(...joined);\r\n              args.push(fragment);\r\n            }\r\n          } else {\r\n            args.push(getNameDivHTML(users[0].toPeerId(), plain));\r\n          }\r\n\r\n          break;\r\n        }\r\n\r\n        case 'messageActionBotAllowed': {\r\n          const anchorHTML = RichTextProcessor.wrapRichText(action.domain, {\r\n            entities: [{\r\n              _: 'messageEntityUrl',\r\n              length: action.domain.length,\r\n              offset: 0\r\n            }]\r\n          });\r\n\r\n          const node = htmlToSpan(anchorHTML);\r\n\r\n          args = [node];\r\n          break;\r\n        }\r\n\r\n        default:\r\n          langPackKey = (langPack[_] || `[${action._}]`) as any;\r\n          break;\r\n      }\r\n\r\n      if(!langPackKey) {\r\n        langPackKey = langPack[_];\r\n        if(langPackKey === undefined) {\r\n          langPackKey = '[' + _ + ']' as any;\r\n        }\r\n      }\r\n\r\n      if(plain) {\r\n        return I18n.format(langPackKey, true, args);\r\n      } else {\r\n        return _i18n(element, langPackKey, args);\r\n      }\r\n\r\n      //str = !langPackKey || langPackKey[0].toUpperCase() === langPackKey[0] ? langPackKey : getNameDivHTML(message.fromId) + langPackKey + (suffix ? ' ' : '');\r\n    }\r\n  }\r\n\r\n  public wrapMessageActionTextNew(message: MyMessage, plain: true): string;\r\n  public wrapMessageActionTextNew(message: MyMessage, plain?: false): HTMLElement;\r\n  public wrapMessageActionTextNew(message: MyMessage, plain: boolean): HTMLElement | string;\r\n  public wrapMessageActionTextNew(message: MyMessage, plain?: boolean): HTMLElement | string {\r\n    try {\r\n      return this.wrapMessageActionTextNewUnsafe(message, plain);\r\n    } catch(err) {\r\n      this.log.error('wrapMessageActionTextNewUnsafe error:', err);\r\n      return plain ? '' : document.createElement('span');\r\n    }\r\n  }\r\n\r\n  public reportMessages(peerId: PeerId, mids: number[], reason: ReportReason['_'], message?: string) {\r\n    return apiManager.invokeApiSingle('messages.report', {\r\n      peer: appPeersManager.getInputPeerById(peerId),\r\n      id: mids.map(mid => appMessagesIdsManager.getServerMessageId(mid)),\r\n      reason: {\r\n        _: reason\r\n      },\r\n      message\r\n    });\r\n  }\r\n\r\n  public startBot(botId: BotId, chatId?: ChatId, startParam?: string) {\r\n    const peerId = chatId ? chatId.toPeerId(true) : botId.toPeerId();\r\n    if(startParam) {\r\n      const randomId = randomLong();\r\n\r\n      return apiManager.invokeApi('messages.startBot', {\r\n        bot: appUsersManager.getUserInput(botId),\r\n        peer: appPeersManager.getInputPeerById(peerId),\r\n        random_id: randomId,\r\n        start_param: startParam\r\n      }).then((updates) => {\r\n        apiUpdatesManager.processUpdateMessage(updates);\r\n      });\r\n    }\r\n\r\n    const str = '/start';\r\n    if(chatId) {\r\n      let promise: Promise<void>;\r\n      if(appChatsManager.isChannel(chatId)) {\r\n        promise = appChatsManager.inviteToChannel(chatId, [botId]);\r\n      } else {\r\n        promise = appChatsManager.addChatUser(chatId, botId, 0);\r\n      }\r\n\r\n      return promise.catch((error) => {\r\n        if(error && error.type == 'USER_ALREADY_PARTICIPANT') {\r\n          error.handled = true;\r\n          return;\r\n        }\r\n\r\n        throw error;\r\n      }).then(() => {\r\n        const bot = appUsersManager.getUser(botId);\r\n        return this.sendText(peerId, str + '@' + bot.username);\r\n      });\r\n    }\r\n\r\n    return this.sendText(peerId, str);\r\n  }\r\n\r\n  public editPeerFolders(peerIds: PeerId[], folderId: number) {\r\n    apiManager.invokeApi('folders.editPeerFolders', {\r\n      folder_peers: peerIds.map(peerId => {\r\n        return {\r\n          _: 'inputFolderPeer',\r\n          peer: appPeersManager.getInputPeerById(peerId),\r\n          folder_id: folderId\r\n        };\r\n      })\r\n    }).then(updates => {\r\n      //this.log('editPeerFolders updates:', updates);\r\n      apiUpdatesManager.processUpdateMessage(updates); // WARNING! возможно тут нужно добавлять channelId, и вызывать апдейт для каждого канала отдельно\r\n    });\r\n  }\r\n\r\n  public toggleDialogPin(peerId: PeerId, filterId?: number) {\r\n    if(filterId > 1) {\r\n      return this.filtersStorage.toggleDialogPin(peerId, filterId);\r\n    }\r\n\r\n    const dialog = this.getDialogOnly(peerId);\r\n    if(!dialog) return Promise.reject();\r\n\r\n    const pinned = dialog.pFlags?.pinned ? undefined : true;\r\n\r\n    if(pinned) {\r\n      const max = filterId === 1 ? rootScope.config.pinned_infolder_count_max : rootScope.config.pinned_dialogs_count_max;\r\n      if(this.dialogsStorage.getPinnedOrders(filterId).length >= max) {\r\n        return Promise.reject({type: 'PINNED_DIALOGS_TOO_MUCH'});\r\n      }\r\n    }\r\n\r\n    return apiManager.invokeApi('messages.toggleDialogPin', {\r\n      peer: appPeersManager.getInputDialogPeerById(peerId),\r\n      pinned\r\n    }).then(bool => {\r\n      if(bool) {\r\n        const pFlags: Update.updateDialogPinned['pFlags'] = pinned ? {pinned} : {};\r\n        apiUpdatesManager.saveUpdate({\r\n          _: 'updateDialogPinned',\r\n          peer: appPeersManager.getDialogPeer(peerId),\r\n          folder_id: filterId,\r\n          pFlags\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  public markDialogUnread(peerId: PeerId, read?: true) {\r\n    const dialog = this.getDialogOnly(peerId);\r\n    if(!dialog) return Promise.reject();\r\n\r\n    const unread = read || dialog.pFlags?.unread_mark ? undefined : true;\r\n    return apiManager.invokeApi('messages.markDialogUnread', {\r\n      peer: appPeersManager.getInputDialogPeerById(peerId),\r\n      unread\r\n    }).then(bool => {\r\n      if(bool) {\r\n        const pFlags: Update.updateDialogUnreadMark['pFlags'] = unread ? {unread} : {};\r\n        this.onUpdateDialogUnreadMark({\r\n          _: 'updateDialogUnreadMark',\r\n          peer: appPeersManager.getDialogPeer(peerId),\r\n          pFlags\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  public migrateChecks(migrateFrom: PeerId, migrateTo: PeerId) {\r\n    if(!this.migratedFromTo[migrateFrom] &&\r\n      !this.migratedToFrom[migrateTo] &&\r\n      appChatsManager.hasChat(migrateTo.toChatId())) {\r\n      const fromChat = appChatsManager.getChat(migrateFrom.toChatId());\r\n      if(fromChat &&\r\n        fromChat.migrated_to &&\r\n        fromChat.migrated_to.channel_id === migrateTo.toChatId()) {\r\n          this.migratedFromTo[migrateFrom] = migrateTo;\r\n          this.migratedToFrom[migrateTo] = migrateFrom;\r\n\r\n        //setTimeout(() => {\r\n          rootScope.dispatchEvent('dialog_migrate', {migrateFrom, migrateTo});\r\n\r\n          this.dialogsStorage.dropDialogWithEvent(migrateFrom);\r\n        //}, 100);\r\n      }\r\n    }\r\n  }\r\n\r\n  private canMessageBeEdited(message: any, kind: 'text' | 'poll') {\r\n    if(message.pFlags.is_outgoing) {\r\n      return false;\r\n    }\r\n\r\n    const goodMedias = [\r\n      'messageMediaPhoto',\r\n      'messageMediaDocument',\r\n      'messageMediaWebPage'\r\n    ];\r\n\r\n    if(kind === 'poll') {\r\n      goodMedias.push('messageMediaPoll');\r\n    }\r\n\r\n    if(message._ !== 'message' ||\r\n        message.deleted ||\r\n        message.fwd_from ||\r\n        message.via_bot_id ||\r\n        message.media && goodMedias.indexOf(message.media._) === -1 ||\r\n        message.fromId && appUsersManager.isBot(message.fromId)) {\r\n      return false;\r\n    }\r\n    \r\n    if(message.media &&\r\n        message.media._ === 'messageMediaDocument' &&\r\n        (message.media.document.sticker || message.media.document.type === 'round')) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  public canEditMessage(message: Message.message | Message.messageService, kind: 'text' | 'poll' = 'text') {\r\n    if(!message || !this.canMessageBeEdited(message, kind)) {\r\n      return false;\r\n    }\r\n\r\n    // * second rule for saved messages, because there is no 'out' flag\r\n    if(/* message.pFlags.out ||  */this.getMessagePeer(message) === appUsersManager.getSelf().id) {\r\n      return true;\r\n    }\r\n\r\n    if(!message.pFlags.out || (\r\n        message.peer_id._ !== 'peerChannel' &&  \r\n        message.date < (tsNow(true) - rootScope.config.edit_time_limit) && \r\n        (message as Message.message).media?._ !== 'messageMediaPoll'\r\n      )\r\n    ) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  public canDeleteMessage(message: MyMessage) {\r\n    return message && (\r\n      message.peerId.isUser() \r\n      || message.pFlags.out \r\n      || appChatsManager.getChat(message.peerId.toChatId())._ === 'chat' \r\n      || appChatsManager.hasRights(message.peerId.toChatId(), 'delete_messages')\r\n    ) && !message.pFlags.is_outgoing;\r\n  }\r\n\r\n  public getReplyKeyboard(peerId: PeerId) {\r\n    return this.getHistoryStorage(peerId).replyMarkup;\r\n  }\r\n\r\n  public mergeReplyKeyboard(historyStorage: HistoryStorage, message: Message.messageService | Message.message) {\r\n    // this.log('merge', message.mid, message.reply_markup, historyStorage.reply_markup)\r\n    let messageReplyMarkup = (message as Message.message).reply_markup;\r\n    if(!messageReplyMarkup &&\r\n      !message.pFlags?.out &&\r\n      !(message as Message.messageService).action) {\r\n      return false;\r\n    }\r\n\r\n    if(messageReplyMarkup?._ === 'replyInlineMarkup') {\r\n      return false;\r\n    }\r\n\r\n    const lastReplyMarkup = historyStorage.replyMarkup;\r\n    if(messageReplyMarkup) {\r\n      if(lastReplyMarkup && lastReplyMarkup.mid >= message.mid) {\r\n        return false;\r\n      }\r\n\r\n      if(messageReplyMarkup.pFlags.selective) {\r\n        return false;\r\n      }\r\n\r\n      if(historyStorage.maxOutId &&\r\n        message.mid < historyStorage.maxOutId &&\r\n        (messageReplyMarkup as ReplyMarkup.replyKeyboardMarkup | ReplyMarkup.replyKeyboardForceReply).pFlags.single_use) {\r\n        (messageReplyMarkup as ReplyMarkup.replyKeyboardMarkup | ReplyMarkup.replyKeyboardForceReply).pFlags.hidden = true;\r\n      }\r\n\r\n      messageReplyMarkup.mid = message.mid;\r\n      /* messageReplyMarkup = Object.assign({\r\n        mid: message.mid\r\n      }, messageReplyMarkup); */\r\n\r\n      if(messageReplyMarkup._ !== 'replyKeyboardHide') {\r\n        messageReplyMarkup.fromId = appPeersManager.getPeerId(message.from_id);\r\n      }\r\n\r\n      historyStorage.replyMarkup = messageReplyMarkup;\r\n      // this.log('set', historyStorage.reply_markup)\r\n      return true;\r\n    }\r\n\r\n    if(message.pFlags.out) {\r\n      if(lastReplyMarkup) {\r\n        assumeType<ReplyMarkup.replyKeyboardMarkup>(lastReplyMarkup);\r\n        if(lastReplyMarkup.pFlags.single_use &&\r\n          !lastReplyMarkup.pFlags.hidden &&\r\n          (message.mid > lastReplyMarkup.mid || message.pFlags.is_outgoing) &&\r\n          (message as Message.message).message) {\r\n          lastReplyMarkup.pFlags.hidden = true;\r\n          // this.log('set', historyStorage.reply_markup)\r\n          return true;\r\n        }\r\n      } else if(!historyStorage.maxOutId ||\r\n        message.mid > historyStorage.maxOutId) {\r\n        historyStorage.maxOutId = message.mid;\r\n      }\r\n    }\r\n\r\n    assumeType<Message.messageService>(message);\r\n    if(message.action?._ === 'messageActionChatDeleteUser' &&\r\n      (lastReplyMarkup\r\n        ? message.action.user_id === (lastReplyMarkup as ReplyMarkup.replyKeyboardMarkup).fromId\r\n        : appUsersManager.isBot(message.action.user_id)\r\n      )\r\n    ) {\r\n      historyStorage.replyMarkup = {\r\n        _: 'replyKeyboardHide',\r\n        mid: message.mid,\r\n        pFlags: {}\r\n      };\r\n      // this.log('set', historyStorage.reply_markup)\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  public getSearchStorage(peerId: PeerId, inputFilter: MyInputMessagesFilter) {\r\n    if(!this.searchesStorage[peerId]) this.searchesStorage[peerId] = {};\r\n    if(!this.searchesStorage[peerId][inputFilter]) this.searchesStorage[peerId][inputFilter] = {history: []};\r\n    return this.searchesStorage[peerId][inputFilter];\r\n  }\r\n\r\n  public getSearchCounters(peerId: PeerId, filters: MessagesFilter[], canCache = true): Promise<MessagesSearchCounter[]> {\r\n    if(appPeersManager.isRestricted(peerId)) {\r\n      return Promise.resolve(filters.map((filter) => {\r\n        return {\r\n          _: 'messages.searchCounter',\r\n          pFlags: {},\r\n          filter: filter,\r\n          count: 0\r\n        };\r\n      }));\r\n    }\r\n\r\n    const func = (canCache ? apiManager.invokeApiCacheable : apiManager.invokeApi).bind(apiManager);\r\n    return func('messages.getSearchCounters', {\r\n      peer: appPeersManager.getInputPeerById(peerId),\r\n      filters\r\n    });\r\n  }\r\n\r\n  public filterMessagesByInputFilterFromStorage(inputFilter: MyInputMessagesFilter, history: number[], storage: MessagesStorage, limit: number) {\r\n    return this.filterMessagesByInputFilter(inputFilter, history.map(mid => storage.get(mid)), limit);\r\n  }\r\n\r\n  public filterMessagesByInputFilter(inputFilter: MyInputMessagesFilter, history: Array<Message.message | Message.messageService>, limit: number) {\r\n    if(inputFilter === 'inputMessagesFilterEmpty') {\r\n      return history;\r\n    }\r\n\r\n    const foundMsgs: MyMessage[] = [];\r\n    if(!history.length) {\r\n      return foundMsgs;\r\n    }\r\n\r\n    let filtering = true;\r\n    const neededContents: Partial<{\r\n      [messageMediaType in MessageMedia['_']]: boolean\r\n    }> & Partial<{\r\n      avatar: boolean,\r\n      url: boolean\r\n    }> = {},\r\n      neededDocTypes: MyDocument['type'][] = [], \r\n      excludeDocTypes: MyDocument['type'][] = []/* ,\r\n      neededFlags: string[] = [] */;\r\n\r\n    switch(inputFilter) {\r\n      case 'inputMessagesFilterPhotos':\r\n        neededContents['messageMediaPhoto'] = true;\r\n        break;\r\n\r\n      case 'inputMessagesFilterPhotoVideo':\r\n        neededContents['messageMediaPhoto'] = true;\r\n        neededContents['messageMediaDocument'] = true;\r\n        neededDocTypes.push('video');\r\n        break;\r\n\r\n      case 'inputMessagesFilterVideo':\r\n        neededContents['messageMediaDocument'] = true;\r\n        neededDocTypes.push('video');\r\n        break;\r\n\r\n      case 'inputMessagesFilterDocument':\r\n        neededContents['messageMediaDocument'] = true;\r\n        // excludeDocTypes.push('video');\r\n        neededDocTypes.push(undefined, 'photo', 'pdf');\r\n        break;\r\n\r\n      case 'inputMessagesFilterVoice':\r\n        neededContents['messageMediaDocument'] = true;\r\n        neededDocTypes.push('voice');\r\n        break;\r\n\r\n      case 'inputMessagesFilterRoundVoice':\r\n        neededContents['messageMediaDocument'] = true;\r\n        neededDocTypes.push('round', 'voice');\r\n        break;\r\n\r\n      case 'inputMessagesFilterRoundVideo':\r\n        neededContents['messageMediaDocument'] = true;\r\n        neededDocTypes.push('round');\r\n        break;\r\n\r\n      case 'inputMessagesFilterMusic':\r\n        neededContents['messageMediaDocument'] = true;\r\n        neededDocTypes.push('audio');\r\n        break;\r\n\r\n      case 'inputMessagesFilterUrl':\r\n        neededContents['url'] = true;\r\n        break;\r\n\r\n      case 'inputMessagesFilterChatPhotos':\r\n        neededContents['avatar'] = true;\r\n        break;\r\n\r\n      /* case 'inputMessagesFilterPinned':\r\n        neededFlags.push('pinned');\r\n        break; */\r\n\r\n      /* case 'inputMessagesFilterMyMentions':\r\n        neededContents['mentioned'] = true;\r\n        break; */\r\n\r\n      default:\r\n        filtering = false;\r\n        break;\r\n        /* return Promise.resolve({\r\n          count: 0,\r\n          next_rate: 0,\r\n          history: [] as number[]\r\n        }); */\r\n    }\r\n\r\n    if(!filtering) {\r\n      return foundMsgs;\r\n    }\r\n\r\n    for(let i = 0, length = history.length; i < length; ++i) {\r\n      const message: Message.message | Message.messageService = history[i];\r\n      if(!message) continue;\r\n  \r\n      //|| (neededContents['mentioned'] && message.totalEntities.find((e: any) => e._ === 'messageEntityMention'));\r\n  \r\n      let found = false;\r\n      if(message._ === 'message') {\r\n        if(message.media && neededContents[message.media._]/*  && !message.fwd_from */) {\r\n          const doc = (message.media as MessageMedia.messageMediaDocument).document as MyDocument;\r\n          if(doc && \r\n            (\r\n              (neededDocTypes.length && !neededDocTypes.includes(doc.type)) || \r\n              excludeDocTypes.includes(doc.type)\r\n            )\r\n          ) {\r\n            continue;\r\n          }\r\n  \r\n          found = true;\r\n        } else if(neededContents['url'] && message.message) {\r\n          const goodEntities = ['messageEntityTextUrl', 'messageEntityUrl'];\r\n          if((message.totalEntities as MessageEntity[]).find(e => goodEntities.includes(e._)) || RichTextProcessor.matchUrl(message.message)) {\r\n            found = true;\r\n          }\r\n        }\r\n      } else if(neededContents['avatar'] && \r\n        message.action && \r\n        ([\r\n          'messageActionChannelEditPhoto' as const, \r\n          'messageActionChatEditPhoto' as const, \r\n          'messageActionChannelEditVideo' as const, \r\n          'messageActionChatEditVideo' as const\r\n        ] as MessageAction['_'][]).includes(message.action._)) {\r\n        found = true;\r\n      }/*  else if(neededFlags.find(flag => message.pFlags[flag])) {\r\n        found = true;\r\n      } */\r\n  \r\n      if(found) {\r\n        foundMsgs.push(message);\r\n        if(foundMsgs.length >= limit) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    return foundMsgs;\r\n  }\r\n\r\n  public getSearch({peerId, query, inputFilter, maxId, limit, nextRate, backLimit, threadId, folderId, minDate, maxDate}: {\r\n    peerId?: PeerId,\r\n    maxId?: number,\r\n    limit?: number,\r\n    nextRate?: number,\r\n    backLimit?: number,\r\n    threadId?: number,\r\n    folderId?: number,\r\n    query?: string,\r\n    inputFilter?: {\r\n      _: MyInputMessagesFilter\r\n    },\r\n    minDate?: number,\r\n    maxDate?: number\r\n  }): Promise<{\r\n    count: number,\r\n    next_rate: number,\r\n    offset_id_offset: number,\r\n    history: MyMessage[]\r\n  }> {\r\n    if(appPeersManager.isRestricted(peerId)) {\r\n      return Promise.resolve({\r\n        count: 0,\r\n        offset_id_offset: 0,\r\n        next_rate: undefined,\r\n        history: []\r\n      });\r\n    }\r\n\r\n    if(!query) query = '';\r\n    if(!inputFilter) inputFilter = {_: 'inputMessagesFilterEmpty'};\r\n    if(limit === undefined) limit = 20;\r\n    if(!nextRate) nextRate = 0;\r\n    if(!backLimit) backLimit = 0;\r\n\r\n    minDate = minDate ? minDate / 1000 | 0 : 0;\r\n    maxDate = maxDate ? maxDate / 1000 | 0 : 0;\r\n\r\n    let foundMsgs: MyMessage[] = [];\r\n\r\n    //this.log('search', maxId);\r\n\r\n    if(backLimit) {\r\n      limit += backLimit;\r\n    }\r\n\r\n    //const beta = inputFilter._ === 'inputMessagesFilterPinned' && !backLimit;\r\n    const beta = false;\r\n\r\n    let storage: {\r\n      count?: number;\r\n      history: SlicedArray<number>;\r\n    };\r\n\r\n    // * костыль для limit 1, если нужно и получить сообщение, и узнать количество сообщений\r\n    if(peerId && !backLimit && !maxId && !query && limit !== 1 && !threadId/*  && inputFilter._ !== 'inputMessagesFilterPinned' */) {\r\n      storage = beta ? \r\n        this.getSearchStorage(peerId, inputFilter._) as any : \r\n        this.getHistoryStorage(peerId);\r\n      foundMsgs = this.filterMessagesByInputFilterFromStorage(inputFilter._, storage.history.slice, this.getMessagesStorage(peerId), limit);\r\n    }\r\n\r\n    if(foundMsgs.length) {\r\n      if(foundMsgs.length < limit && (beta ? storage.count !== storage.history.length : true)) {\r\n        maxId = foundMsgs[foundMsgs.length - 1].mid;\r\n        limit = limit - foundMsgs.length;\r\n      } else {\r\n        return Promise.resolve({\r\n          count: beta ? storage.count : 0,\r\n          next_rate: 0,\r\n          offset_id_offset: 0,\r\n          history: foundMsgs\r\n        });\r\n      }\r\n    } else if(beta && storage?.count) {\r\n      return Promise.resolve({\r\n        count: storage.count,\r\n        next_rate: 0,\r\n        offset_id_offset: 0,\r\n        history: []\r\n      });\r\n    }\r\n\r\n    const canCache = false && (['inputMessagesFilterChatPhotos', 'inputMessagesFilterPinned'] as MyInputMessagesFilter[]).includes(inputFilter._);\r\n    const method = (canCache ? apiManager.invokeApiCacheable : apiManager.invokeApi).bind(apiManager);\r\n\r\n    let apiPromise: Promise<any>;\r\n    if(peerId && !nextRate && folderId === undefined/*  || !query */) {\r\n      apiPromise = method('messages.search', {\r\n        peer: appPeersManager.getInputPeerById(peerId),\r\n        q: query || '',\r\n        filter: inputFilter as any as MessagesFilter,\r\n        min_date: minDate,\r\n        max_date: maxDate,\r\n        limit,\r\n        offset_id: appMessagesIdsManager.getServerMessageId(maxId) || 0,\r\n        add_offset: backLimit ? -backLimit : 0,\r\n        max_id: 0,\r\n        min_id: 0,\r\n        hash: '',\r\n        top_msg_id: appMessagesIdsManager.getServerMessageId(threadId) || 0\r\n      }, {\r\n        //timeout: APITIMEOUT,\r\n        noErrorBox: true\r\n      });\r\n    } else {\r\n      //var offsetDate = 0;\r\n      let offsetPeerId: PeerId;\r\n      let offsetId = 0;\r\n      let offsetMessage = maxId && this.getMessageByPeer(peerId, maxId);\r\n\r\n      if(offsetMessage && offsetMessage.date) {\r\n        //offsetDate = offsetMessage.date + serverTimeManager.serverTimeOffset;\r\n        offsetId = offsetMessage.id;\r\n        offsetPeerId = this.getMessagePeer(offsetMessage);\r\n      }\r\n\r\n      apiPromise = method('messages.searchGlobal', {\r\n        q: query,\r\n        filter: inputFilter as any as MessagesFilter,\r\n        min_date: minDate,\r\n        max_date: maxDate,\r\n        offset_rate: nextRate,\r\n        offset_peer: appPeersManager.getInputPeerById(offsetPeerId),\r\n        offset_id: offsetId,\r\n        limit,\r\n        folder_id: folderId\r\n      }, {\r\n        //timeout: APITIMEOUT,\r\n        noErrorBox: true\r\n      });\r\n    }\r\n\r\n    return apiPromise.then((searchResult: any) => {\r\n      appUsersManager.saveApiUsers(searchResult.users);\r\n      appChatsManager.saveApiChats(searchResult.chats);\r\n      this.saveMessages(searchResult.messages);\r\n\r\n      /* if(beta && storage && (!maxId || storage.history[storage.history.length - 1] === maxId)) {\r\n        const storage = this.getSearchStorage(peerId, inputFilter._);\r\n        const add = (searchResult.messages.map((m: any) => m.mid) as number[]).filter(mid => storage.history.indexOf(mid) === -1);\r\n        storage.history.push(...add);\r\n        storage.history.sort((a, b) => b - a);\r\n        storage.count = searchResult.count;\r\n      } */\r\n\r\n      if(DEBUG) {\r\n        this.log('getSearch result:', inputFilter, searchResult);\r\n      }\r\n\r\n      const foundCount: number = searchResult.count || (foundMsgs.length + searchResult.messages.length);\r\n\r\n      searchResult.messages.forEach((message: MyMessage) => {\r\n        const peerId = this.getMessagePeer(message);\r\n        if(peerId.isAnyChat()) {\r\n          const chat: Chat.chat = appChatsManager.getChat(peerId.toChatId());\r\n          if(chat.migrated_to) {\r\n            this.migrateChecks(peerId, (chat.migrated_to as InputChannel.inputChannel).channel_id.toPeerId(true));\r\n          }\r\n        }\r\n\r\n        foundMsgs.push(message);\r\n      });\r\n\r\n      return {\r\n        count: foundCount,\r\n        offset_id_offset: searchResult.offset_id_offset || 0,\r\n        next_rate: searchResult.next_rate,\r\n        history: foundMsgs\r\n      };\r\n    });\r\n  }\r\n\r\n  public subscribeRepliesThread(peerId: PeerId, mid: number) {\r\n    const repliesKey = peerId + '_' + mid;\r\n    for(const threadKey in this.threadsToReplies) {\r\n      if(this.threadsToReplies[threadKey] === repliesKey) return;\r\n    }\r\n\r\n    this.getDiscussionMessage(peerId, mid);\r\n  }\r\n\r\n  public generateThreadServiceStartMessage(message: Message.message | Message.messageService) {\r\n    const threadKey = message.peerId + '_' + message.mid;\r\n    if(this.threadsServiceMessagesIdsStorage[threadKey]) return;\r\n\r\n    const maxMessageId = appMessagesIdsManager.getServerMessageId(Math.max(...this.getMidsByMessage(message)));\r\n    const serviceStartMessage: Message.messageService = {\r\n      _: 'messageService',\r\n      pFlags: {\r\n        is_single: true\r\n      },\r\n      id: appMessagesIdsManager.generateMessageId(maxMessageId, true),\r\n      date: message.date,\r\n      from_id: {_: 'peerUser', user_id: NULL_PEER_ID}/* message.from_id */,\r\n      peer_id: message.peer_id,\r\n      action: {\r\n        _: 'messageActionDiscussionStarted'\r\n      },\r\n      reply_to: this.generateReplyHeader(message.id)\r\n    };\r\n\r\n    this.saveMessages([serviceStartMessage], {isOutgoing: true});\r\n    this.threadsServiceMessagesIdsStorage[threadKey] = serviceStartMessage.mid;\r\n  } \r\n\r\n  public getDiscussionMessage(peerId: PeerId, mid: number) {\r\n    return apiManager.invokeApiSingle('messages.getDiscussionMessage', {\r\n      peer: appPeersManager.getInputPeerById(peerId),\r\n      msg_id: appMessagesIdsManager.getServerMessageId(mid)\r\n    }).then(result => {\r\n      appChatsManager.saveApiChats(result.chats);\r\n      appUsersManager.saveApiUsers(result.users);\r\n      this.saveMessages(result.messages);\r\n\r\n      const message = this.filterMessages(result.messages[0] as Message.message, message => !!(message as Message.message).replies)[0] as Message.message;\r\n      const threadKey = message.peerId + '_' + message.mid;\r\n\r\n      this.generateThreadServiceStartMessage(message);\r\n      \r\n      const historyStorage = this.getHistoryStorage(message.peerId, message.mid);\r\n      result.max_id = historyStorage.maxId = appMessagesIdsManager.generateMessageId(result.max_id) || 0;\r\n      result.read_inbox_max_id = historyStorage.readMaxId = appMessagesIdsManager.generateMessageId(result.read_inbox_max_id ?? message.mid);\r\n      result.read_outbox_max_id = historyStorage.readOutboxMaxId = appMessagesIdsManager.generateMessageId(result.read_outbox_max_id) || 0;\r\n\r\n      this.threadsToReplies[threadKey] = peerId + '_' + mid;\r\n\r\n      return message;\r\n    });\r\n  }\r\n\r\n  private handleNewMessage(peerId: PeerId, mid: number) {\r\n    if(this.newMessagesToHandle[peerId] === undefined) {\r\n      this.newMessagesToHandle[peerId] = new Set();\r\n    }\r\n\r\n    this.newMessagesToHandle[peerId].add(mid);\r\n    if(!this.newMessagesHandleTimeout) {\r\n      this.newMessagesHandleTimeout = window.setTimeout(this.handleNewMessages, 0);\r\n    }\r\n  }\r\n\r\n  private handleNewMessages = () => {\r\n    clearTimeout(this.newMessagesHandleTimeout);\r\n    this.newMessagesHandleTimeout = 0;\r\n\r\n    rootScope.dispatchEvent('history_multiappend', this.newMessagesToHandle);\r\n    this.newMessagesToHandle = {};\r\n  };\r\n\r\n  private handleNewDialogs = () => {\r\n    let newMaxSeenId = 0;\r\n    const obj = this.newDialogsToHandle;\r\n    for(const peerId in obj) {\r\n      const dialog = obj[peerId];\r\n      if(!dialog) {\r\n        this.reloadConversation(peerId.toPeerId());\r\n        delete obj[peerId];\r\n      } else {\r\n        this.dialogsStorage.pushDialog(dialog);\r\n        if(!appPeersManager.isChannel(peerId.toPeerId())) {\r\n          newMaxSeenId = Math.max(newMaxSeenId, dialog.top_message || 0);\r\n        }\r\n      }\r\n    }\r\n\r\n    //this.log('after order:', this.dialogsStorage[0].map(d => d.peerId));\r\n\r\n    if(newMaxSeenId !== 0) {\r\n      this.incrementMaxSeenId(newMaxSeenId);\r\n    }\r\n\r\n    rootScope.dispatchEvent('dialogs_multiupdate', obj);\r\n    this.newDialogsToHandle = {};\r\n  };\r\n\r\n  public scheduleHandleNewDialogs(peerId?: PeerId, dialog?: Dialog) {\r\n    if(peerId !== undefined) {\r\n      this.newDialogsToHandle[peerId] = dialog;\r\n    }\r\n\r\n    if(this.newDialogsHandlePromise) return this.newDialogsHandlePromise;\r\n    return this.newDialogsHandlePromise = new Promise<void>((resolve) => {\r\n      setTimeout(() => {\r\n        resolve();\r\n        this.newDialogsHandlePromise = undefined;\r\n        this.handleNewDialogs();\r\n      }, 0);\r\n    });\r\n  }\r\n\r\n  public deleteMessages(peerId: PeerId, mids: number[], revoke?: boolean) {\r\n    let promise: Promise<any>;\r\n\r\n    const localMessageIds = mids.map(mid => appMessagesIdsManager.getServerMessageId(mid));\r\n\r\n    if(peerId.isAnyChat() && appPeersManager.isChannel(peerId)) {\r\n      const channelId = peerId.toChatId();\r\n      const channel: Chat.channel = appChatsManager.getChat(channelId);\r\n      if(!channel.pFlags.creator && !channel.admin_rights?.pFlags?.delete_messages) {\r\n        mids = mids.filter((mid) => {\r\n          const message = this.getMessageByPeer(peerId, mid);\r\n          return !!message.pFlags.out;\r\n        });\r\n\r\n        if(!mids.length) {\r\n          return;\r\n        }\r\n      }\r\n\r\n      promise = apiManager.invokeApi('channels.deleteMessages', {\r\n        channel: appChatsManager.getChannelInput(channelId),\r\n        id: localMessageIds\r\n      }).then((affectedMessages) => {\r\n        apiUpdatesManager.processLocalUpdate({\r\n          _: 'updateDeleteChannelMessages',\r\n          channel_id: channelId,\r\n          messages: mids,\r\n          pts: affectedMessages.pts,\r\n          pts_count: affectedMessages.pts_count\r\n        });\r\n      });\r\n    } else {\r\n      promise = apiManager.invokeApi('messages.deleteMessages', {\r\n        revoke,\r\n        id: localMessageIds\r\n      }).then((affectedMessages) => {\r\n        apiUpdatesManager.processLocalUpdate({\r\n          _: 'updateDeleteMessages',\r\n          messages: mids,\r\n          pts: affectedMessages.pts,\r\n          pts_count: affectedMessages.pts_count\r\n        });\r\n      });\r\n    }\r\n\r\n    return promise;\r\n  }\r\n\r\n  public readHistory(peerId: PeerId, maxId = 0, threadId?: number, force = false) {\r\n    if(DO_NOT_READ_HISTORY) {\r\n      return Promise.resolve();\r\n    }\r\n\r\n    // console.trace('start read')\r\n    this.log('readHistory:', peerId, maxId, threadId);\r\n    if(!this.getReadMaxIdIfUnread(peerId, threadId) && !force) {\r\n      this.log('readHistory: isn\\'t unread');\r\n      return Promise.resolve();\r\n    }\r\n\r\n    const historyStorage = this.getHistoryStorage(peerId, threadId);\r\n\r\n    if(historyStorage.triedToReadMaxId >= maxId) {\r\n      return Promise.resolve();\r\n    }\r\n\r\n    let apiPromise: Promise<any>;\r\n    if(threadId) {\r\n      if(!historyStorage.readPromise) {\r\n        apiPromise = apiManager.invokeApi('messages.readDiscussion', {\r\n          peer: appPeersManager.getInputPeerById(peerId),\r\n          msg_id: appMessagesIdsManager.getServerMessageId(threadId),\r\n          read_max_id: appMessagesIdsManager.getServerMessageId(maxId)\r\n        });\r\n      }\r\n\r\n      apiUpdatesManager.processLocalUpdate({\r\n        _: 'updateReadChannelDiscussionInbox',\r\n        channel_id: peerId.toChatId(),\r\n        top_msg_id: threadId,\r\n        read_max_id: maxId\r\n      });\r\n    } else if(appPeersManager.isChannel(peerId)) {\r\n      if(!historyStorage.readPromise) {\r\n        apiPromise = apiManager.invokeApi('channels.readHistory', {\r\n          channel: appChatsManager.getChannelInput(peerId.toChatId()),\r\n          max_id: appMessagesIdsManager.getServerMessageId(maxId)\r\n        });\r\n      }\r\n\r\n      apiUpdatesManager.processLocalUpdate({\r\n        _: 'updateReadChannelInbox',\r\n        max_id: maxId,\r\n        channel_id: peerId.toChatId(),\r\n        still_unread_count: undefined,\r\n        pts: undefined\r\n      });\r\n    } else {\r\n      if(!historyStorage.readPromise) {\r\n        apiPromise = apiManager.invokeApi('messages.readHistory', {\r\n          peer: appPeersManager.getInputPeerById(peerId),\r\n          max_id: appMessagesIdsManager.getServerMessageId(maxId)\r\n        }).then((affectedMessages) => {\r\n          apiUpdatesManager.processUpdateMessage({\r\n            _: 'updateShort',\r\n            update: {\r\n              _: 'updatePts',\r\n              pts: affectedMessages.pts,\r\n              pts_count: affectedMessages.pts_count\r\n            }\r\n          });\r\n        });\r\n      }\r\n\r\n      apiUpdatesManager.processLocalUpdate({\r\n        _: 'updateReadHistoryInbox',\r\n        max_id: maxId,\r\n        peer: appPeersManager.getOutputPeer(peerId),\r\n        still_unread_count: undefined,\r\n        pts: undefined,\r\n        pts_count: undefined\r\n      });\r\n    }\r\n\r\n    appNotificationsManager.soundReset(appPeersManager.getPeerString(peerId));\r\n\r\n    if(historyStorage.readPromise) {\r\n      return historyStorage.readPromise;\r\n    }\r\n\r\n    historyStorage.triedToReadMaxId = maxId;\r\n\r\n    apiPromise.finally(() => {\r\n      delete historyStorage.readPromise;\r\n\r\n      const {readMaxId} = historyStorage;\r\n      this.log('readHistory: promise finally', maxId, readMaxId);\r\n\r\n      if(readMaxId > maxId) {\r\n        this.readHistory(peerId, readMaxId, threadId, true);\r\n      }\r\n    });\r\n\r\n    return historyStorage.readPromise = apiPromise;\r\n  }\r\n\r\n  public readAllHistory(peerId: PeerId, threadId?: number, force = false) {\r\n    const historyStorage = this.getHistoryStorage(peerId, threadId);\r\n    if(historyStorage.maxId) {\r\n      this.readHistory(peerId, historyStorage.maxId, threadId, force); // lol\r\n    }\r\n  }\r\n\r\n  public fixDialogUnreadMentionsIfNoMessage(peerId: PeerId) {\r\n    const dialog = this.getDialogOnly(peerId);\r\n    if(dialog?.unread_mentions_count) {\r\n      this.reloadConversation(peerId);\r\n    }\r\n  }\r\n\r\n  public modifyCachedMentions(peerId: PeerId, mid: number, add: boolean) {\r\n    const slicedArray = this.unreadMentions[peerId];\r\n    if(!slicedArray) return;\r\n\r\n    if(add) {\r\n      if(slicedArray.first.isEnd(SliceEnd.Top)) {\r\n        slicedArray.insertSlice([mid]);\r\n      }\r\n    } else {\r\n      slicedArray.delete(mid);\r\n    }\r\n  }\r\n\r\n  private fixUnreadMentionsCountIfNeeded(peerId: PeerId, slicedArray: SlicedArray<number>) {\r\n    const dialog = this.getDialogOnly(peerId);\r\n    if(!slicedArray.length && dialog?.unread_mentions_count) {\r\n      this.reloadConversation(peerId);\r\n    }\r\n  }\r\n\r\n  public goToNextMention(peerId: PeerId) {\r\n    /* this.getUnreadMentions(peerId, 1, 2, 0).then(messages => {\r\n      console.log(messages);\r\n    }); */\r\n\r\n    const promise = this.goToNextMentionPromises[peerId];\r\n    if(promise) {\r\n      return promise;\r\n    }\r\n\r\n    const slicedArray = this.unreadMentions[peerId] ?? (this.unreadMentions[peerId] = new SlicedArray());\r\n    const length = slicedArray.length;\r\n    const isTopEnd = slicedArray.first.isEnd(SliceEnd.Top);\r\n    if(!length && isTopEnd) {\r\n      this.fixUnreadMentionsCountIfNeeded(peerId, slicedArray);\r\n      return Promise.resolve();\r\n    }\r\n\r\n    let loadNextPromise = Promise.resolve();\r\n    if(!isTopEnd && length < 25) {\r\n      loadNextPromise = this.loadNextMentions(peerId);\r\n    }\r\n\r\n    return this.goToNextMentionPromises[peerId] = loadNextPromise.then(() => {\r\n      const last = slicedArray.last;\r\n      const mid = last && last[last.length - 1];\r\n      if(mid) {\r\n        slicedArray.delete(mid);\r\n        rootScope.dispatchEvent('history_focus', {peerId, mid});\r\n      } else {\r\n        this.fixUnreadMentionsCountIfNeeded(peerId, slicedArray);\r\n      }\r\n    }).finally(() => {\r\n      delete this.goToNextMentionPromises[peerId];\r\n    });\r\n  }\r\n\r\n  public loadNextMentions(peerId: PeerId) {\r\n    const slicedArray = this.unreadMentions[peerId];\r\n    const maxId = slicedArray.first[0] || 1;\r\n\r\n    const backLimit = 50;\r\n    const add_offset = -backLimit;\r\n    const limit = backLimit;\r\n    return this.getUnreadMentions(peerId, maxId, add_offset, limit).then(messages => {\r\n      this.mergeHistoryResult(slicedArray, messages, maxId === 1 ? 0 : maxId, limit, add_offset);\r\n    });\r\n  }\r\n\r\n  public getUnreadMentions(peerId: PeerId, offsetId: number, add_offset: number, limit: number, maxId = 0, minId = 0) {\r\n    return apiManager.invokeApiSingle('messages.getUnreadMentions', {\r\n      peer: appPeersManager.getInputPeerById(peerId),\r\n      offset_id: appMessagesIdsManager.getServerMessageId(offsetId),\r\n      add_offset,\r\n      limit,\r\n      max_id: appMessagesIdsManager.getServerMessageId(maxId),\r\n      min_id: appMessagesIdsManager.getServerMessageId(minId)\r\n    }).then(messagesMessages => {\r\n      assumeType<Exclude<MessagesMessages, MessagesMessages.messagesMessagesNotModified>>(messagesMessages);\r\n      appUsersManager.saveApiUsers(messagesMessages.users);\r\n      appChatsManager.saveApiChats(messagesMessages.chats);\r\n      this.saveMessages(messagesMessages.messages);\r\n\r\n      return messagesMessages;\r\n    });\r\n  }\r\n\r\n  public readMessages(peerId: PeerId, msgIds: number[]) {\r\n    if(DO_NOT_READ_HISTORY) {\r\n      return Promise.resolve();\r\n    }\r\n\r\n    if(!msgIds.length) {\r\n      return Promise.resolve();\r\n    }\r\n\r\n    msgIds = msgIds.map(mid => appMessagesIdsManager.getServerMessageId(mid));\r\n    let promise: Promise<any>, update: Update.updateChannelReadMessagesContents | Update.updateReadMessagesContents;\r\n    if(peerId.isAnyChat() && appPeersManager.isChannel(peerId)) {\r\n      const channelId = peerId.toChatId();\r\n\r\n      update = {\r\n        _: 'updateChannelReadMessagesContents',\r\n        channel_id: channelId,\r\n        messages: msgIds\r\n      };\r\n\r\n      promise = apiManager.invokeApi('channels.readMessageContents', {\r\n        channel: appChatsManager.getChannelInput(channelId),\r\n        id: msgIds\r\n      });\r\n    } else {\r\n      update = {\r\n        _: 'updateReadMessagesContents',\r\n        messages: msgIds,\r\n        pts: undefined,\r\n        pts_count: undefined\r\n      };\r\n\r\n      promise = apiManager.invokeApi('messages.readMessageContents', {\r\n        id: msgIds\r\n      }).then((affectedMessages) => {\r\n        (update as Update.updateReadMessagesContents).pts = affectedMessages.pts;\r\n        (update as Update.updateReadMessagesContents).pts_count = affectedMessages.pts_count;\r\n        apiUpdatesManager.processLocalUpdate(update);\r\n      });\r\n    }\r\n\r\n    apiUpdatesManager.processLocalUpdate(update);\r\n\r\n    return promise;\r\n  }\r\n\r\n  public getHistoryStorage(peerId: PeerId, threadId?: number) {\r\n    if(threadId) {\r\n      //threadId = this.getLocalMessageId(threadId);\r\n      if(!this.threadsStorage[peerId]) this.threadsStorage[peerId] = {};\r\n      return this.threadsStorage[peerId][threadId] ?? (this.threadsStorage[peerId][threadId] = {count: null, history: new SlicedArray()});\r\n    }\r\n\r\n    return this.historiesStorage[peerId] ?? (this.historiesStorage[peerId] = {count: null, history: new SlicedArray()});\r\n  }\r\n\r\n  private getNotifyPeerSettings(peerId: PeerId) {\r\n    return Promise.all([\r\n      appNotificationsManager.getNotifyPeerTypeSettings(),\r\n      appNotificationsManager.getNotifySettings(appPeersManager.getInputNotifyPeerById(peerId, true))\r\n    ]).then(([_, peerTypeNotifySettings]) => {\r\n      return {\r\n        muted: appNotificationsManager.isPeerLocalMuted(peerId, true),\r\n        peerTypeNotifySettings\r\n      };\r\n    });\r\n  }\r\n\r\n  private handleNotifications = () => {\r\n    window.clearTimeout(this.notificationsHandlePromise);\r\n    this.notificationsHandlePromise = 0;\r\n\r\n    //var timeout = $rootScope.idle.isIDLE && StatusManager.isOtherDeviceActive() ? 30000 : 1000;\r\n    //const timeout = 1000;\r\n\r\n    for(const _peerId in this.notificationsToHandle) {\r\n      const peerId = _peerId.toPeerId();\r\n      if(rootScope.peerId === peerId && !rootScope.idle.isIDLE) {\r\n        continue;\r\n      }\r\n\r\n      const notifyPeerToHandle = this.notificationsToHandle[peerId];\r\n      this.getNotifyPeerSettings(peerId).then(({muted, peerTypeNotifySettings}) => {\r\n        const topMessage = notifyPeerToHandle.topMessage;\r\n        if((muted && !topMessage.pFlags.mentioned) || !topMessage.pFlags.unread) {\r\n          return;\r\n        }\r\n\r\n        //setTimeout(() => {\r\n          if(topMessage.pFlags.unread) {\r\n            this.notifyAboutMessage(topMessage, {\r\n              fwdCount: notifyPeerToHandle.fwdCount,\r\n              peerTypeNotifySettings\r\n            });\r\n          }\r\n        //}, timeout);\r\n      });\r\n    }\r\n\r\n    this.notificationsToHandle = {};\r\n  };\r\n\r\n  private onUpdateMessageId = (update: Update.updateMessageID) => {\r\n    const randomId = update.random_id;\r\n    const pendingData = this.pendingByRandomId[randomId];\r\n    //this.log('AMM updateMessageID:', update, pendingData);\r\n    if(pendingData) {\r\n      const {peerId, tempId, threadId, storage} = pendingData;\r\n      const mid = appMessagesIdsManager.generateMessageId(update.id);\r\n      const message = this.getMessageFromStorage(storage, mid);\r\n      if(!message.deleted) {\r\n        [this.getHistoryStorage(peerId), threadId ? this.getHistoryStorage(peerId, threadId) : undefined]\r\n        .filter(Boolean)\r\n        .forEach(storage => {\r\n          storage.history.delete(tempId);\r\n        });\r\n\r\n        this.finalizePendingMessageCallbacks(storage, tempId, message);\r\n      } else {\r\n        this.pendingByMessageId[mid] = randomId;\r\n      }\r\n    }\r\n  };\r\n\r\n  private onUpdateNewMessage = (update: Update.updateNewDiscussionMessage | Update.updateNewMessage | Update.updateNewChannelMessage) => {\r\n    const message = update.message as MyMessage;\r\n    const peerId = this.getMessagePeer(message);\r\n    const storage = this.getMessagesStorage(peerId);\r\n    const dialog = this.getDialogOnly(peerId);\r\n\r\n    // * local update\r\n    const isLocalThreadUpdate = update._ === 'updateNewDiscussionMessage';\r\n\r\n    // * temporary save the message for info (peerId, reply mids...)\r\n    this.saveMessages([message], {storage: new Map()});\r\n\r\n    const threadKey = this.getThreadKey(message);\r\n    const threadId = threadKey ? +threadKey.split('_')[1] : undefined;\r\n    if(threadId && !isLocalThreadUpdate && this.threadsStorage[peerId] && this.threadsStorage[peerId][threadId]) {\r\n      const update = {\r\n        _: 'updateNewDiscussionMessage',\r\n        message\r\n      } as Update.updateNewDiscussionMessage;\r\n\r\n      this.onUpdateNewMessage(update);\r\n    }\r\n\r\n    if(!dialog && !isLocalThreadUpdate) {\r\n      let good = true;\r\n      if(peerId.isAnyChat()) {\r\n        good = appChatsManager.isInChat(peerId.toChatId());\r\n      }\r\n\r\n      if(good) {\r\n        const set = this.newUpdatesAfterReloadToHandle[peerId] ?? (this.newUpdatesAfterReloadToHandle[peerId] = new Set());\r\n        if(set.has(update)) {\r\n          this.log.error('here we go again', peerId);\r\n          return;\r\n        }\r\n\r\n        (update as any).ignoreExisting = true;\r\n        set.add(update);\r\n        this.scheduleHandleNewDialogs(peerId);\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    /* if(update._ === 'updateNewChannelMessage') {\r\n      const chat = appChatsManager.getChat(peerId.toChatId());\r\n      if(chat.pFlags && (chat.pFlags.left || chat.pFlags.kicked)) {\r\n        return;\r\n      }\r\n    } */\r\n\r\n    this.saveMessages([message], {storage});\r\n    // this.log.warn(dT(), 'message unread', message.mid, message.pFlags.unread)\r\n\r\n    /* if((message as Message.message).grouped_id) {\r\n      this.log('updateNewMessage', message);\r\n    } */\r\n\r\n    const pendingMessage = this.checkPendingMessage(message);\r\n    const historyStorage = this.getHistoryStorage(peerId, isLocalThreadUpdate ? threadId : undefined);\r\n\r\n    if(!isLocalThreadUpdate) {\r\n      this.updateMessageRepliesIfNeeded(message);\r\n    }\r\n\r\n    // * so message can exist if reloadConversation came back earlier with mid\r\n    const ignoreExisting: boolean = (update as any).ignoreExisting;\r\n    const isExisting = !!historyStorage.history.findSlice(message.mid);\r\n    if(isExisting) {\r\n      if(!ignoreExisting) {\r\n        return false;\r\n      }\r\n    } else {\r\n      // * catch situation with disconnect. if message's id is lower than we already have (in bottom end slice), will sort it\r\n      const firstSlice = historyStorage.history.first;\r\n      if(firstSlice.isEnd(SliceEnd.Bottom)) {\r\n        let i = 0;\r\n        for(const length = firstSlice.length; i < length; ++i) {\r\n          if(message.mid > firstSlice[i]) {\r\n            break;\r\n          }\r\n        }\r\n\r\n        firstSlice.splice(i, 0, message.mid);\r\n      } else {\r\n        historyStorage.history.unshift(message.mid);\r\n      }\r\n\r\n      if(historyStorage.count !== null) {\r\n        historyStorage.count++;\r\n      }\r\n    }\r\n\r\n    if(this.mergeReplyKeyboard(historyStorage, message)) {\r\n      rootScope.dispatchEvent('history_reply_markup', {peerId});\r\n    }\r\n\r\n    const fromId = message.fromId;\r\n    if(fromId.isUser() && !message.pFlags.out && message.from_id) {\r\n      appUsersManager.forceUserOnline(fromId, message.date);\r\n\r\n      const action: SendMessageAction = {\r\n        _: 'sendMessageCancelAction'\r\n      };\r\n\r\n      let update: Update.updateUserTyping | Update.updateChatUserTyping | Update.updateChannelUserTyping;\r\n      if(peerId.isUser()) {\r\n        update = {\r\n          _: 'updateUserTyping',\r\n          action,\r\n          user_id: fromId\r\n        };\r\n      } else if(appPeersManager.isChannel(peerId)) {\r\n        update = {\r\n          _: 'updateChannelUserTyping',\r\n          action,\r\n          channel_id: peerId.toChatId(),\r\n          from_id: appPeersManager.getOutputPeer(fromId),\r\n          top_msg_id: threadId ? appMessagesIdsManager.getServerMessageId(threadId) : undefined\r\n        };\r\n      } else {\r\n        update = {\r\n          _: 'updateChatUserTyping',\r\n          action,\r\n          chat_id: peerId.toChatId(),\r\n          from_id: appPeersManager.getOutputPeer(fromId)\r\n        };\r\n      }\r\n\r\n      apiUpdatesManager.processLocalUpdate(update);\r\n    }\r\n\r\n    if(!pendingMessage) {\r\n      this.handleNewMessage(peerId, message.mid);\r\n    }\r\n\r\n    if(isLocalThreadUpdate) {\r\n      return;\r\n    }\r\n    \r\n    const inboxUnread = !message.pFlags.out && message.pFlags.unread;\r\n    if(dialog) {\r\n      if(inboxUnread && message.mid > dialog.top_message) {\r\n        const releaseUnreadCount = this.dialogsStorage.prepareDialogUnreadCountModifying(dialog);\r\n\r\n        ++dialog.unread_count;\r\n        if(message.pFlags.mentioned) {\r\n          ++dialog.unread_mentions_count;\r\n          this.modifyCachedMentions(peerId, message.mid, true);\r\n        }\r\n\r\n        releaseUnreadCount();\r\n      }\r\n\r\n      if(message.mid >= dialog.top_message) {\r\n        this.setDialogTopMessage(message, dialog);\r\n      }\r\n    }\r\n\r\n    if(inboxUnread/*  && ($rootScope.selectedPeerID != peerID || $rootScope.idle.isIDLE) */) {\r\n      const notifyPeer = peerId;\r\n      let notifyPeerToHandle = this.notificationsToHandle[notifyPeer];\r\n      if(notifyPeerToHandle === undefined) {\r\n        notifyPeerToHandle = this.notificationsToHandle[notifyPeer] = {\r\n          fwdCount: 0,\r\n          fromId: NULL_PEER_ID\r\n        };\r\n      }\r\n\r\n      if(notifyPeerToHandle.fromId !== fromId) {\r\n        notifyPeerToHandle.fromId = fromId;\r\n        notifyPeerToHandle.fwdCount = 0;\r\n      }\r\n\r\n      if((message as Message.message).fwd_from) {\r\n        ++notifyPeerToHandle.fwdCount;\r\n      }\r\n\r\n      notifyPeerToHandle.topMessage = message;\r\n\r\n      if(!this.notificationsHandlePromise) {\r\n        this.notificationsHandlePromise = window.setTimeout(this.handleNotifications, 0);\r\n      }\r\n    }\r\n  };\r\n\r\n  private onUpdateMessageReactions = (update: Update.updateMessageReactions) => {\r\n    const {peer, msg_id, reactions} = update;\r\n    const mid = appMessagesIdsManager.generateMessageId(msg_id);\r\n    const peerId = appPeersManager.getPeerId(peer);\r\n    const message: MyMessage = this.getMessageByPeer(peerId, mid);\r\n\r\n    if(message._ !== 'message') {\r\n      return;\r\n    }\r\n\r\n    const recentReactions = reactions?.recent_reactions;\r\n    if(recentReactions?.length && message.pFlags.out) {\r\n      const recentReaction = recentReactions[recentReactions.length - 1];\r\n      const previousReactions = message.reactions;\r\n      const previousRecentReactions = previousReactions?.recent_reactions;\r\n      if(\r\n        appPeersManager.getPeerId(recentReaction.peer_id) !== rootScope.myId && (\r\n          !previousRecentReactions ||\r\n          previousRecentReactions.length <= recentReactions.length\r\n        ) && (\r\n          !previousRecentReactions || \r\n          !deepEqual(recentReaction, previousRecentReactions[previousRecentReactions.length - 1])\r\n        )\r\n      ) {\r\n        this.getNotifyPeerSettings(peerId).then(({muted, peerTypeNotifySettings}) => {\r\n          if(/* muted ||  */!peerTypeNotifySettings.show_previews) return;\r\n          this.notifyAboutMessage(message, {\r\n            peerReaction: recentReaction,\r\n            peerTypeNotifySettings\r\n          });\r\n        });\r\n      }\r\n    }\r\n    \r\n    const key = message.peerId + '_' + message.mid;\r\n    this.pushBatchUpdate('messages_reactions', this.batchUpdateReactions, key, () => copy(message.reactions));\r\n\r\n    message.reactions = reactions;\r\n\r\n    if(!update.local) {\r\n      this.setDialogToStateIfMessageIsTop(message);\r\n    }\r\n  };\r\n\r\n  private onUpdateDialogUnreadMark = (update: Update.updateDialogUnreadMark) => {\r\n    //this.log('updateDialogUnreadMark', update);\r\n    const peerId = appPeersManager.getPeerId((update.peer as DialogPeer.dialogPeer).peer);\r\n    const dialog = this.getDialogOnly(peerId);\r\n\r\n    if(!dialog) {\r\n      this.scheduleHandleNewDialogs(peerId);\r\n    } else {\r\n      const releaseUnreadCount = this.dialogsStorage.prepareDialogUnreadCountModifying(dialog);\r\n\r\n      if(!update.pFlags.unread) {\r\n        delete dialog.pFlags.unread_mark;\r\n      } else {\r\n        dialog.pFlags.unread_mark = true;\r\n      }\r\n\r\n      releaseUnreadCount();\r\n      rootScope.dispatchEvent('dialogs_multiupdate', {[peerId]: dialog});\r\n      this.dialogsStorage.setDialogToState(dialog);\r\n    }\r\n  };\r\n\r\n  private onUpdateEditMessage = (update: Update.updateEditMessage | Update.updateEditChannelMessage) => {\r\n    const message = update.message as MyMessage;\r\n    const peerId = this.getMessagePeer(message);\r\n    const mid = appMessagesIdsManager.generateMessageId(message.id);\r\n    const storage = this.getMessagesStorage(peerId);\r\n    if(!storage.has(mid)) {\r\n      // this.fixDialogUnreadMentionsIfNoMessage(peerId);\r\n      return;\r\n    }\r\n\r\n    // console.trace(dT(), 'edit message', message)\r\n    \r\n    const oldMessage: Message = this.getMessageFromStorage(storage, mid);\r\n    this.saveMessages([message], {storage});\r\n    const newMessage: Message = this.getMessageFromStorage(storage, mid);\r\n\r\n    this.handleEditedMessage(oldMessage, newMessage);\r\n\r\n    const dialog = this.getDialogOnly(peerId);\r\n\r\n    // if sender erased mention\r\n    /* if(dialog.unread_mentions_count && (oldMessage as Message.message)?.pFlags?.mentioned && !message.pFlags.mentioned) {\r\n      --dialog.unread_mentions_count;\r\n      this.modifyCachedMentions(peerId, mid, false);\r\n    } */\r\n\r\n    const isTopMessage = dialog && dialog.top_message === mid;\r\n    if((message as Message.messageService).clear_history) {\r\n      if(isTopMessage) {\r\n        rootScope.dispatchEvent('dialog_flush', {peerId});\r\n      }\r\n    } else {\r\n      // no sense in dispatching message_edit since only reactions have changed\r\n      if(oldMessage?._ === 'message' && !deepEqual(oldMessage.reactions, (newMessage as Message.message).reactions)) {\r\n        const newReactions = (newMessage as Message.message).reactions;\r\n        (newMessage as Message.message).reactions = oldMessage.reactions;\r\n        apiUpdatesManager.processLocalUpdate({\r\n          _: 'updateMessageReactions',\r\n          peer: appPeersManager.getOutputPeer(peerId),\r\n          msg_id: message.id,\r\n          reactions: newReactions\r\n        });\r\n\r\n        return;\r\n      }\r\n\r\n      rootScope.dispatchEvent('message_edit', {\r\n        storage,\r\n        peerId,\r\n        mid\r\n      });\r\n\r\n      if(isTopMessage || (message as Message.message).grouped_id) {\r\n        const updatedDialogs: {[peerId: PeerId]: Dialog} = {};\r\n        updatedDialogs[peerId] = dialog;\r\n        rootScope.dispatchEvent('dialogs_multiupdate', updatedDialogs);\r\n        this.dialogsStorage.setDialogToState(dialog);\r\n      }\r\n    }\r\n  };\r\n\r\n  private onUpdateReadHistory = (update: Update.updateReadChannelDiscussionInbox | Update.updateReadChannelDiscussionOutbox \r\n    | Update.updateReadHistoryInbox | Update.updateReadHistoryOutbox \r\n    | Update.updateReadChannelInbox | Update.updateReadChannelOutbox) => {\r\n    const channelId = (update as Update.updateReadChannelInbox).channel_id;\r\n    const maxId = appMessagesIdsManager.generateMessageId((update as Update.updateReadChannelInbox).max_id || (update as Update.updateReadChannelDiscussionInbox).read_max_id);\r\n    const threadId = appMessagesIdsManager.generateMessageId((update as Update.updateReadChannelDiscussionInbox).top_msg_id);\r\n    const peerId = channelId ? channelId.toPeerId(true) : appPeersManager.getPeerId((update as Update.updateReadHistoryInbox).peer);\r\n\r\n    const isOut = update._ === 'updateReadHistoryOutbox' || update._ === 'updateReadChannelOutbox' || update._ === 'updateReadChannelDiscussionOutbox' ? true : undefined;\r\n\r\n    const storage = this.getMessagesStorage(peerId);\r\n    const history = getObjectKeysAndSort(storage, 'desc');\r\n    const foundDialog = this.getDialogOnly(peerId);\r\n    const stillUnreadCount = (update as Update.updateReadChannelInbox).still_unread_count;\r\n    let newUnreadCount = 0;\r\n    let newUnreadMentionsCount = 0;\r\n    let foundAffected = false;\r\n\r\n    //this.log.warn(dT(), 'read', peerId, isOut ? 'out' : 'in', maxId)\r\n\r\n    const historyStorage = this.getHistoryStorage(peerId, threadId);\r\n\r\n    if(peerId.isUser() && isOut) {\r\n      appUsersManager.forceUserOnline(peerId);\r\n    }\r\n\r\n    if(threadId) {\r\n      const repliesKey = this.threadsToReplies[peerId + '_' + threadId];\r\n      if(repliesKey) {\r\n        const [peerId, mid] = repliesKey.split('_');\r\n        this.updateMessage(peerId.toPeerId(), +mid, 'replies_updated');\r\n      }\r\n    }\r\n\r\n    const releaseUnreadCount = !threadId && foundDialog && this.dialogsStorage.prepareDialogUnreadCountModifying(foundDialog);\r\n\r\n    for(let i = 0, length = history.length; i < length; i++) {\r\n      const mid = history[i];\r\n      if(mid > maxId) {\r\n        continue;\r\n      }\r\n      \r\n      const message: MyMessage = storage.get(mid);\r\n\r\n      if(message.pFlags.out !== isOut) {\r\n        continue;\r\n      }\r\n\r\n      if(!message.pFlags.unread) {\r\n        break;\r\n      }\r\n\r\n      if(threadId) {\r\n        const replyTo = message.reply_to;\r\n        if(!replyTo || (replyTo.reply_to_top_id || replyTo.reply_to_msg_id) !== threadId) {\r\n          continue;\r\n        }\r\n      }\r\n      \r\n      // this.log.warn('read', messageId, message.pFlags.unread, message)\r\n      if(message.pFlags.unread) {\r\n        delete message.pFlags.unread;\r\n        if(!foundAffected) {\r\n          foundAffected = true;\r\n        }\r\n\r\n        if(!message.pFlags.out && !threadId && foundDialog) {\r\n          if(stillUnreadCount === undefined) {\r\n            newUnreadCount = --foundDialog.unread_count;\r\n          }\r\n\r\n          if(message.pFlags.mentioned) {\r\n            newUnreadMentionsCount = --foundDialog.unread_mentions_count;\r\n            this.modifyCachedMentions(peerId, message.mid, false);\r\n          }\r\n        }\r\n        \r\n        appNotificationsManager.cancel('msg' + mid);\r\n      }\r\n    }\r\n\r\n    if(isOut) historyStorage.readOutboxMaxId = maxId;\r\n    else historyStorage.readMaxId = maxId;\r\n\r\n    if(!threadId && foundDialog) {\r\n      if(isOut) foundDialog.read_outbox_max_id = maxId;\r\n      else foundDialog.read_inbox_max_id = maxId;\r\n\r\n      if(!isOut) {\r\n        let setCount: number;\r\n        if(stillUnreadCount !== undefined) {\r\n          setCount = stillUnreadCount;\r\n        } else if(newUnreadCount < 0 || !this.getReadMaxIdIfUnread(peerId)) {\r\n          setCount = 0;\r\n        } else if(newUnreadCount && foundDialog.top_message > maxId) {\r\n          setCount = newUnreadCount;\r\n        }\r\n\r\n        if(setCount !== undefined) {\r\n          foundDialog.unread_count = setCount;\r\n        }\r\n\r\n        if(newUnreadMentionsCount < 0 || !foundDialog.unread_count) {\r\n          foundDialog.unread_mentions_count = 0;\r\n        }\r\n      }\r\n\r\n      if(releaseUnreadCount) {\r\n        releaseUnreadCount();\r\n      }\r\n\r\n      this.dialogsStorage.processDialogForFilters(foundDialog);\r\n      \r\n      rootScope.dispatchEvent('dialog_unread', {peerId});\r\n      this.dialogsStorage.setDialogToState(foundDialog);\r\n    }\r\n\r\n    if(foundAffected) {\r\n      rootScope.dispatchEvent('messages_read');\r\n    }\r\n\r\n    if(!threadId && channelId) {\r\n      const threadKeyPart = peerId + '_';\r\n      for(const threadKey in this.threadsToReplies) {\r\n        if(threadKey.indexOf(threadKeyPart) === 0) {\r\n          const [peerId, mid] = this.threadsToReplies[threadKey].split('_');\r\n          rootScope.dispatchEvent('replies_updated', this.getMessageByPeer(peerId.toPeerId(), +mid));\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  private onUpdateReadMessagesContents = (update: Update.updateChannelReadMessagesContents | Update.updateReadMessagesContents) => {\r\n    const channelId = (update as Update.updateChannelReadMessagesContents).channel_id;\r\n    const mids = (update as Update.updateReadMessagesContents).messages.map(id => appMessagesIdsManager.generateMessageId(id));\r\n    const peerId = channelId ? channelId.toPeerId(true) : this.getMessageById(mids[0]).peerId;\r\n    for(let i = 0, length = mids.length; i < length; ++i) {\r\n      const mid = mids[i];\r\n      const message: MyMessage = this.getMessageByPeer(peerId, mid);\r\n      if(!message.deleted) {\r\n        if(message.pFlags.media_unread) {\r\n          delete message.pFlags.media_unread;\r\n          this.setDialogToStateIfMessageIsTop(message);\r\n  \r\n          if(!message.pFlags.out && message.pFlags.mentioned) {\r\n            this.modifyCachedMentions(peerId, mid, false);\r\n          }\r\n        }\r\n      } else {\r\n        this.fixDialogUnreadMentionsIfNoMessage(peerId);\r\n      }\r\n    }\r\n\r\n    rootScope.dispatchEvent('messages_media_read', {peerId, mids});\r\n  };\r\n\r\n  private onUpdateChannelAvailableMessages = (update: Update.updateChannelAvailableMessages) => {\r\n    const peerId = update.channel_id.toPeerId(true);\r\n    const history = this.getHistoryStorage(peerId).history.slice;\r\n    const availableMinId = appMessagesIdsManager.generateMessageId(update.available_min_id);\r\n    const messages = history.filter(mid => mid <= availableMinId);\r\n\r\n    (update as any as Update.updateDeleteChannelMessages).messages = messages;\r\n    this.onUpdateDeleteMessages(update as any as Update.updateDeleteChannelMessages);\r\n  };\r\n\r\n  private onUpdateDeleteMessages = (update: Update.updateDeleteMessages | Update.updateDeleteChannelMessages) => {\r\n    const channelId = (update as Update.updateDeleteChannelMessages).channel_id;\r\n    //const messages = (update as any as Update.updateDeleteChannelMessages).messages;\r\n    const messages = (update as any as Update.updateDeleteChannelMessages).messages.map(id => appMessagesIdsManager.generateMessageId(id));\r\n    const peerId: PeerId = channelId ? channelId.toPeerId(true) : this.getMessageById(messages[0]).peerId;\r\n    \r\n    if(!peerId) {\r\n      return;\r\n    }\r\n\r\n    apiManager.clearCache('messages.getSearchCounters', (params) => {\r\n      return appPeersManager.getPeerId(params.peer) === peerId;\r\n    });\r\n\r\n    const threadKeys: Set<string> = new Set();\r\n    for(const mid of messages) {\r\n      const message = this.getMessageByPeer(peerId, mid);\r\n      const threadKey = this.getThreadKey(message);\r\n      if(threadKey && this.threadsStorage[peerId] && this.threadsStorage[peerId][+threadKey.split('_')[1]]) {\r\n        threadKeys.add(threadKey);\r\n      }\r\n    }\r\n    \r\n    const historyUpdated = this.handleDeletedMessages(peerId, this.getMessagesStorage(peerId), messages);\r\n\r\n    const threadsStorages = Array.from(threadKeys).map(threadKey => {\r\n      const [peerId, mid] = threadKey.split('_');\r\n      return this.getHistoryStorage(peerId.toPeerId(), +mid);\r\n    });\r\n\r\n    const historyStorage = this.getHistoryStorage(peerId);\r\n    [historyStorage].concat(threadsStorages).forEach(historyStorage => {\r\n      for(const mid of historyUpdated.msgs) {\r\n        historyStorage.history.delete(mid);\r\n      }\r\n      \r\n      if(historyUpdated.count && historyStorage.count) {\r\n        historyStorage.count = Math.max(0, historyStorage.count - historyUpdated.count);\r\n      }\r\n    });\r\n\r\n    rootScope.dispatchEvent('history_delete', {peerId, msgs: historyUpdated.msgs});\r\n\r\n    const foundDialog = this.getDialogOnly(peerId);\r\n    if(foundDialog) {\r\n      const affected = historyUpdated.unreadMentions || historyUpdated.unread;\r\n      const releaseUnreadCount = affected && this.dialogsStorage.prepareDialogUnreadCountModifying(foundDialog);\r\n      \r\n      if(historyUpdated.unread) {\r\n        foundDialog.unread_count = Math.max(0, foundDialog.unread_count - historyUpdated.unread);\r\n      }\r\n\r\n      if(historyUpdated.unreadMentions) {\r\n        foundDialog.unread_mentions_count = !foundDialog.unread_count ? 0 : Math.max(0, foundDialog.unread_mentions_count - historyUpdated.unreadMentions);\r\n      }\r\n\r\n      if(affected) {\r\n        releaseUnreadCount();\r\n        rootScope.dispatchEvent('dialog_unread', {peerId});\r\n      }\r\n\r\n      if(historyUpdated.msgs.has(foundDialog.top_message)) {\r\n        const slice = historyStorage.history.first;\r\n        if(slice.isEnd(SliceEnd.Bottom) && slice.length) {\r\n          const mid = slice[0];\r\n          const message = this.getMessageByPeer(peerId, mid);\r\n          this.setDialogTopMessage(message, foundDialog);\r\n        } else {\r\n          this.reloadConversation(peerId);\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  private onUpdateChannel = (update: Update.updateChannel) => {\r\n    const channelId = update.channel_id;\r\n    const peerId = channelId.toPeerId(true);\r\n    const channel: Chat.channel = appChatsManager.getChat(channelId);\r\n\r\n    const needDialog = appChatsManager.isInChat(channelId);\r\n    \r\n    const canViewHistory = !!channel.username || !channel.pFlags.left;\r\n    const hasHistory = this.historiesStorage[peerId] !== undefined;\r\n    \r\n    if(canViewHistory !== hasHistory) {\r\n      delete this.historiesStorage[peerId];\r\n      rootScope.dispatchEvent('history_forbidden', peerId);\r\n    }\r\n    \r\n    const dialog = this.getDialogOnly(peerId);\r\n    if(!!dialog !== needDialog) {\r\n      if(needDialog) {\r\n        this.reloadConversation(peerId);\r\n      } else {\r\n        this.dialogsStorage.dropDialogOnDeletion(peerId);\r\n      }\r\n    }\r\n\r\n    rootScope.dispatchEvent('channel_update', channelId);\r\n  };\r\n\r\n  private onUpdateChannelReload = (update: Update.updateChannelReload) => {\r\n    const peerId = update.channel_id.toPeerId(true);\r\n\r\n    this.dialogsStorage.dropDialog(peerId);\r\n\r\n    delete this.historiesStorage[peerId];\r\n    this.reloadConversation(peerId).then(() => {\r\n      rootScope.dispatchEvent('history_reload', peerId);\r\n    });\r\n  };\r\n  \r\n  private onUpdateChannelMessageViews = (update: Update.updateChannelMessageViews) => {\r\n    const views = update.views;\r\n    const peerId = update.channel_id.toPeerId(true);\r\n    const mid = appMessagesIdsManager.generateMessageId(update.id);\r\n    const message: Message.message = this.getMessageByPeer(peerId, mid);\r\n    if(!message.deleted && message.views !== undefined && message.views < views) {\r\n      message.views = views;\r\n      this.pushBatchUpdate('messages_views', this.batchUpdateViews, message.peerId + '_' + message.mid);\r\n      this.setDialogToStateIfMessageIsTop(message);\r\n    }\r\n  };\r\n\r\n  private onUpdateServiceNotification = (update: Update.updateServiceNotification) => {\r\n    //this.log('updateServiceNotification', update);\r\n    if(update.pFlags?.popup) {\r\n      rootScope.dispatchEvent('service_notification', update);\r\n      return;\r\n    }\r\n    \r\n    const fromId = SERVICE_PEER_ID;\r\n    const peerId = fromId;\r\n    const messageId = this.generateTempMessageId(peerId);\r\n    const message: Message.message = {\r\n      _: 'message',\r\n      id: messageId,\r\n      from_id: appPeersManager.getOutputPeer(fromId),\r\n      peer_id: appPeersManager.getOutputPeer(peerId),\r\n      pFlags: {unread: true},\r\n      date: (update.inbox_date || tsNow(true)) + serverTimeManager.serverTimeOffset,\r\n      message: update.message,\r\n      media: update.media,\r\n      entities: update.entities\r\n    };\r\n    if(!appUsersManager.hasUser(fromId)) {\r\n      appUsersManager.saveApiUsers([{\r\n        _: 'user',\r\n        id: fromId,\r\n        pFlags: {verified: true},\r\n        access_hash: '0',\r\n        first_name: 'Telegram',\r\n        phone: '42777'\r\n      }]);\r\n    }\r\n    this.saveMessages([message], {isOutgoing: true});\r\n\r\n    if(update.inbox_date) {\r\n      this.pendingTopMsgs[peerId] = messageId;\r\n      this.onUpdateNewMessage({\r\n        _: 'updateNewMessage',\r\n        message,\r\n        pts: undefined,\r\n        pts_count: undefined\r\n      });\r\n    }\r\n  };\r\n\r\n  private onUpdatePinnedMessages = (update: Update.updatePinnedMessages | Update.updatePinnedChannelMessages) => {\r\n    const channelId = update._ === 'updatePinnedChannelMessages' ? update.channel_id : undefined;\r\n    const peerId = channelId ? channelId.toPeerId(true) : appPeersManager.getPeerId((update as Update.updatePinnedMessages).peer);\r\n\r\n    /* const storage = this.getSearchStorage(peerId, 'inputMessagesFilterPinned');\r\n    if(storage.count !== storage.history.length) {\r\n      if(storage.count !== undefined) {\r\n        delete this.searchesStorage[peerId]['inputMessagesFilterPinned'];  \r\n      }\r\n\r\n      rootScope.broadcast('peer_pinned_messages', peerId);\r\n      break;\r\n    } */\r\n\r\n    const messages = update.messages.map(id => appMessagesIdsManager.generateMessageId(id)); \r\n\r\n    const storage = this.getMessagesStorage(peerId);\r\n    const missingMessages = messages.filter(mid => !storage.has(mid));\r\n    const getMissingPromise = missingMessages.length ? Promise.all(missingMessages.map(mid => this.wrapSingleMessage(peerId, mid))) : Promise.resolve();\r\n    getMissingPromise.finally(() => {\r\n      const werePinned = update.pFlags?.pinned;\r\n      if(werePinned) {\r\n        for(const mid of messages) {\r\n          //storage.history.push(mid);\r\n          const message = storage.get(mid);\r\n          message.pFlags.pinned = true;\r\n        }\r\n\r\n        /* if(this.pinnedMessages[peerId]?.maxId) {\r\n          const maxMid = Math.max(...messages);\r\n          this.pinnedMessages\r\n        } */\r\n\r\n        //storage.history.sort((a, b) => b - a);\r\n      } else {\r\n        for(const mid of messages) {\r\n          //storage.history.findAndSplice(_mid => _mid === mid);\r\n          const message = storage.get(mid);\r\n          delete message.pFlags.pinned;\r\n        }\r\n      }\r\n\r\n      /* const info = this.pinnedMessages[peerId];\r\n      if(info) {\r\n        info.count += messages.length * (werePinned ? 1 : -1);\r\n      } */\r\n  \r\n      delete this.pinnedMessages[peerId];\r\n      appStateManager.getState().then(state => {\r\n        delete state.hiddenPinnedMessages[peerId];\r\n        rootScope.dispatchEvent('peer_pinned_messages', {peerId, mids: messages, pinned: werePinned});\r\n      });\r\n    });\r\n  };\r\n\r\n  private onUpdateNotifySettings = (update: Update.updateNotifySettings) => {\r\n    const {peer, notify_settings} = update;\r\n    if(peer._ === 'notifyPeer') {\r\n      const peerId = appPeersManager.getPeerId((peer as NotifyPeer.notifyPeer).peer);\r\n    \r\n      const dialog = this.getDialogOnly(peerId);\r\n      if(dialog) {\r\n        dialog.notify_settings = notify_settings;\r\n        rootScope.dispatchEvent('dialog_notify_settings', dialog);\r\n        this.dialogsStorage.setDialogToState(dialog);\r\n      }\r\n    }\r\n  };\r\n\r\n  private onUpdateNewScheduledMessage = (update: Update.updateNewScheduledMessage) => {\r\n    const message = update.message as MyMessage;\r\n    const peerId = this.getMessagePeer(message);\r\n\r\n    const storage = this.scheduledMessagesStorage[peerId];\r\n    if(storage) {\r\n      const mid = appMessagesIdsManager.generateMessageId(message.id);\r\n\r\n      const oldMessage = this.getMessageFromStorage(storage, mid);\r\n      this.saveMessages([message], {storage, isScheduled: true});\r\n      const newMessage = this.getMessageFromStorage(storage, mid);\r\n\r\n      if(!oldMessage.deleted) {\r\n        this.handleEditedMessage(oldMessage, newMessage);\r\n        rootScope.dispatchEvent('message_edit', {storage, peerId, mid: message.mid});\r\n      } else {\r\n        const pendingMessage = this.checkPendingMessage(message);\r\n        if(!pendingMessage) {\r\n          rootScope.dispatchEvent('scheduled_new', {peerId, mid: message.mid});\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  private onUpdateDeleteScheduledMessages = (update: Update.updateDeleteScheduledMessages) => {\r\n    const peerId = appPeersManager.getPeerId(update.peer);\r\n\r\n    const storage = this.scheduledMessagesStorage[peerId];\r\n    if(storage) {\r\n      const mids = update.messages.map(id => appMessagesIdsManager.generateMessageId(id));\r\n      this.handleDeletedMessages(peerId, storage, mids);\r\n\r\n      rootScope.dispatchEvent('scheduled_delete', {peerId, mids});\r\n    }\r\n  };\r\n\r\n  public setDialogToStateIfMessageIsTop(message: MyMessage) {\r\n    if(this.isMessageIsTopMessage(message)) {\r\n      this.dialogsStorage.setDialogToState(this.getDialogOnly(message.peerId));\r\n    }\r\n  }\r\n\r\n  public isMessageIsTopMessage(message: MyMessage) {\r\n    const dialog = this.getDialogOnly(message.peerId);\r\n    return dialog && dialog.top_message === message.mid;\r\n  }\r\n\r\n  private updateMessageRepliesIfNeeded(threadMessage: MyMessage) {\r\n    try { // * на всякий случай, скорее всего это не понадобится\r\n      const threadKey = this.getThreadKey(threadMessage);\r\n      if(threadKey) {\r\n        const repliesKey = this.threadsToReplies[threadKey];\r\n        if(repliesKey) {\r\n          const [peerId, mid] = repliesKey.split('_');\r\n\r\n          this.updateMessage(peerId.toPeerId(), +mid, 'replies_updated');\r\n        }\r\n      }\r\n    } catch(err) {\r\n      this.log.error('incrementMessageReplies err', err, threadMessage);\r\n    }\r\n  }\r\n\r\n  private getThreadKey(threadMessage: MyMessage) {\r\n    let threadKey = '';\r\n    if(threadMessage.peerId?.isAnyChat() && threadMessage.reply_to) {\r\n      const threadId = threadMessage.reply_to.reply_to_top_id || threadMessage.reply_to.reply_to_msg_id;\r\n      threadKey = threadMessage.peerId + '_' + threadId;\r\n    }\r\n\r\n    return threadKey;\r\n  }\r\n\r\n  public updateMessage(peerId: PeerId, mid: number, broadcastEventName?: 'replies_updated'): Promise<Message.message> {\r\n    const promise: Promise<Message.message> = this.wrapSingleMessage(peerId, mid, true).then(() => {\r\n      const message = this.getMessageByPeer(peerId, mid);\r\n\r\n      if(broadcastEventName) {\r\n        rootScope.dispatchEvent(broadcastEventName, message);\r\n      }\r\n\r\n      return message;\r\n    });\r\n    \r\n    return promise;\r\n  }\r\n\r\n  private checkPendingMessage(message: MyMessage) {\r\n    const randomId = this.pendingByMessageId[message.mid];\r\n    let pendingMessage: ReturnType<AppMessagesManager['finalizePendingMessage']>;\r\n    if(randomId) {\r\n      const pendingData = this.pendingByRandomId[randomId];\r\n      if(pendingMessage = this.finalizePendingMessage(randomId, message)) {\r\n        rootScope.dispatchEvent('history_update', {storage: pendingData.storage, peerId: message.peerId, mid: message.mid});\r\n      }\r\n\r\n      delete this.pendingByMessageId[message.mid];\r\n    }\r\n\r\n    return pendingMessage;\r\n  }\r\n\r\n  public mutePeer(peerId: PeerId, muteUntil: number) {\r\n    const settings: InputPeerNotifySettings = {\r\n      _: 'inputPeerNotifySettings'\r\n    };\r\n\r\n    settings.mute_until = muteUntil;\r\n\r\n    return appNotificationsManager.updateNotifySettings({\r\n      _: 'inputNotifyPeer',\r\n      peer: appPeersManager.getInputPeerById(peerId)\r\n    }, settings);\r\n  }\r\n\r\n  public togglePeerMute(peerId: PeerId, mute?: boolean) {\r\n    if(mute === undefined) {\r\n      mute = !appNotificationsManager.isPeerLocalMuted(peerId, false);\r\n    }\r\n\r\n    return this.mutePeer(peerId, mute ? MUTE_UNTIL : 0);\r\n  }\r\n\r\n  public canSendToPeer(peerId: PeerId, threadId?: number, action: ChatRights = 'send_messages') {\r\n    if(appPeersManager.isRestricted(peerId)) {\r\n      return false;\r\n    }\r\n    \r\n    if(peerId.isAnyChat()) {\r\n      //const isChannel = appPeersManager.isChannel(peerId);\r\n      const chat: Chat.chat = appChatsManager.getChat(peerId.toChatId());\r\n      const hasRights = /* isChannel &&  */appChatsManager.hasRights(peerId.toChatId(), action, undefined, !!threadId); \r\n      return /* !isChannel ||  */hasRights && (!chat.pFlags.left || !!threadId);\r\n    } else {\r\n      return appUsersManager.canSendToUser(peerId);\r\n    }\r\n  }\r\n\r\n  public finalizePendingMessage(randomId: Long, finalMessage: MyMessage) {\r\n    const pendingData = this.pendingByRandomId[randomId];\r\n    // this.log('pdata', randomID, pendingData)\r\n\r\n    if(pendingData) {\r\n      const {peerId, tempId, threadId, storage} = pendingData;\r\n\r\n      [this.getHistoryStorage(peerId), threadId ? this.getHistoryStorage(peerId, threadId) : undefined]\r\n      .filter(Boolean)\r\n      .forEach(storage => {\r\n        storage.history.delete(tempId);\r\n      });\r\n\r\n      // this.log('pending', randomID, historyStorage.pending)\r\n\r\n      const tempMessage: MyMessage = this.getMessageFromStorage(storage, tempId);\r\n      if(!tempMessage.deleted) {\r\n        delete finalMessage.pFlags.is_outgoing;\r\n        delete finalMessage.pending;\r\n        delete finalMessage.error;\r\n        delete finalMessage.random_id;\r\n        delete finalMessage.send;\r\n      }\r\n\r\n      rootScope.dispatchEvent('messages_pending');\r\n      \r\n      delete this.pendingByRandomId[randomId];\r\n\r\n      this.finalizePendingMessageCallbacks(storage, tempId, finalMessage);\r\n\r\n      return tempMessage;\r\n    }\r\n  }\r\n\r\n  public finalizePendingMessageCallbacks(storage: MessagesStorage, tempId: number, message: MyMessage) {\r\n    const callbacks = this.tempFinalizeCallbacks[tempId];\r\n    //this.log.warn(callbacks, tempId);\r\n    if(callbacks !== undefined) {\r\n      for(const name in callbacks) {\r\n        const {deferred, callback} = callbacks[name];\r\n        //this.log(`finalizePendingMessageCallbacks: will invoke ${name} callback`);\r\n        callback(message).then(deferred.resolve, deferred.reject);\r\n      }\r\n\r\n      delete this.tempFinalizeCallbacks[tempId];\r\n    }\r\n\r\n    // set cached url to media\r\n    if((message as Message.message).media) {\r\n      assumeType<Message.message>(message);\r\n      const {photo: newPhoto, document: newDoc} = message.media as any;\r\n      if(newPhoto) {\r\n        const photo = appPhotosManager.getPhoto('' + tempId);\r\n        if(/* photo._ !== 'photoEmpty' */photo) {\r\n          const newPhotoSize = newPhoto.sizes[newPhoto.sizes.length - 1];\r\n          const cacheContext = appDownloadManager.getCacheContext(newPhoto, newPhotoSize.type);\r\n          const oldCacheContext = appDownloadManager.getCacheContext(photo, 'full');\r\n          Object.assign(cacheContext, oldCacheContext);\r\n\r\n          const photoSize = newPhoto.sizes[newPhoto.sizes.length - 1] as PhotoSize.photoSize;\r\n\r\n          const downloadOptions = appPhotosManager.getPhotoDownloadOptions(newPhoto, photoSize);\r\n          const fileName = getFileNameByLocation(downloadOptions.location);\r\n          appDownloadManager.fakeDownload(fileName, oldCacheContext.url);\r\n        }\r\n      } else if(newDoc) {\r\n        const oldDoc = appDocsManager.getDoc('' + tempId);\r\n        if(oldDoc) {\r\n          const oldCacheContext = appDownloadManager.getCacheContext(oldDoc);\r\n          if(\r\n            /* doc._ !== 'documentEmpty' &&  */\r\n            oldDoc.type && \r\n            oldDoc.type !== 'sticker' && \r\n            oldDoc.mime_type !== 'image/gif' && \r\n            oldCacheContext.url\r\n          ) {\r\n            const cacheContext = appDownloadManager.getCacheContext(newDoc);\r\n            Object.assign(cacheContext, oldCacheContext);\r\n\r\n            const fileName = appDocsManager.getInputFileName(newDoc);\r\n            appDownloadManager.fakeDownload(fileName, oldCacheContext.url);\r\n          }\r\n        }\r\n      } else if((message.media as MessageMedia.messageMediaPoll).poll) {\r\n        delete appPollsManager.polls[tempId];\r\n        delete appPollsManager.results[tempId];\r\n      }\r\n    }\r\n\r\n    const tempMessage = this.getMessageFromStorage(storage, tempId);\r\n    storage.delete(tempId);\r\n    \r\n    this.handleReleasingMessage(tempMessage, storage);\r\n\r\n    rootScope.dispatchEvent('message_sent', {storage, tempId, tempMessage, mid: message.mid, message});\r\n  }\r\n\r\n  public incrementMaxSeenId(maxId: number) {\r\n    if(!maxId || !(!this.maxSeenId || maxId > this.maxSeenId)) {\r\n      return false;\r\n    }\r\n\r\n    this.maxSeenId = maxId;\r\n    appStateManager.pushToState('maxSeenMsgId', maxId);\r\n\r\n    apiManager.invokeApi('messages.receivedMessages', {\r\n      max_id: appMessagesIdsManager.getServerMessageId(maxId)\r\n    });\r\n  }\r\n\r\n  public getMessageReactionsListAndReadParticipants(\r\n    message: Message.message, \r\n    limit?: number, \r\n    reaction?: string, \r\n    offset?: string,\r\n    skipReadParticipants?: boolean,\r\n    skipReactionsList?: boolean\r\n  ) {\r\n    const emptyMessageReactionsList = {\r\n      reactions: [] as MessagePeerReaction[],\r\n      count: 0,\r\n      next_offset: undefined as string\r\n    };\r\n\r\n    const canViewMessageReadParticipants = this.canViewMessageReadParticipants(message);\r\n    if(canViewMessageReadParticipants && limit === undefined) {\r\n      limit = 100;\r\n    } else if(limit === undefined) {\r\n      limit = 50;\r\n    }\r\n\r\n    return Promise.all([\r\n      canViewMessageReadParticipants && !reaction && !skipReadParticipants ? this.getMessageReadParticipants(message.peerId, message.mid).catch(() => [] as UserId[]) : [] as UserId[],\r\n\r\n      message.reactions?.recent_reactions?.length && !skipReactionsList ? appReactionsManager.getMessageReactionsList(message.peerId, message.mid, limit, reaction, offset).catch(err => emptyMessageReactionsList) : emptyMessageReactionsList\r\n    ]).then(([userIds, messageReactionsList]) => {\r\n      const readParticipantsPeerIds = userIds.map(userId => userId.toPeerId());\r\n      \r\n      const filteredReadParticipants = readParticipantsPeerIds.slice();\r\n      forEachReverse(filteredReadParticipants, (peerId, idx, arr) => {\r\n        if(messageReactionsList.reactions.some(reaction => appPeersManager.getPeerId(reaction.peer_id) === peerId)) {\r\n          arr.splice(idx, 1);\r\n        }\r\n      });\r\n\r\n      let combined: {peerId: PeerId, reaction?: string}[] = messageReactionsList.reactions.map(reaction => ({peerId: appPeersManager.getPeerId(reaction.peer_id), reaction: reaction.reaction}));\r\n      combined = combined.concat(filteredReadParticipants.map(readPeerId => ({peerId: readPeerId})));\r\n      \r\n      return {\r\n        reactions: messageReactionsList.reactions,\r\n        reactionsCount: messageReactionsList.count,\r\n        readParticipants: readParticipantsPeerIds,\r\n        combined: combined,\r\n        nextOffset: messageReactionsList.next_offset\r\n      };\r\n    });\r\n  }\r\n\r\n  public getMessageReadParticipants(peerId: PeerId, mid: number): Promise<UserId[]> {\r\n    return apiManager.invokeApiSingle('messages.getMessageReadParticipants', {\r\n      peer: appPeersManager.getInputPeerById(peerId),\r\n      msg_id: appMessagesIdsManager.getServerMessageId(mid)\r\n    }).then(userIds => { // ! convert long to number\r\n      return userIds.map(userId => userId.toUserId());\r\n    });\r\n  }\r\n\r\n  public canViewMessageReadParticipants(message: Message) {\r\n    if(\r\n      message._ !== 'message' || \r\n      message.pFlags.is_outgoing || \r\n      !message.pFlags.out || \r\n      !appPeersManager.isAnyGroup(message.peerId)\r\n    ) {\r\n      return false;\r\n    }\r\n\r\n    const chat: Chat.chat | Chat.channel = appChatsManager.getChat(message.peerId.toChatId());\r\n    return chat.participants_count <= rootScope.appConfig.chat_read_mark_size_threshold && \r\n      (tsNow(true) - message.date) < rootScope.appConfig.chat_read_mark_expire_period;\r\n  }\r\n\r\n  public incrementMessageViews(peerId: PeerId, mids: number[]) {\r\n    if(!mids.length) {\r\n      return;\r\n    }\r\n\r\n    return apiManager.invokeApiSingle('messages.getMessagesViews', {\r\n      peer: appPeersManager.getInputPeerById(peerId),\r\n      id: mids.map(mid => appMessagesIdsManager.getServerMessageId(mid)),\r\n      increment: true\r\n    }).then(views => {\r\n      const updates: Update[] = new Array(mids.length);\r\n      const channelId = peerId.toChatId();\r\n      for(let i = 0, length = mids.length; i < length; ++i) {\r\n        updates[i] = {\r\n          _: 'updateChannelMessageViews',\r\n          channel_id: channelId,\r\n          id: mids[i],\r\n          views: views.views[i].views\r\n        };\r\n      }\r\n\r\n      apiUpdatesManager.processUpdateMessage({\r\n        _: 'updates',\r\n        updates,\r\n        chats: views.chats,\r\n        users: views.users\r\n      });\r\n    });\r\n  }\r\n\r\n  private notifyAboutMessage(message: MyMessage, options: Partial<{\r\n    fwdCount: number,\r\n    peerReaction: MessagePeerReaction,\r\n    peerTypeNotifySettings: PeerNotifySettings\r\n  }> = {}) {\r\n    const peerId = this.getMessagePeer(message);\r\n\r\n    if(appPeersManager.isRestricted(peerId)) {\r\n      return;\r\n    }\r\n\r\n    const isAnyChat = peerId.isAnyChat();\r\n    const notification: NotifyOptions = {};\r\n    const peerString = appPeersManager.getPeerString(peerId);\r\n    let notificationMessage: string;\r\n\r\n    if(options.peerTypeNotifySettings.show_previews) {\r\n      if(message._ === 'message' && message.fwd_from && options.fwdCount > 1) {\r\n        notificationMessage = I18n.format('Notifications.Forwarded', true, [options.fwdCount]);\r\n      } else {\r\n        notificationMessage = this.wrapMessageForReply(message, undefined, undefined, true);\r\n\r\n        if(options.peerReaction) {\r\n          const langPackKey: LangPackKey = /* isAnyChat ? 'Notification.Group.Reacted' :  */'Notification.Contact.Reacted';\r\n          const args: FormatterArguments = [\r\n            RichTextProcessor.fixEmoji(options.peerReaction.reaction), // can be plain heart\r\n            notificationMessage\r\n          ];\r\n  \r\n          /* if(isAnyChat) {\r\n            args.unshift(appPeersManager.getPeerTitle(message.fromId, true));\r\n          } */\r\n  \r\n          notificationMessage = I18n.format(langPackKey, true, args);\r\n        }\r\n      }\r\n    } else {\r\n      notificationMessage = I18n.format('Notifications.New', true);\r\n    }\r\n\r\n    if(options.peerReaction) {\r\n      notification.noIncrement = true;\r\n      notification.silent = true;\r\n    }\r\n\r\n    const notificationFromPeerId = options.peerReaction ? appPeersManager.getPeerId(options.peerReaction.peer_id) : message.fromId;\r\n    notification.title = appPeersManager.getPeerTitle(peerId, true);\r\n    if(isAnyChat && notificationFromPeerId !== message.peerId) {\r\n      notification.title = appPeersManager.getPeerTitle(notificationFromPeerId, true) +\r\n        ' @ ' +\r\n        notification.title;\r\n    }\r\n\r\n    notification.title = RichTextProcessor.wrapPlainText(notification.title);\r\n\r\n    notification.onclick = () => {\r\n      rootScope.dispatchEvent('history_focus', {peerId, mid: message.mid});\r\n    };\r\n\r\n    notification.message = notificationMessage;\r\n    notification.key = 'msg' + message.mid;\r\n    notification.tag = peerString;\r\n    notification.silent = true;//message.pFlags.silent || false;\r\n\r\n    const peerPhoto = appPeersManager.getPeerPhoto(peerId);\r\n    if(peerPhoto) {\r\n      appAvatarsManager.loadAvatar(peerId, peerPhoto, 'photo_small').loadPromise.then(url => {\r\n        if(message.pFlags.unread || options.peerReaction) {\r\n          notification.image = url;\r\n          appNotificationsManager.notify(notification);\r\n        }\r\n      });\r\n    } else {\r\n      appNotificationsManager.notify(notification);\r\n    }\r\n  }\r\n\r\n  public getScheduledMessagesStorage(peerId: PeerId) {\r\n    return this.scheduledMessagesStorage[peerId] ?? (this.scheduledMessagesStorage[peerId] = this.createMessageStorage());\r\n  }\r\n\r\n  public getScheduledMessageByPeer(peerId: PeerId, mid: number) {\r\n    return this.getMessageFromStorage(this.getScheduledMessagesStorage(peerId), mid);\r\n  }\r\n\r\n  public getScheduledMessages(peerId: PeerId): Promise<number[]> {\r\n    if(!this.canSendToPeer(peerId)) return Promise.resolve([]);\r\n\r\n    const storage = this.getScheduledMessagesStorage(peerId);\r\n    if(storage.size) {\r\n      return Promise.resolve([...storage.keys()]);\r\n    }\r\n\r\n    return apiManager.invokeApiSingle('messages.getScheduledHistory', {\r\n      peer: appPeersManager.getInputPeerById(peerId),\r\n      hash: ''\r\n    }).then(historyResult => {\r\n      if(historyResult._ !== 'messages.messagesNotModified') {\r\n        appUsersManager.saveApiUsers(historyResult.users);\r\n        appChatsManager.saveApiChats(historyResult.chats);\r\n        \r\n        const storage = this.getScheduledMessagesStorage(peerId);\r\n        this.saveMessages(historyResult.messages, {storage, isScheduled: true});\r\n        return [...storage.keys()];\r\n      }\r\n      \r\n      return [];\r\n    });\r\n  }\r\n\r\n  public sendScheduledMessages(peerId: PeerId, mids: number[]) {\r\n    return apiManager.invokeApi('messages.sendScheduledMessages', {\r\n      peer: appPeersManager.getInputPeerById(peerId),\r\n      id: mids.map(mid => appMessagesIdsManager.getServerMessageId(mid))\r\n    }).then(updates => {\r\n      apiUpdatesManager.processUpdateMessage(updates);\r\n    });\r\n  }\r\n\r\n  public deleteScheduledMessages(peerId: PeerId, mids: number[]) {\r\n    return apiManager.invokeApi('messages.deleteScheduledMessages', {\r\n      peer: appPeersManager.getInputPeerById(peerId),\r\n      id: mids.map(mid => appMessagesIdsManager.getServerMessageId(mid))\r\n    }).then(updates => {\r\n      apiUpdatesManager.processUpdateMessage(updates);\r\n    });\r\n  }\r\n\r\n  public getMessageWithReplies(message: Message.message) {\r\n    if(message.peerId !== REPLIES_PEER_ID) {\r\n      message = this.filterMessages(message, message => !!(message as Message.message).replies)[0] as any;\r\n      if(!(message && message.replies && message.replies.pFlags.comments && message.replies.channel_id.toChatId() !== REPLIES_HIDDEN_CHANNEL_ID)) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    return message;\r\n  }\r\n\r\n  public isFetchIntervalNeeded(peerId: PeerId) {\r\n    return peerId.isAnyChat() && !appChatsManager.isInChat(peerId.toChatId());\r\n  }\r\n\r\n  public isRestricted(message: Message.message) {\r\n    return !!(message.restriction_reason && isRestricted(message.restriction_reason));\r\n  }\r\n\r\n  public async getNewHistory(peerId: PeerId, threadId?: number) {\r\n    if(!this.isFetchIntervalNeeded(peerId)) {\r\n      return;\r\n    }\r\n\r\n    const historyStorage = this.getHistoryStorage(peerId, threadId);\r\n    const slice = historyStorage.history.slice;\r\n    if(!slice.isEnd(SliceEnd.Bottom)) {\r\n      return;\r\n    }\r\n\r\n    delete historyStorage.maxId;\r\n    slice.unsetEnd(SliceEnd.Bottom);\r\n\r\n    // if there is no id - then request by first id because cannot request by id 0 with backLimit\r\n    let historyResult = this.getHistory(peerId, slice[0] ?? 1, 0, 50, threadId);\r\n    if(historyResult instanceof Promise) {\r\n      historyResult = await historyResult;\r\n    }\r\n\r\n    for(let i = 0, length = historyResult.history.length; i < length; ++i) {\r\n      this.handleNewMessage(peerId, historyResult.history[i]);\r\n    }\r\n\r\n    return historyStorage;\r\n  }\r\n\r\n  /**\r\n   * * https://core.telegram.org/api/offsets, offset_id is inclusive\r\n   */\r\n  public getHistory(peerId: PeerId, maxId = 0, limit: number, backLimit?: number, threadId?: number): Promise<HistoryResult> | HistoryResult {\r\n    const historyStorage = this.getHistoryStorage(peerId, threadId);\r\n\r\n    if(appPeersManager.isRestricted(peerId)) {\r\n      const first = historyStorage.history.first;\r\n      first.setEnd(SliceEnd.Both);\r\n\r\n      const slice = first.slice(0, 0);\r\n      slice.setEnd(SliceEnd.Both);\r\n      \r\n      return {\r\n        count: 0,\r\n        history: slice,\r\n        offsetIdOffset: 0\r\n      };\r\n    }\r\n\r\n    let offset = 0;\r\n    /* \r\n    let offsetFound = true;\r\n\r\n    if(maxId) {\r\n      offsetFound = false;\r\n      for(; offset < historyStorage.history.length; offset++) {\r\n        if(maxId > historyStorage.history.slice[offset]) {\r\n          offsetFound = true;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    if(offsetFound && (\r\n      historyStorage.count !== null && historyStorage.history.length === historyStorage.count ||\r\n      historyStorage.history.length >= offset + limit\r\n      )) {\r\n      if(backLimit) {\r\n        backLimit = Math.min(offset, backLimit);\r\n        offset = Math.max(0, offset - backLimit);\r\n        limit += backLimit;\r\n      } else {\r\n        limit = limit;\r\n      }\r\n\r\n      const history = historyStorage.history.slice.slice(offset, offset + limit);\r\n      return {\r\n        count: historyStorage.count,\r\n        history: history,\r\n        offsetIdOffset: offset\r\n      };\r\n    }\r\n\r\n    if(offsetFound) {\r\n      offset = 0;\r\n    } */\r\n\r\n    if(backLimit) {\r\n      offset = -backLimit;\r\n      limit += backLimit;\r\n\r\n      /* return this.requestHistory(reqPeerId, maxId, limit, offset, undefined, threadId).then((historyResult) => {\r\n        historyStorage.count = (historyResult as MessagesMessages.messagesMessagesSlice).count || historyResult.messages.length;\r\n\r\n        const history = (historyResult.messages as MyMessage[]).map(message => message.mid);\r\n        return {\r\n          count: historyStorage.count,\r\n          history,\r\n          offsetIdOffset: (historyResult as MessagesMessages.messagesMessagesSlice).offset_id_offset || 0\r\n        };\r\n      }); */\r\n    }\r\n\r\n    const haveSlice = historyStorage.history.sliceMe(maxId, offset, limit);\r\n    if(haveSlice && (haveSlice.slice.length === limit || (haveSlice.fulfilled & SliceEnd.Both) === SliceEnd.Both)) {\r\n      return {\r\n        count: historyStorage.count,\r\n        history: haveSlice.slice,\r\n        offsetIdOffset: haveSlice.offsetIdOffset\r\n      }; \r\n    }\r\n\r\n    return this.fillHistoryStorage(peerId, maxId, limit, offset, historyStorage, threadId).then(() => {\r\n      const slice = historyStorage.history.sliceMe(maxId, offset, limit);\r\n      return {\r\n        count: historyStorage.count,\r\n        history: slice?.slice || historyStorage.history.constructSlice(),\r\n        offsetIdOffset: slice?.offsetIdOffset || historyStorage.count\r\n      };\r\n    });\r\n  }\r\n\r\n  public isHistoryResultEnd(historyResult: Exclude<MessagesMessages, MessagesMessages.messagesMessagesNotModified>, limit: number, add_offset: number) {\r\n    const {offset_id_offset, messages} = historyResult as MessagesMessages.messagesMessagesSlice;\r\n\r\n    const count = (historyResult as MessagesMessages.messagesMessagesSlice).count || messages.length;\r\n    const offsetIdOffset = offset_id_offset || 0;\r\n\r\n    const topWasMeantToLoad = add_offset < 0 ? limit + add_offset : limit;\r\n\r\n    const isTopEnd = offsetIdOffset >= (count - topWasMeantToLoad) || count < topWasMeantToLoad;\r\n    const isBottomEnd = !offsetIdOffset || (add_offset < 0 && (offsetIdOffset + add_offset) <= 0);\r\n\r\n    return {count, offsetIdOffset, isTopEnd, isBottomEnd};\r\n  }\r\n\r\n  public mergeHistoryResult(slicedArray: SlicedArray<number>, \r\n    historyResult: Parameters<AppMessagesManager['isHistoryResultEnd']>[0], \r\n    offset_id: number, \r\n    limit: number, \r\n    add_offset: number) {\r\n    const {messages} = historyResult as MessagesMessages.messagesMessagesSlice;\r\n    const isEnd = this.isHistoryResultEnd(historyResult, limit, add_offset);\r\n    const {count, offsetIdOffset, isTopEnd, isBottomEnd} = isEnd;\r\n    const mids = messages.map((message) => {\r\n      return (message as MyMessage).mid;\r\n    });\r\n\r\n    // * add bound manually. \r\n    // * offset_id will be inclusive only if there is 'add_offset' <= -1 (-1 - will only include the 'offset_id')\r\n    // * check that offset_id is not 0\r\n    if(offset_id && appMessagesIdsManager.getServerMessageId(offset_id) && !mids.includes(offset_id) && offsetIdOffset < count) {\r\n      let i = 0;\r\n      for(const length = mids.length; i < length; ++i) {\r\n        if(offset_id > mids[i]) {\r\n          break;\r\n        }\r\n      }\r\n\r\n      mids.splice(i, 0, offset_id);\r\n    }\r\n\r\n    const slice = slicedArray.insertSlice(mids) || slicedArray.slice;\r\n    if(isTopEnd) {\r\n      slice.setEnd(SliceEnd.Top);\r\n    }\r\n  \r\n    if(isBottomEnd) {\r\n      slice.setEnd(SliceEnd.Bottom);\r\n    }\r\n\r\n    return {slice, mids, messages, ...isEnd};\r\n  }\r\n\r\n  public fillHistoryStorage(peerId: PeerId, offset_id: number, limit: number, add_offset: number, historyStorage: HistoryStorage, threadId?: number): Promise<void> {\r\n    return this.requestHistory(peerId, offset_id, limit, add_offset, undefined, threadId).then((historyResult) => {\r\n      const {count, isBottomEnd, slice, messages} = this.mergeHistoryResult(historyStorage.history, historyResult, offset_id, limit, add_offset);\r\n\r\n      historyStorage.count = count;\r\n\r\n      /* if(!maxId && historyResult.messages.length) {\r\n        maxId = this.incrementMessageId((historyResult.messages[0] as MyMessage).mid, 1);\r\n      }\r\n\r\n      const wasTotalCount = historyStorage.history.length; */\r\n\r\n      for(let i = 0, length = messages.length; i < length; ++i) {\r\n        const message = messages[i] as MyMessage;\r\n        if(this.mergeReplyKeyboard(historyStorage, message)) {\r\n          rootScope.dispatchEvent('history_reply_markup', {peerId});\r\n        }\r\n      }\r\n\r\n      if(isBottomEnd) {\r\n        historyStorage.maxId = slice[0]; // ! WARNING\r\n      }\r\n      \r\n      /* const isBackLimit = offset < 0 && -offset !== fullLimit;\r\n      if(isBackLimit) {\r\n        return;\r\n      }\r\n\r\n      const totalCount = historyStorage.history.length;\r\n      fullLimit -= (totalCount - wasTotalCount);\r\n\r\n      const migratedNextPeer = this.migratedFromTo[peerId];\r\n      const migratedPrevPeer = this.migratedToFrom[peerId]\r\n      const isMigrated = migratedNextPeer !== undefined || migratedPrevPeer !== undefined;\r\n\r\n      if(isMigrated) {\r\n        historyStorage.count = Math.max(historyStorage.count, totalCount) + 1;\r\n      }\r\n\r\n      if(fullLimit > 0) {\r\n        maxId = historyStorage.history.slice[totalCount - 1];\r\n        if(isMigrated) {\r\n          if(!historyResult.messages.length) {\r\n            if(migratedPrevPeer) {\r\n              maxId = 0;\r\n              peerId = migratedPrevPeer;\r\n            } else {\r\n              historyStorage.count = totalCount;\r\n              return true;\r\n            }\r\n          }\r\n\r\n          return this.fillHistoryStorage(peerId, maxId, fullLimit, historyStorage, threadId);\r\n        } else if(totalCount < historyStorage.count) {\r\n          return this.fillHistoryStorage(peerId, maxId, fullLimit, offset, historyStorage, threadId);\r\n        }\r\n      } */\r\n    });\r\n  }\r\n\r\n  public requestHistory(peerId: PeerId, maxId: number, limit = 0, offset = 0, offsetDate = 0, threadId = 0): Promise<Exclude<MessagesMessages, MessagesMessages.messagesMessagesNotModified>> {\r\n    //console.trace('requestHistory', peerId, maxId, limit, offset);\r\n\r\n    //rootScope.broadcast('history_request');\r\n\r\n    const options: any = {\r\n      peer: appPeersManager.getInputPeerById(peerId),\r\n      offset_id: appMessagesIdsManager.getServerMessageId(maxId) || 0,\r\n      offset_date: offsetDate,\r\n      add_offset: offset,\r\n      limit,\r\n      max_id: 0,\r\n      min_id: 0,\r\n      hash: 0\r\n    };\r\n\r\n    if(threadId) {\r\n      options.msg_id = appMessagesIdsManager.getServerMessageId(threadId) || 0;\r\n    }\r\n\r\n    const promise: ReturnType<AppMessagesManager['requestHistory']> = apiManager.invokeApiSingle(threadId ? 'messages.getReplies' : 'messages.getHistory', options, {\r\n      //timeout: APITIMEOUT,\r\n      noErrorBox: true\r\n    }) as any;\r\n\r\n    return promise.then((historyResult) => {\r\n      if(DEBUG) {\r\n        this.log('requestHistory result:', peerId, historyResult, maxId, limit, offset);\r\n      }\r\n\r\n      appUsersManager.saveApiUsers(historyResult.users);\r\n      appChatsManager.saveApiChats(historyResult.chats);\r\n      this.saveMessages(historyResult.messages);\r\n\r\n      if(appPeersManager.isChannel(peerId)) {\r\n        apiUpdatesManager.addChannelState(peerId.toChatId(), (historyResult as MessagesMessages.messagesChannelMessages).pts);\r\n      }\r\n\r\n      let length = historyResult.messages.length, count = (historyResult as MessagesMessages.messagesMessagesSlice).count;\r\n      if(length && historyResult.messages[length - 1].deleted) {\r\n        historyResult.messages.splice(length - 1, 1);\r\n        length--;\r\n        count--;\r\n      }\r\n\r\n      // will load more history if last message is album grouped (because it can be not last item)\r\n      // historyResult.messages: desc sorted\r\n      const historyStorage = this.getHistoryStorage(peerId, threadId);\r\n      const oldestMessage: Message.message = historyResult.messages[length - 1] as any;\r\n      if(length && oldestMessage.grouped_id) {\r\n        const foundSlice = historyStorage.history.findSlice(oldestMessage.mid);\r\n        if(foundSlice && (foundSlice.slice.length + historyResult.messages.length) < count) {\r\n          return this.requestHistory(peerId, oldestMessage.mid, 10, 0, offsetDate, threadId).then((_historyResult) => {\r\n            return historyResult;\r\n          });\r\n        }\r\n      }\r\n\r\n      return historyResult;\r\n    }, (error) => {\r\n      switch (error.type) {\r\n        case 'CHANNEL_PRIVATE':\r\n          let channel = appChatsManager.getChat(peerId.toChatId());\r\n          channel = {_: 'channelForbidden', access_hash: channel.access_hash, title: channel.title};\r\n          apiUpdatesManager.processUpdateMessage({\r\n            _: 'updates',\r\n            updates: [{\r\n              _: 'updateChannel',\r\n              channel_id: peerId.toChatId()\r\n            }],\r\n            chats: [channel],\r\n            users: []\r\n          });\r\n          break;\r\n      }\r\n\r\n      throw error;\r\n    });\r\n  }\r\n\r\n  public fetchSingleMessages() {\r\n    if(this.fetchSingleMessagesPromise) {\r\n      return this.fetchSingleMessagesPromise;\r\n    }\r\n\r\n    return this.fetchSingleMessagesPromise = new Promise((resolve) => {\r\n      setTimeout(() => {\r\n        const requestPromises: Promise<void>[] = [];\r\n        \r\n        for(const [peerId, map] of this.needSingleMessages) {\r\n          const mids = [...map.keys()];\r\n          const msgIds: InputMessage[] = mids.map((mid) => {\r\n            return {\r\n              _: 'inputMessageID',\r\n              id: appMessagesIdsManager.getServerMessageId(mid)\r\n            };\r\n          });\r\n    \r\n          let promise: Promise<MethodDeclMap['channels.getMessages']['res'] | MethodDeclMap['messages.getMessages']['res']>;\r\n          if(peerId.isAnyChat() && appPeersManager.isChannel(peerId)) {\r\n            promise = apiManager.invokeApiSingle('channels.getMessages', {\r\n              channel: appChatsManager.getChannelInput(peerId.toChatId()),\r\n              id: msgIds\r\n            });\r\n          } else {\r\n            promise = apiManager.invokeApiSingle('messages.getMessages', {\r\n              id: msgIds\r\n            });\r\n          }\r\n\r\n          const after = promise.then(getMessagesResult => {\r\n            assumeType<Exclude<MessagesMessages.messagesMessages, MessagesMessages.messagesMessagesNotModified>>(getMessagesResult);\r\n\r\n            appUsersManager.saveApiUsers(getMessagesResult.users);\r\n            appChatsManager.saveApiChats(getMessagesResult.chats);\r\n            this.saveMessages(getMessagesResult.messages);\r\n\r\n            for(let i = 0; i < getMessagesResult.messages.length; ++i) {\r\n              const message = getMessagesResult.messages[i];\r\n              const mid = appMessagesIdsManager.generateMessageId(message.id);\r\n              const promise = map.get(mid);\r\n              promise.resolve(getMessagesResult.messages[i]);\r\n              map.delete(mid);\r\n            }\r\n\r\n            if(map.size) {\r\n              for(const [mid, promise] of map) {\r\n                promise.resolve(this.generateEmptyMessage(mid));\r\n              }\r\n            }\r\n          }).finally(() => {\r\n            rootScope.dispatchEvent('messages_downloaded', {peerId, mids});\r\n          });\r\n    \r\n          requestPromises.push(after);\r\n        }\r\n\r\n        this.needSingleMessages.clear();\r\n\r\n        Promise.all(requestPromises).finally(() => {\r\n          this.fetchSingleMessagesPromise = null;\r\n          if(this.needSingleMessages.size) this.fetchSingleMessages();\r\n          resolve();\r\n        });\r\n      }, 0);\r\n    });\r\n  }\r\n\r\n  public wrapSingleMessage(peerId: PeerId, mid: number, overwrite = false): Promise<Message> {\r\n    const message = this.getMessageByPeer(peerId, mid);\r\n    if(!message.deleted && !overwrite) {\r\n      rootScope.dispatchEvent('messages_downloaded', {peerId, mids: [mid]});\r\n      return Promise.resolve(message);\r\n    } else {\r\n      let map = this.needSingleMessages.get(peerId);\r\n      if(!map) {\r\n        this.needSingleMessages.set(peerId, map = new Map());\r\n      }\r\n\r\n      let promise = map.get(mid);\r\n      if(promise) {\r\n        return promise;\r\n      }\r\n\r\n      promise = deferredPromise();\r\n      map.set(mid, promise);\r\n      this.fetchSingleMessages();\r\n      return promise;\r\n    }\r\n  }\r\n\r\n  public fetchMessageReplyTo(message: MyMessage): Promise<Message> {\r\n    if(!message.reply_to_mid) return Promise.resolve(this.generateEmptyMessage(0));\r\n    const replyToPeerId = message.reply_to.reply_to_peer_id ? appPeersManager.getPeerId(message.reply_to.reply_to_peer_id) : message.peerId;\r\n    return this.wrapSingleMessage(replyToPeerId, message.reply_to_mid).then(originalMessage => {\r\n      if(originalMessage.deleted) { // ! чтобы не пыталось бесконечно загрузить удалённое сообщение\r\n        delete message.reply_to_mid; // ! WARNING!\r\n      }\r\n\r\n      return originalMessage;\r\n    });\r\n  }\r\n\r\n  public setTyping(peerId: PeerId, action: SendMessageAction, force?: boolean): Promise<boolean> {\r\n    let typing = this.typings[peerId];\r\n    if(!rootScope.myId || \r\n      !peerId || \r\n      !this.canSendToPeer(peerId) || \r\n      peerId === rootScope.myId ||\r\n      // (!force && deepEqual(typing?.action, action))\r\n      (!force && typing?.action?._ === action._)\r\n    ) {\r\n      return Promise.resolve(false);\r\n    }\r\n\r\n    if(typing?.timeout) {\r\n      clearTimeout(typing.timeout);\r\n    }\r\n\r\n    typing = this.typings[peerId] = {\r\n      action\r\n    };\r\n\r\n    return apiManager.invokeApi('messages.setTyping', {\r\n      peer: appPeersManager.getInputPeerById(peerId),\r\n      action\r\n    }).finally(() => {\r\n      if(typing === this.typings[peerId]) {\r\n        typing.timeout = window.setTimeout(() => {\r\n          delete this.typings[peerId];\r\n        }, 6000);\r\n      }\r\n    });\r\n  }\r\n\r\n  private handleReleasingMessage(message: MyMessage, storage: MessagesStorage) {\r\n    const media = (message as Message.message).media;\r\n    if(media) {\r\n      const c = (media as MessageMedia.messageMediaWebPage).webpage as WebPage.webPage || media as MessageMedia.messageMediaPhoto | MessageMedia.messageMediaDocument;\r\n      const smth: Photo.photo | MyDocument = (c as MessageMedia.messageMediaPhoto).photo as any || (c as MessageMedia.messageMediaDocument).document as any;\r\n\r\n      if(smth?.file_reference) {\r\n        referenceDatabase.deleteContext(smth.file_reference, {type: 'message', peerId: message.peerId, messageId: message.mid});\r\n      }\r\n\r\n      if('webpage' in media && media.webpage) {\r\n        const isScheduled = this.getScheduledMessagesStorage(message.peerId) === storage;\r\n        const messageKey = appWebPagesManager.getMessageKeyForPendingWebPage(message.peerId, message.mid, isScheduled);\r\n        appWebPagesManager.deleteWebPageFromPending(media.webpage, messageKey);\r\n      }\r\n\r\n      if((media as MessageMedia.messageMediaPoll).poll) {\r\n        appPollsManager.updatePollToMessage(message as Message.message, false);\r\n      }\r\n    }\r\n  }\r\n\r\n  private handleDeletedMessages(peerId: PeerId, storage: MessagesStorage, messages: number[]) {\r\n    const history: {\r\n      count: number, \r\n      unread: number, \r\n      unreadMentions: number, \r\n      msgs: Set<number>,\r\n      albums?: {[groupId: string]: Set<number>},\r\n    } = {\r\n      count: 0, \r\n      unread: 0, \r\n      unreadMentions: 0, \r\n      msgs: new Set()\r\n    };\r\n\r\n    for(const mid of messages) {\r\n      const message: MyMessage = this.getMessageFromStorage(storage, mid);\r\n      if(message.deleted) {\r\n        this.fixDialogUnreadMentionsIfNoMessage(peerId);\r\n        continue;\r\n      }\r\n\r\n      this.handleReleasingMessage(message, storage);\r\n\r\n      this.updateMessageRepliesIfNeeded(message);\r\n\r\n      if(!message.pFlags.out && !message.pFlags.is_outgoing && message.pFlags.unread) {\r\n        ++history.unread;\r\n        appNotificationsManager.cancel('msg' + mid);\r\n\r\n        if(message.pFlags.mentioned) {\r\n          ++history.unreadMentions;\r\n          this.modifyCachedMentions(peerId, mid, false);\r\n        }\r\n      }\r\n\r\n      ++history.count;\r\n      history.msgs.add(mid);\r\n\r\n      message.deleted = true;\r\n\r\n      const groupedId = (message as Message.message).grouped_id;\r\n      if(groupedId) {\r\n        const groupedStorage = this.groupedMessagesStorage[groupedId];\r\n        if(groupedStorage) {\r\n          groupedStorage.delete(mid);\r\n\r\n          if(!history.albums) history.albums = {};\r\n          (history.albums[groupedId] || (history.albums[groupedId] = new Set())).add(mid);\r\n\r\n          if(!groupedStorage.size) {\r\n            delete history.albums;\r\n            delete this.groupedMessagesStorage[groupedId];\r\n          }\r\n        }\r\n      }\r\n\r\n      storage.delete(mid);\r\n\r\n      const peerMessagesToHandle = this.newMessagesToHandle[peerId];\r\n      if(peerMessagesToHandle && peerMessagesToHandle.has(mid)) {\r\n        peerMessagesToHandle.delete(mid);\r\n      }\r\n    }\r\n\r\n    if(history.albums) {\r\n      for(const groupId in history.albums) {\r\n        rootScope.dispatchEvent('album_edit', {peerId, groupId, deletedMids: [...history.albums[groupId]]});\r\n        /* const mids = this.getMidsByAlbum(groupId);\r\n        if(mids.length) {\r\n          const mid = Math.max(...mids);\r\n          rootScope.$broadcast('message_edit', {peerId, mid, justMedia: false});\r\n        } */\r\n      }\r\n    }\r\n\r\n    return history;\r\n  }\r\n  \r\n  private handleEditedMessage(oldMessage: Message, newMessage: Message) {\r\n    if(oldMessage._ === 'message') {\r\n      if((oldMessage.media as MessageMedia.messageMediaWebPage)?.webpage) {\r\n        const messageKey = appWebPagesManager.getMessageKeyForPendingWebPage(oldMessage.peerId, oldMessage.mid, !!oldMessage.pFlags.is_scheduled);\r\n        appWebPagesManager.deleteWebPageFromPending((oldMessage.media as MessageMedia.messageMediaWebPage).webpage, messageKey);\r\n      }\r\n    }\r\n  }\r\n\r\n  public getMediaFromMessage(message: any) {\r\n    return message.action ? \r\n      message.action.photo : \r\n      message.media && (\r\n        message.media.photo || \r\n        message.media.document || (\r\n          message.media.webpage && (\r\n            message.media.webpage.document || \r\n            message.media.webpage.photo\r\n          )\r\n        )\r\n      );\r\n  }\r\n\r\n  public isMentionUnread(message: MyMessage) {\r\n    const doc = ((message as Message.message).media as MessageMedia.messageMediaDocument)?.document as MyDocument;\r\n    return message.pFlags.media_unread && \r\n      message.pFlags.mentioned && \r\n      (\r\n        !doc || \r\n        !(['voice', 'round'] as MyDocument['type'][]).includes(doc.type)\r\n      );\r\n  }\r\n\r\n  public getDialogUnreadCount(dialog: Dialog) {\r\n    return dialog.unread_count || +!!dialog.pFlags.unread_mark;\r\n  }\r\n\r\n  public isDialogUnread(dialog: Dialog) {\r\n    return !!this.getDialogUnreadCount(dialog);\r\n  }\r\n\r\n  public canForward(message: Message.message | Message.messageService) {\r\n    return message._ === 'message' && !(message as Message.message).pFlags.noforwards && !appPeersManager.noForwards(message.peerId);\r\n  }\r\n\r\n  private pushBatchUpdate<E extends keyof BatchUpdates, C extends BatchUpdates[E]>(\r\n    event: E, \r\n    callback: C, \r\n    key: string, \r\n    getElementCallback?: () => MapValueType<ArgumentTypes<C>[0]>\r\n  ) {\r\n    let details = this.batchUpdates[event];\r\n    if(!details) {\r\n      // @ts-ignore\r\n      details = this.batchUpdates[event] = {\r\n        callback,\r\n        batch: new Map()\r\n      };\r\n    }\r\n\r\n    if(!details.batch.has(key)) {\r\n      // @ts-ignore\r\n      details.batch.set(key, getElementCallback ? getElementCallback() : undefined);\r\n      this.batchUpdatesDebounced();\r\n    }\r\n  }\r\n\r\n  private getMessagesFromMap<T extends Map<any, any>>(map: T) {\r\n    const newMap: Map<Message.message, MapValueType<T>> = new Map();\r\n    for(const [key, value] of map) {\r\n      const [peerIdStr, mid] = key.split('_');\r\n      const message: Message.message | Message.messageEmpty = this.getMessageByPeer(peerIdStr.toPeerId(), +mid);\r\n      if(message._ === 'messageEmpty') {\r\n        continue;\r\n      }\r\n\r\n      newMap.set(message, value);\r\n    }\r\n\r\n    return newMap;\r\n  }\r\n\r\n  private batchUpdateViews = (batch: Map<string, undefined>) => {\r\n    const toDispatch: {peerId: PeerId, mid: number, views: number}[] = [];\r\n\r\n    const map = this.getMessagesFromMap(batch);\r\n    for(const [message] of map) {\r\n      toDispatch.push({\r\n        peerId: message.peerId,\r\n        mid: message.mid,\r\n        views: message.views\r\n      })\r\n    }\r\n\r\n    return toDispatch;\r\n  };\r\n\r\n  private batchUpdateReactions = (batch: Map<string, MessageReactions>) => {\r\n    const toDispatch: {message: Message.message, changedResults: ReactionCount.reactionCount[]}[] = [];\r\n\r\n    const map = this.getMessagesFromMap(batch);\r\n    for(const [message, previousReactions] of map) {\r\n      const results = message.reactions?.results ?? [];\r\n      const previousResults = previousReactions?.results ?? [];\r\n      const changedResults = results.filter(reactionCount => {\r\n        const previousReactionCount = previousResults.find(_reactionCount => _reactionCount.reaction === reactionCount.reaction);\r\n        return (\r\n          message.pFlags.out && (\r\n            !previousReactionCount || \r\n            reactionCount.count > previousReactionCount.count\r\n          )\r\n        ) || (\r\n          reactionCount.pFlags.chosen && (\r\n            !previousReactionCount || \r\n            !previousReactionCount.pFlags.chosen\r\n          )\r\n        );\r\n      });\r\n\r\n      toDispatch.push({message, changedResults});\r\n    }\r\n\r\n    return toDispatch;\r\n  };\r\n}\r\n\r\nconst appMessagesManager = new AppMessagesManager();\r\nMOUNT_CLASS_TO.appMessagesManager = appMessagesManager;\r\nexport default appMessagesManager;\r\n","export default function splitStringByLength(str: string, maxLength: number) {\r\n  if(str.length < maxLength) return [str];\r\n  let length = 0, lastSliceStartIndex = 0, arrayIndex = 0;\r\n  const delimiter = ' ';//'\\n';\r\n  const out: string[] = [];\r\n\r\n  const cut = (end?: number) => {\r\n    let part = str.slice(lastSliceStartIndex, end);\r\n    const _arrayIndex = arrayIndex++;\r\n    if(part.length > maxLength) {\r\n      let overflowPart = part.slice(maxLength);\r\n      const splitted = splitStringByLength(overflowPart, maxLength);\r\n      splitted.forEach(part => {\r\n        out[arrayIndex++] = part;\r\n      });\r\n\r\n      part = part.slice(0, maxLength);\r\n    }\r\n\r\n    lastSliceStartIndex = end;\r\n    length = 0;\r\n    out[_arrayIndex] = (out[_arrayIndex] || '') + part;\r\n  };\r\n\r\n  let lastIndex = 0;\r\n  do {\r\n    let index = str.indexOf(delimiter, lastIndex);\r\n    if(index === -1) {\r\n      if(lastIndex !== (str.length - 1)) {\r\n        cut();\r\n      }\r\n\r\n      break;\r\n    }\r\n\r\n    index += delimiter.length;\r\n\r\n    const partLength = index - lastIndex;\r\n    if((length + partLength) > maxLength) {\r\n      cut(length);\r\n    }\r\n    \r\n    lastIndex = index;\r\n    length += partLength;\r\n  } while(true);\r\n\r\n  return out;\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n * \r\n * Originally from:\r\n * https://github.com/zhukov/webogram\r\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\r\n * https://github.com/zhukov/webogram/blob/master/LICENSE\r\n */\r\n\r\nimport { MOUNT_CLASS_TO } from \"../../config/debug\";\r\nimport copy from \"../../helpers/object/copy\";\r\nimport deepEqual from \"../../helpers/object/deepEqual\";\r\nimport isObject from \"../../helpers/object/isObject\";\r\nimport safeReplaceObject from \"../../helpers/object/safeReplaceObject\";\r\nimport { ChannelParticipant, ChannelsCreateChannel, Chat, ChatAdminRights, ChatBannedRights, ChatParticipant, ChatPhoto, InputChannel, InputChatPhoto, InputFile, InputPeer, Update, Updates } from \"../../layer\";\r\nimport apiManagerProxy from \"../mtproto/mtprotoworker\";\r\nimport apiManager from '../mtproto/mtprotoworker';\r\nimport { RichTextProcessor } from \"../richtextprocessor\";\r\nimport rootScope from \"../rootScope\";\r\nimport apiUpdatesManager from \"./apiUpdatesManager\";\r\nimport appPeersManager from \"./appPeersManager\";\r\nimport appStateManager from \"./appStateManager\";\r\nimport appUsersManager from \"./appUsersManager\";\r\nimport { isRestricted } from \"../../helpers/restrictions\";\r\nimport findAndSplice from \"../../helpers/array/findAndSplice\";\r\n\r\nexport type Channel = Chat.channel;\r\nexport type ChatRights = keyof ChatBannedRights['pFlags'] | keyof ChatAdminRights['pFlags'] | 'change_type' | 'change_permissions' | 'delete_chat' | 'view_participants';\r\n\r\nexport class AppChatsManager {\r\n  private storage = appStateManager.storages.chats;\r\n  \r\n  private chats: {[id: ChatId]: Chat.channel | Chat.chat | any};\r\n  //private usernames: any;\r\n  //private channelAccess: any;\r\n  //private megagroups: {[id: number]: true};\r\n\r\n  constructor() {\r\n    this.clear(true);\r\n\r\n    rootScope.addMultipleEventsListeners({\r\n      /* updateChannel: (update) => {\r\n        const channelId = update.channel_id;\r\n        //console.log('updateChannel:', update);\r\n        rootScope.broadcast('channel_settings', {channelId});\r\n      }, */\r\n\r\n      updateChannelParticipant: (update) => {\r\n        apiManagerProxy.clearCache('channels.getParticipants', (params) => {\r\n          return (params.channel as InputChannel.inputChannel).channel_id === update.channel_id;\r\n        });\r\n      },\r\n\r\n      updateChatDefaultBannedRights: (update) => {\r\n        const chatId = appPeersManager.getPeerId(update.peer).toChatId();\r\n        const chat: Chat.chat = this.chats[chatId];\r\n        if(chat) {\r\n          chat.default_banned_rights = update.default_banned_rights;\r\n          rootScope.dispatchEvent('chat_update', chatId);\r\n        }\r\n      }\r\n    });\r\n\r\n    appStateManager.getState().then((state) => {\r\n      const chats = appStateManager.storagesResults.chats;\r\n      if(chats.length) {\r\n        for(let i = 0, length = chats.length; i < length; ++i) {\r\n          const chat = chats[i];\r\n          if(chat) {\r\n            this.chats[chat.id] = chat;\r\n          }\r\n        }\r\n      }\r\n\r\n      appStateManager.addEventListener('peerNeeded', (peerId) => {\r\n        if(peerId.isUser() || this.storage.getFromCache(peerId.toChatId())) {\r\n          return;\r\n        }\r\n\r\n        this.storage.set({\r\n          [peerId.toChatId()]: this.getChat(peerId.toChatId())\r\n        });\r\n      });\r\n\r\n      appStateManager.addEventListener('peerUnneeded', (peerId) => {\r\n        if(peerId.isUser() || !this.storage.getFromCache(peerId.toChatId())) {\r\n          return;\r\n        }\r\n\r\n        this.storage.delete(peerId.toChatId());\r\n      });\r\n    });\r\n  }\r\n\r\n  public clear(init = false) {\r\n    if(!init) {\r\n      const chats = appStateManager.storagesResults.chats;\r\n      for(const chatId in this.chats) {\r\n        if(!chatId) continue;\r\n        if(!appStateManager.isPeerNeeded(chatId.toPeerId(true))) {\r\n          /* const chat = this.chats[chatId];\r\n          if(chat.username) {\r\n            delete this.usernames[cleanUsername(chat.username)];\r\n          } */\r\n          \r\n          findAndSplice(chats, (chat) => chat.id === chatId);\r\n          this.storage.delete(chatId);\r\n          delete this.chats[chatId];\r\n        }\r\n      }\r\n    } else {\r\n      this.chats = {};\r\n    }\r\n  }\r\n\r\n  public saveApiChats(apiChats: any[], override?: boolean) {\r\n    if((apiChats as any).saved) return;\r\n    (apiChats as any).saved = true;\r\n    apiChats.forEach(chat => this.saveApiChat(chat, override));\r\n  }\r\n\r\n  public saveApiChat(chat: Chat, override?: boolean) {\r\n    if(chat._ === 'chatEmpty') return;\r\n    /* if(chat._ !== 'chat' && chat._ !== 'channel') {\r\n      return;\r\n    } */\r\n    \r\n    // * exclude from state\r\n    // defineNotNumerableProperties(chat, ['rTitle', 'initials']);\r\n\r\n    const oldChat: Exclude<Chat, Chat.chatEmpty> = this.chats[chat.id];\r\n\r\n    /* if(oldChat && !override) {\r\n      return;\r\n    } */\r\n\r\n    if((chat as Chat.chat).pFlags === undefined) {\r\n      (chat as Chat.chat).pFlags = {};\r\n    }\r\n\r\n    if((chat as Chat.channel).pFlags.min && oldChat !== undefined) {\r\n      return;\r\n    }\r\n\r\n    if(chat._ === 'channel' &&\r\n        chat.participants_count === undefined &&\r\n        oldChat !== undefined &&\r\n        (oldChat as Chat.channel).participants_count) {\r\n      chat.participants_count = (oldChat as Chat.channel).participants_count;\r\n    }\r\n\r\n    /* if(chat.username) {\r\n      let searchUsername = searchIndexManager.cleanUsername(chat.username);\r\n      this.usernames[searchUsername] = chat.id;\r\n    } */\r\n\r\n    let changedPhoto = false, changedTitle = false;\r\n    if(oldChat === undefined) {\r\n      this.chats[chat.id] = chat;\r\n    } else {\r\n      const oldPhotoId = ((oldChat as Chat.chat).photo as ChatPhoto.chatPhoto)?.photo_id;\r\n      const newPhotoId = ((chat as Chat.chat).photo as ChatPhoto.chatPhoto)?.photo_id;\r\n      if(oldPhotoId !== newPhotoId) {\r\n        changedPhoto = true;\r\n      }\r\n\r\n      if(oldChat.title !== chat.title) {\r\n        changedTitle = true;\r\n      }\r\n\r\n      safeReplaceObject(oldChat, chat);\r\n      rootScope.dispatchEvent('chat_update', chat.id);\r\n    }\r\n\r\n    const peerId = chat.id.toPeerId(true);\r\n    if(changedPhoto) {\r\n      rootScope.dispatchEvent('avatar_update', peerId);\r\n    }\r\n\r\n    if(changedTitle) {\r\n      rootScope.dispatchEvent('peer_title_edit', peerId);\r\n    }\r\n\r\n    if(appStateManager.isPeerNeeded(peerId)) {\r\n      this.storage.set({\r\n        [chat.id]: chat\r\n      });\r\n    }\r\n  }\r\n\r\n  public getChat(id: ChatId) {\r\n    return this.chats[id] || {_: 'chatEmpty', id, deleted: true, access_hash: '', pFlags: {}/* this.channelAccess[id] */};\r\n  }\r\n\r\n  public getChatTyped(id: ChatId): Chat {\r\n    return this.getChat(id);\r\n  }\r\n\r\n  public combineParticipantBannedRights(id: ChatId, rights: ChatBannedRights) {\r\n    const chat: Chat.channel = this.getChat(id);\r\n\r\n    if(chat.default_banned_rights) {\r\n      rights = copy(rights);\r\n      const defaultRights = chat.default_banned_rights.pFlags;\r\n      for(let i in defaultRights) {\r\n        // @ts-ignore\r\n        rights.pFlags[i] = defaultRights[i];\r\n      }\r\n    }\r\n\r\n    return rights;\r\n  }\r\n\r\n  /**\r\n   * Check the user's ability to do an action in chat\r\n   * @param id \r\n   * @param action creator can still send messages to left channel. so this function shows server rights. see canSendToPeer for local rights in messages manager.\r\n   * @param rights do not provide this parameter when checking rights for self\r\n   * @param isThread \r\n   * @returns \r\n   */\r\n  public hasRights(id: ChatId, action: ChatRights, rights?: ChatAdminRights | ChatBannedRights, isThread?: boolean) {\r\n    const chat: Chat = this.getChat(id);\r\n    if(chat._ === 'chatEmpty') return false;\r\n\r\n    if((chat as Chat.chat).pFlags.deactivated && action !== 'view_messages') {\r\n      return false;\r\n    }\r\n\r\n    const isCheckingRightsForSelf = rights === undefined;\r\n    if((chat as Chat.chat).pFlags.creator && isCheckingRightsForSelf) {\r\n      return true;\r\n    }\r\n\r\n    if(chat._ === 'chatForbidden' ||\r\n        chat._ === 'channelForbidden' ||\r\n        // (chat as any).pFlags.kicked ||\r\n        (chat.pFlags.left && !(chat as Chat.channel).pFlags.megagroup)) {\r\n      return false;\r\n    }\r\n\r\n    // const adminRights = chat.admin_rights;\r\n    // const bannedRights = (chat as Chat.channel).banned_rights || chat.default_banned_rights;\r\n\r\n    if(!rights) {\r\n      rights = chat.admin_rights || (chat as Chat.channel).banned_rights || chat.default_banned_rights;\r\n\r\n      if(!rights) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    let myFlags: Partial<{[flag in keyof ChatBannedRights['pFlags'] | keyof ChatAdminRights['pFlags']]: true}> = {};\r\n    if(rights) {\r\n      myFlags = rights.pFlags as any;\r\n    }\r\n\r\n    // const adminFlags = adminRights?.pFlags || {};\r\n    // const bannedFlags = bannedRights?.pFlags || {};\r\n\r\n    switch(action) {\r\n      case 'embed_links':\r\n      case 'send_games':\r\n      case 'send_gifs':\r\n      case 'send_inline':\r\n      case 'send_media':\r\n      case 'send_messages':\r\n      case 'send_polls':\r\n      case 'send_stickers': {\r\n        if(!isThread && chat.pFlags.left) {\r\n          return false;\r\n        }\r\n\r\n        if(rights._ === 'chatBannedRights' && myFlags[action]) {\r\n          return false;\r\n        }\r\n\r\n        if(chat._ === 'channel') {\r\n          if(!chat.pFlags.megagroup && !myFlags.post_messages) {\r\n            return false;\r\n          }\r\n        }\r\n\r\n        break;\r\n      }\r\n\r\n      // * revoke foreign messages\r\n      case 'delete_messages':\r\n      case 'manage_call': {\r\n        return !!myFlags[action];\r\n      }\r\n\r\n      case 'pin_messages': {\r\n        return rights._ === 'chatAdminRights' ? myFlags[action] || !!myFlags.post_messages : !myFlags[action];\r\n      }\r\n\r\n      // case 'change_info': {\r\n        // return adminRights || isCheckingRightsForSelf ? adminFlags[action] : !myFlags[action];\r\n      // }\r\n\r\n      case 'change_info':\r\n      case 'invite_users': {\r\n        return rights._ === 'chatAdminRights' ? myFlags[action] : !myFlags[action];\r\n      }\r\n\r\n      // * only creator can do that\r\n      case 'change_type':\r\n      case 'delete_chat': {\r\n        return false;\r\n      }\r\n\r\n      case 'ban_users':\r\n      case 'change_permissions': {\r\n        return rights._ === 'chatAdminRights' && !!myFlags['ban_users'];\r\n      }\r\n\r\n      case 'view_participants': {\r\n        return !!(chat._ === 'chat' || !chat.pFlags.broadcast || chat.pFlags.creator || chat.admin_rights);\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  public editChatDefaultBannedRights(id: ChatId, banned_rights: ChatBannedRights) {\r\n    const chat: Chat.chat = this.getChat(id);\r\n    if(chat.default_banned_rights) {\r\n      if(chat.default_banned_rights.until_date === banned_rights.until_date && deepEqual(chat.default_banned_rights.pFlags, banned_rights.pFlags)) {\r\n        return Promise.resolve();\r\n      }\r\n    }\r\n    \r\n    return apiManager.invokeApi('messages.editChatDefaultBannedRights', {\r\n      peer: appPeersManager.getInputPeerById(id.toPeerId(true)),\r\n      banned_rights\r\n    }).then(this.onChatUpdated.bind(this, id));\r\n  }\r\n\r\n  /* public resolveUsername(username: string) {\r\n    return this.usernames[username] || 0;\r\n  } */\r\n\r\n  /* public saveChannelAccess(id: ChatId, accessHash: string) {\r\n    this.channelAccess[id] = accessHash;\r\n  } */\r\n\r\n  /* public saveIsMegagroup(id: ChatId) {\r\n    this.megagroups[id] = true;\r\n  } */\r\n\r\n  public isChannel(id: ChatId) {\r\n    const chat = this.chats[id];\r\n    return !!(chat && (chat._ === 'channel' || chat._ === 'channelForbidden')/*  || this.channelAccess[id] */);\r\n  }\r\n\r\n  public isMegagroup(id: ChatId) {\r\n    /* if(this.megagroups[id]) {\r\n      return true;\r\n    } */\r\n\r\n    const chat: Chat = this.chats[id];\r\n    return !!(chat && chat._ === 'channel' && chat.pFlags.megagroup);\r\n  }\r\n\r\n  public isBroadcast(id: ChatId) {\r\n    return this.isChannel(id) && !this.isMegagroup(id);\r\n  }\r\n\r\n  public isInChat(id: ChatId) {\r\n    let good = true;\r\n    const chat: Chat = this.getChat(id);\r\n    if(chat._ === 'channelForbidden' \r\n      || chat._ === 'chatForbidden' \r\n      || chat._ === 'chatEmpty' \r\n      || (chat as Chat.chat).pFlags.left \r\n      // || (chat as any).pFlags.kicked \r\n      || (chat as Chat.chat).pFlags.deactivated) {\r\n      good = false;\r\n    }\r\n\r\n    return good;\r\n  }\r\n\r\n  public getChannelInput(id: ChatId): InputChannel {\r\n    const chat: Chat = this.getChat(id);\r\n    if(chat._ === 'chatEmpty' || !(chat as Chat.channel).access_hash) {\r\n      return {\r\n        _: 'inputChannelEmpty'\r\n      };\r\n    } else {\r\n      return {\r\n        _: 'inputChannel',\r\n        channel_id: id,\r\n        access_hash: (chat as Chat.channel).access_hash/*  || this.channelAccess[id] */ || '0'\r\n      };\r\n    }\r\n  }\r\n\r\n  public getInputPeer(id: ChatId) {\r\n    return this.isChannel(id) ? this.getChannelInputPeer(id) : this.getChatInputPeer(id);\r\n  }\r\n\r\n  public getChatInputPeer(id: ChatId): InputPeer.inputPeerChat {\r\n    return {\r\n      _: 'inputPeerChat',\r\n      chat_id: id\r\n    };\r\n  }\r\n\r\n  public getChannelInputPeer(id: ChatId): InputPeer.inputPeerChannel {\r\n    return {\r\n      _: 'inputPeerChannel',\r\n      channel_id: id,\r\n      access_hash: this.getChat(id).access_hash/*  || this.channelAccess[id] */ || 0\r\n    };\r\n  }\r\n\r\n  public hasChat(id: ChatId, allowMin?: true) {\r\n    const chat = this.chats[id];\r\n    return isObject(chat) && (allowMin || !chat.pFlags.min);\r\n  }\r\n\r\n  public getChatPhoto(id: ChatId) {\r\n    const chat: Chat.chat = this.getChat(id);\r\n\r\n    return chat && chat.photo || {\r\n      _: 'chatPhotoEmpty'\r\n    };\r\n  }\r\n\r\n  public getChatString(id: ChatId) {\r\n    const chat = this.getChat(id);\r\n    if(this.isChannel(id)) {\r\n      return (this.isMegagroup(id) ? 's' : 'c') + id + '_' + chat.access_hash;\r\n    }\r\n    return 'g' + id;\r\n  }\r\n\r\n  /* public wrapForFull(id: number, fullChat: any) {\r\n    const chatFull = copy(fullChat);\r\n    const chat = this.getChat(id);\r\n\r\n    if(!chatFull.participants_count) {\r\n      chatFull.participants_count = chat.participants_count;\r\n    }\r\n\r\n    if(chatFull.participants &&\r\n        chatFull.participants._ === 'chatParticipants') {\r\n      chatFull.participants.participants = this.wrapParticipants(id, chatFull.participants.participants);\r\n    }\r\n\r\n    if(chatFull.about) {\r\n      chatFull.rAbout = RichTextProcessor.wrapRichText(chatFull.about, {noLinebreaks: true});\r\n    }\r\n\r\n    //chatFull.peerString = this.getChatString(id);\r\n    chatFull.chat = chat;\r\n\r\n    return chatFull;\r\n  }\r\n\r\n  public wrapParticipants(id: number, participants: any[]) {\r\n    const chat = this.getChat(id);\r\n    const myId = appUsersManager.getSelf().id;\r\n    if(this.isChannel(id)) {\r\n      const isAdmin = chat.pFlags.creator;\r\n      participants.forEach((participant) => {\r\n        participant.canLeave = myId === participant.user_id;\r\n        participant.canKick = isAdmin && participant._ === 'channelParticipant';\r\n\r\n        // just for order by last seen\r\n        participant.user = appUsersManager.getUser(participant.user_id);\r\n      });\r\n    } else {\r\n      const isAdmin = chat.pFlags.creator || chat.pFlags.admins_enabled && chat.pFlags.admin;\r\n      participants.forEach((participant) => {\r\n        participant.canLeave = myId === participant.user_id;\r\n        participant.canKick = !participant.canLeave && (\r\n          chat.pFlags.creator ||\r\n          participant._ === 'chatParticipant' && (isAdmin || myId === participant.inviter_id)\r\n        );\r\n\r\n        // just for order by last seen\r\n        participant.user = appUsersManager.getUser(participant.user_id);\r\n      });\r\n    }\r\n\r\n    return participants;\r\n  } */\r\n\r\n  public createChannel(options: ChannelsCreateChannel): Promise<ChatId> {\r\n    return apiManager.invokeApi('channels.createChannel', options).then((updates) => {\r\n      apiUpdatesManager.processUpdateMessage(updates);\r\n\r\n      const channelId = (updates as any).chats[0].id;\r\n      rootScope.dispatchEvent('history_focus', {peerId: channelId.toPeerId(true)});\r\n\r\n      return channelId;\r\n    });\r\n  }\r\n\r\n  public inviteToChannel(id: ChatId, userIds: UserId[]) {\r\n    const input = this.getChannelInput(id);\r\n    const usersInputs = userIds.map(u => appUsersManager.getUserInput(u));\r\n\r\n    return apiManager.invokeApi('channels.inviteToChannel', {\r\n      channel: input,\r\n      users: usersInputs\r\n    }).then(this.onChatUpdated.bind(this, id));\r\n  }\r\n\r\n  public createChat(title: string, userIds: UserId[]): Promise<ChatId> {\r\n    return apiManager.invokeApi('messages.createChat', {\r\n      users: userIds.map(u => appUsersManager.getUserInput(u)),\r\n      title\r\n    }).then(updates => {\r\n      apiUpdatesManager.processUpdateMessage(updates);\r\n\r\n      const chatId = (updates as any as Updates.updates).chats[0].id;\r\n      rootScope.dispatchEvent('history_focus', {peerId: chatId.toPeerId(true)});\r\n\r\n      return chatId;\r\n    });\r\n  }\r\n\r\n  private onChatUpdated = (chatId: ChatId, updates?: any) => {\r\n    //console.log('onChatUpdated', chatId, updates);\r\n\r\n    apiUpdatesManager.processUpdateMessage(updates);\r\n    if(updates?.updates?.length && this.isChannel(chatId)) {\r\n      rootScope.dispatchEvent('invalidate_participants', chatId);\r\n    }\r\n  };\r\n\r\n  public leaveChannel(id: ChatId) {\r\n    return apiManager.invokeApi('channels.leaveChannel', {\r\n      channel: this.getChannelInput(id)\r\n    }).then(this.onChatUpdated.bind(this, id));\r\n  }\r\n\r\n  public joinChannel(id: ChatId) {\r\n    return apiManager.invokeApi('channels.joinChannel', {\r\n      channel: this.getChannelInput(id)\r\n    }).then(this.onChatUpdated.bind(this, id));\r\n  }\r\n\r\n  public addChatUser(id: ChatId, userId: UserId, fwdLimit = 100) {\r\n    return apiManager.invokeApi('messages.addChatUser', {\r\n      chat_id: id,\r\n      user_id: appUsersManager.getUserInput(userId),\r\n      fwd_limit: fwdLimit\r\n    }).then(this.onChatUpdated.bind(this, id));\r\n  }\r\n\r\n  public deleteChatUser(id: ChatId, userId: UserId) {\r\n    return apiManager.invokeApi('messages.deleteChatUser', {\r\n      chat_id: id,\r\n      user_id: appUsersManager.getUserInput(userId)\r\n    }).then(this.onChatUpdated.bind(this, id));\r\n  }\r\n\r\n  public leaveChat(id: ChatId) {\r\n    return this.deleteChatUser(id, appUsersManager.getSelf().id);\r\n  }\r\n\r\n  public leave(id: ChatId) {\r\n    return this.isChannel(id) ? this.leaveChannel(id) : this.leaveChat(id);\r\n  }\r\n\r\n  public delete(id: ChatId) {\r\n    return this.isChannel(id) ? this.deleteChannel(id) : this.deleteChat(id);\r\n  }\r\n\r\n  public deleteChannel(id: ChatId) {\r\n    return apiManager.invokeApi('channels.deleteChannel', {\r\n      channel: this.getChannelInput(id)\r\n    }).then(this.onChatUpdated.bind(this, id));\r\n  }\r\n\r\n  public deleteChat(id: ChatId) {\r\n    //return this.leaveChat(id).then(() => {\r\n      return apiManager.invokeApi('messages.deleteChat', {\r\n        chat_id: id\r\n      });\r\n    //});\r\n  }\r\n\r\n  public migrateChat(id: ChatId): Promise<ChatId> {\r\n    const chat: Chat = this.getChat(id);\r\n    if(chat._ === 'channel') return Promise.resolve(chat.id);\r\n    return apiManager.invokeApi('messages.migrateChat', {\r\n      chat_id: id\r\n    }).then((updates) => {\r\n      this.onChatUpdated(id, updates);\r\n      const update: Update.updateChannel = (updates as Updates.updates).updates.find(u => u._ === 'updateChannel') as any;\r\n      return update.channel_id;\r\n    });\r\n  }\r\n\r\n  public updateUsername(id: ChatId, username: string) {\r\n    return apiManager.invokeApi('channels.updateUsername', {\r\n      channel: this.getChannelInput(id),\r\n      username\r\n    }).then((bool) => {\r\n      if(bool) {\r\n        const chat: Chat.channel = this.getChat(id);\r\n        chat.username = username;\r\n      }\r\n\r\n      return bool;\r\n    });\r\n  }\r\n\r\n  public editPhoto(id: ChatId, inputFile: InputFile) {\r\n    const inputChatPhoto: InputChatPhoto = {\r\n      _: 'inputChatUploadedPhoto',\r\n      file: inputFile\r\n    };\r\n\r\n    let promise: any;\r\n    if(this.isChannel(id)) {\r\n      promise = apiManager.invokeApi('channels.editPhoto', {\r\n        channel: this.getChannelInput(id),\r\n        photo: inputChatPhoto\r\n      });\r\n    } else {\r\n      promise = apiManager.invokeApi('messages.editChatPhoto', {\r\n        chat_id: id,\r\n        photo: inputChatPhoto\r\n      });\r\n    }\r\n\r\n    return promise.then((updates: any) => {\r\n      apiUpdatesManager.processUpdateMessage(updates);\r\n    });\r\n  }\r\n\r\n  public editTitle(id: ChatId, title: string) {\r\n    let promise: any;\r\n\r\n    if(this.isChannel(id)) {\r\n      promise = apiManager.invokeApi('channels.editTitle', {\r\n        channel: this.getChannelInput(id),\r\n        title\r\n      });\r\n    } else {\r\n      promise = apiManager.invokeApi('messages.editChatTitle', {\r\n        chat_id: id,\r\n        title\r\n      });\r\n    }\r\n\r\n    return promise.then((updates: any) => {\r\n      apiUpdatesManager.processUpdateMessage(updates);\r\n    });\r\n  }\r\n\r\n  public editAbout(id: ChatId, about: string) {\r\n    const peerId = id.toPeerId(true);\r\n    return apiManager.invokeApi('messages.editChatAbout', {\r\n      peer: appPeersManager.getInputPeerById(peerId),\r\n      about\r\n    }).then(bool => {\r\n      if(bool) {\r\n        rootScope.dispatchEvent('peer_bio_edit', peerId);\r\n      }\r\n\r\n      return bool;\r\n    });\r\n  }\r\n\r\n  public getParticipantPeerId(participant: ChannelParticipant | ChatParticipant): PeerId {\r\n    const peerId = (participant as ChannelParticipant.channelParticipantBanned).peer ? \r\n      appPeersManager.getPeerId((participant as ChannelParticipant.channelParticipantBanned).peer) : \r\n      (participant as ChatParticipant.chatParticipant).user_id.toPeerId();\r\n    return peerId;\r\n  }\r\n\r\n  public editBanned(id: ChatId, participant: PeerId | ChannelParticipant, banned_rights: ChatBannedRights) {\r\n    const peerId = typeof(participant) !== 'object' ? participant : this.getParticipantPeerId(participant);\r\n    return apiManager.invokeApi('channels.editBanned', {\r\n      channel: this.getChannelInput(id),\r\n      participant: appPeersManager.getInputPeerById(peerId),\r\n      banned_rights\r\n    }).then((updates) => {\r\n      this.onChatUpdated(id, updates);\r\n\r\n      if(typeof(participant) === 'object') {\r\n        const timestamp = Date.now() / 1000 | 0;\r\n        apiUpdatesManager.processLocalUpdate({\r\n          _: 'updateChannelParticipant',\r\n          channel_id: id,\r\n          date: timestamp,\r\n          actor_id: undefined,\r\n          qts: undefined,\r\n          user_id: peerId,\r\n          prev_participant: participant,\r\n          new_participant: Object.keys(banned_rights.pFlags).length ? {\r\n            _: 'channelParticipantBanned',\r\n            date: timestamp,\r\n            banned_rights,\r\n            kicked_by: appUsersManager.getSelf().id,\r\n            peer: appPeersManager.getOutputPeer(peerId),\r\n            pFlags: {}\r\n          } : undefined\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  public clearChannelParticipantBannedRights(id: ChatId, participant: PeerId | ChannelParticipant) {\r\n    return this.editBanned(id, participant, {\r\n      _: 'chatBannedRights',\r\n      until_date: 0,\r\n      pFlags: {}\r\n    });\r\n  }\r\n  \r\n  public kickFromChannel(id: ChatId, participant: PeerId | ChannelParticipant) {\r\n    return this.editBanned(id, participant, {\r\n      _: 'chatBannedRights',\r\n      until_date: 0,\r\n      pFlags: {\r\n        view_messages: true\r\n      }\r\n    });\r\n  }\r\n\r\n  public kickFromChat(id: ChatId, participant: PeerId | ChannelParticipant) {\r\n    if(this.isChannel(id)) return this.kickFromChannel(id, participant);\r\n    else return this.deleteChatUser(id, (participant as PeerId).toUserId());\r\n  }\r\n\r\n  public resolveChannel(id: ChatId) {\r\n    return apiManager.invokeApiSingle('channels.getChannels', {\r\n      id: [{\r\n        _: 'inputChannel',\r\n        channel_id: id,\r\n        access_hash: '0'\r\n      }]\r\n    }).then(messagesChats => {\r\n      this.saveApiChats(messagesChats.chats);\r\n    });\r\n  }\r\n\r\n  public togglePreHistoryHidden(id: ChatId, enabled: boolean) {\r\n    return this.migrateChat(id).then(channelId => {\r\n      return apiManager.invokeApi('channels.togglePreHistoryHidden', {\r\n        channel: this.getChannelInput(channelId),\r\n        enabled\r\n      });\r\n    }).then(updates => {\r\n      apiUpdatesManager.processUpdateMessage(updates);\r\n    });\r\n  }\r\n\r\n  public toggleSignatures(id: ChatId, enabled: boolean) {\r\n    return apiManager.invokeApi('channels.toggleSignatures', {\r\n      channel: this.getChannelInput(id),\r\n      enabled\r\n    }).then(updates => {\r\n      apiUpdatesManager.processUpdateMessage(updates);\r\n    });\r\n  }\r\n\r\n  public toggleNoForwards(id: ChatId, enabled: boolean) {\r\n    return apiManager.invokeApi('messages.toggleNoForwards', {\r\n      peer: this.getInputPeer(id),\r\n      enabled\r\n    }).then(updates => {\r\n      apiUpdatesManager.processUpdateMessage(updates);\r\n    });\r\n  }\r\n\r\n  public setChatAvailableReactions(id: ChatId, reactions: Array<string>) {\r\n    return apiManager.invokeApi('messages.setChatAvailableReactions', {\r\n      peer: this.getInputPeer(id),\r\n      available_reactions: reactions\r\n    }).then(updates => {\r\n      apiUpdatesManager.processUpdateMessage(updates);\r\n    });\r\n  }\r\n\r\n  public isRestricted(chatId: ChatId) {\r\n    const chat: Chat.channel = this.getChat(chatId);\r\n    const restrictionReasons = chat.restriction_reason;\r\n\r\n    return !!(chat.pFlags.restricted && restrictionReasons && isRestricted(restrictionReasons));\r\n  }\r\n\r\n  public getSendAs(channelId: ChatId) {\r\n    return apiManager.invokeApiSingleProcess({\r\n      method: 'channels.getSendAs', \r\n      params: {\r\n        peer: this.getChannelInputPeer(channelId)\r\n      },\r\n      processResult: (sendAsPeers) => {\r\n        appUsersManager.saveApiUsers(sendAsPeers.users);\r\n        appChatsManager.saveApiChats(sendAsPeers.chats);\r\n\r\n        return sendAsPeers.peers;\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nconst appChatsManager = new AppChatsManager();\r\nMOUNT_CLASS_TO.appChatsManager = appChatsManager;\r\nexport default appChatsManager;\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport { MOUNT_CLASS_TO } from \"../config/debug\";\r\nimport appPeersManager from \"../lib/appManagers/appPeersManager\";\r\nimport rootScope from \"../lib/rootScope\";\r\nimport { i18n } from \"../lib/langPack\";\r\nimport replaceContent from \"../helpers/dom/replaceContent\";\r\nimport appUsersManager from \"../lib/appManagers/appUsersManager\";\r\nimport RichTextProcessor from \"../lib/richtextprocessor\";\r\nimport { NULL_PEER_ID } from \"../lib/mtproto/mtproto_config\";\r\nimport limitSymbols from \"../helpers/string/limitSymbols\";\r\nimport setInnerHTML from \"../helpers/dom/setInnerHTML\";\r\n\r\nexport type PeerTitleOptions = {\r\n  peerId?: PeerId,\r\n  fromName?: string,\r\n  plainText?: boolean,\r\n  onlyFirstName?: boolean,\r\n  dialog?: boolean,\r\n  limitSymbols?: number\r\n};\r\n\r\nconst weakMap: WeakMap<HTMLElement, PeerTitle> = new WeakMap();\r\n\r\nMOUNT_CLASS_TO.peerTitleWeakMap = weakMap;\r\n\r\nrootScope.addEventListener('peer_title_edit', (peerId) => {\r\n  const elements = Array.from(document.querySelectorAll(`.peer-title[data-peer-id=\"${peerId}\"]`)) as HTMLElement[];\r\n  elements.forEach(element => {\r\n    const peerTitle = weakMap.get(element);\r\n    //console.log('in the summer silence i was doing nothing', peerTitle, peerId);\r\n\r\n    if(peerTitle) {\r\n      peerTitle.update();\r\n    }\r\n  });\r\n});\r\n\r\nexport default class PeerTitle {\r\n  public element: HTMLElement;\r\n  public peerId: PeerId;\r\n  public fromName: string;\r\n  public plainText = false;\r\n  public onlyFirstName = false;\r\n  public dialog = false;\r\n  public limitSymbols: number;\r\n\r\n  constructor(options: PeerTitleOptions) {\r\n    this.element = document.createElement('span');\r\n    this.element.classList.add('peer-title');\r\n    this.element.setAttribute('dir', 'auto');\r\n    \r\n    this.update(options);\r\n    weakMap.set(this.element, this);\r\n  }\r\n\r\n  public update(options?: PeerTitleOptions) {\r\n    if(options) {\r\n      for(let i in options) {\r\n        // @ts-ignore\r\n        this.element.dataset[i] = options[i] ? '' + (typeof(options[i]) === 'boolean' ? +options[i] : options[i]) : '0';\r\n        // @ts-ignore\r\n        this[i] = options[i];\r\n      }\r\n    }\r\n\r\n    let fromName = this.fromName;\r\n    if(fromName !== undefined) {\r\n      if(this.limitSymbols !== undefined) {\r\n        fromName = limitSymbols(fromName, this.limitSymbols, this.limitSymbols);\r\n      }\r\n\r\n      setInnerHTML(this.element, RichTextProcessor.wrapEmojiText(fromName));\r\n      return;\r\n    }\r\n\r\n    if(this.peerId === undefined) {\r\n      this.peerId = NULL_PEER_ID;\r\n    }\r\n\r\n    if(this.peerId !== rootScope.myId || !this.dialog) {\r\n      if(this.peerId.isUser() && appUsersManager.getUser(this.peerId).pFlags.deleted) {\r\n        replaceContent(this.element, i18n(this.onlyFirstName ? 'Deleted' : 'HiddenName'));\r\n      } else {\r\n        setInnerHTML(this.element, appPeersManager.getPeerTitle(this.peerId, this.plainText, this.onlyFirstName, this.limitSymbols));\r\n      }\r\n    } else {\r\n      replaceContent(this.element, i18n(this.onlyFirstName ? 'Saved' : 'SavedMessages'));\r\n    }\r\n  }\r\n}\r\n","export default function bytesFromHex(hexString: string) {\r\n  const len = hexString.length;\r\n  const bytes = new Uint8Array(Math.ceil(len / 2));\r\n  let start = 0;\r\n\r\n  if(len % 2) { // read 0x581 as 0x0581\r\n    bytes[start++] = parseInt(hexString.charAt(0), 16);\r\n  }\r\n\r\n  for(let i = start; i < len; i += 2) {\r\n    bytes[start++] = parseInt(hexString.substr(i, 2), 16);\r\n  }\r\n\r\n  return bytes;\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n * \r\n * Originally from:\r\n * https://github.com/zhukov/webogram\r\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\r\n * https://github.com/zhukov/webogram/blob/master/LICENSE\r\n */\r\n\r\nimport type { DownloadOptions } from \"../mtproto/apiFileManager\";\r\nimport { CancellablePromise } from \"../../helpers/cancellablePromise\";\r\nimport { getFileNameByLocation } from \"../../helpers/fileName\";\r\nimport { IS_SAFARI } from \"../../environment/userAgent\";\r\nimport { InputFileLocation, InputMedia, InputPhoto, Photo, PhotoSize, PhotosPhotos } from \"../../layer\";\r\nimport apiManager from \"../mtproto/mtprotoworker\";\r\nimport referenceDatabase, { ReferenceContext } from \"../mtproto/referenceDatabase\";\r\nimport { MyDocument } from \"./appDocsManager\";\r\nimport appDownloadManager, { ThumbCache } from \"./appDownloadManager\";\r\nimport appUsersManager from \"./appUsersManager\";\r\nimport blur from \"../../helpers/blur\";\r\nimport { MOUNT_CLASS_TO } from \"../../config/debug\";\r\nimport { renderImageFromUrlPromise } from \"../../helpers/dom/renderImageFromUrl\";\r\nimport calcImageInBox from \"../../helpers/calcImageInBox\";\r\nimport { makeMediaSize, MediaSize } from \"../../helpers/mediaSizes\";\r\nimport windowSize from \"../../helpers/windowSize\";\r\nimport bytesFromHex from \"../../helpers/bytes/bytesFromHex\";\r\nimport isObject from \"../../helpers/object/isObject\";\r\nimport safeReplaceArrayInObject from \"../../helpers/object/safeReplaceArrayInObject\";\r\nimport bytesToDataURL from \"../../helpers/bytes/bytesToDataURL\";\r\nimport { REPLIES_HIDDEN_CHANNEL_ID } from \"../mtproto/mtproto_config\";\r\n\r\nexport type MyPhoto = Photo.photo;\r\n\r\n// TIMES = 2 DUE TO SIDEBAR AND CHAT\r\n//let TEST_FILE_REFERENCE = \"5440692274120994569\", TEST_FILE_REFERENCE_TIMES = 2;\r\n\r\nexport class AppPhotosManager {\r\n  private photos: {\r\n    [id: string]: MyPhoto\r\n  } = {};\r\n\r\n  private static jpegHeader = bytesFromHex('ffd8ffe000104a46494600010100000100010000ffdb004300281c1e231e19282321232d2b28303c64413c37373c7b585d4964918099968f808c8aa0b4e6c3a0aadaad8a8cc8ffcbdaeef5ffffff9bc1fffffffaffe6fdfff8ffdb0043012b2d2d3c353c76414176f8a58ca5f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8ffc00011080000000003012200021101031101ffc4001f0000010501010101010100000000000000000102030405060708090a0bffc400b5100002010303020403050504040000017d01020300041105122131410613516107227114328191a1082342b1c11552d1f02433627282090a161718191a25262728292a3435363738393a434445464748494a535455565758595a636465666768696a737475767778797a838485868788898a92939495969798999aa2a3a4a5a6a7a8a9aab2b3b4b5b6b7b8b9bac2c3c4c5c6c7c8c9cad2d3d4d5d6d7d8d9dae1e2e3e4e5e6e7e8e9eaf1f2f3f4f5f6f7f8f9faffc4001f0100030101010101010101010000000000000102030405060708090a0bffc400b51100020102040403040705040400010277000102031104052131061241510761711322328108144291a1b1c109233352f0156272d10a162434e125f11718191a262728292a35363738393a434445464748494a535455565758595a636465666768696a737475767778797a82838485868788898a92939495969798999aa2a3a4a5a6a7a8a9aab2b3b4b5b6b7b8b9bac2c3c4c5c6c7c8c9cad2d3d4d5d6d7d8d9dae2e3e4e5e6e7e8e9eaf2f3f4f5f6f7f8f9faffda000c03010002110311003f00');\r\n  private static jpegTail = bytesFromHex('ffd9');\r\n  \r\n  public savePhoto(photo: Photo, context?: ReferenceContext) {\r\n    if(photo._ === 'photoEmpty') return undefined;\r\n\r\n    /* if(photo.id === TEST_FILE_REFERENCE) {\r\n      console.warn('Testing FILE_REFERENCE_EXPIRED');\r\n      const bytes = [2, 67, 175, 43, 190, 0, 0, 20, 62, 95, 111, 33, 45, 99, 220, 116, 218, 11, 167, 127, 213, 18, 127, 32, 243, 202, 117, 80, 30];\r\n      //photo.file_reference = new Uint8Array(bytes);\r\n      photo.file_reference = bytes;\r\n      if(!--TEST_FILE_REFERENCE_TIMES) {\r\n        TEST_FILE_REFERENCE = '';\r\n      }\r\n    } */\r\n\r\n    const oldPhoto = this.photos[photo.id];\r\n    if(photo.file_reference) { // * because we can have a new object w/o the file_reference while sending\r\n      safeReplaceArrayInObject('file_reference', oldPhoto, photo);\r\n      referenceDatabase.saveContext(photo.file_reference, context);\r\n    }\r\n\r\n    if(photo.sizes?.length) {\r\n      const size = photo.sizes[photo.sizes.length - 1];\r\n      if(size._ === 'photoSizeProgressive') {\r\n        size.size = size.sizes[size.sizes.length - 1];\r\n      }\r\n    }\r\n\r\n    if(oldPhoto) {\r\n      return Object.assign(oldPhoto, photo);\r\n    }\r\n\r\n    return this.photos[photo.id] = photo;\r\n  }\r\n  \r\n  public choosePhotoSize(photo: MyPhoto | MyDocument, boxWidth = 0, boxHeight = 0, useBytes = false, pushDocumentSize = false) {\r\n    if(window.devicePixelRatio > 1) {\r\n      boxWidth *= 2;\r\n      boxHeight *= 2;\r\n    }\r\n    \r\n    /*\r\n    s\tbox\t100x100\r\n    m\tbox\t320x320\r\n    x\tbox\t800x800\r\n    y\tbox\t1280x1280\r\n    w\tbox\t2560x2560\r\n    a\tcrop\t160x160\r\n    b\tcrop\t320x320\r\n    c\tcrop\t640x640\r\n    d\tcrop\t1280x1280 */\r\n\r\n    let bestPhotoSize: PhotoSize = {_: 'photoSizeEmpty', type: ''};\r\n    let sizes = (photo as MyPhoto).sizes || (photo as MyDocument).thumbs as PhotoSize[];\r\n    if(pushDocumentSize && sizes && photo._ === 'document') {\r\n      sizes = sizes.concat({\r\n        _: 'photoSize', \r\n        w: (photo as MyDocument).w, \r\n        h: (photo as MyDocument).h, \r\n        size: (photo as MyDocument).size, \r\n        type: undefined\r\n      });\r\n    }\r\n\r\n    if(sizes?.length) {\r\n      for(let i = 0, length = sizes.length; i < length; ++i) {\r\n        const photoSize = sizes[i];\r\n        if(!('w' in photoSize) && !('h' in photoSize)) continue;\r\n  \r\n        bestPhotoSize = photoSize;\r\n  \r\n        const size = calcImageInBox(photoSize.w, photoSize.h, boxWidth, boxHeight);\r\n        if(size.width >= boxWidth || size.height >= boxHeight) {\r\n          break;\r\n        }\r\n      }\r\n\r\n      if(useBytes && bestPhotoSize._ === 'photoSizeEmpty' && sizes[0]._ === 'photoStrippedSize') {\r\n        bestPhotoSize = sizes[0];\r\n      }\r\n    }\r\n    \r\n    return bestPhotoSize;\r\n  }\r\n  \r\n  public getUserPhotos(userId: UserId, maxId: Photo.photo['id'] = '0', limit: number = 20) {\r\n    const inputUser = appUsersManager.getUserInput(userId);\r\n    return apiManager.invokeApiCacheable('photos.getUserPhotos', {\r\n      user_id: inputUser,\r\n      offset: 0,\r\n      limit,\r\n      max_id: maxId\r\n    }, {cacheSeconds: 60}).then((photosResult) => {\r\n      appUsersManager.saveApiUsers(photosResult.users);\r\n      const photoIds = photosResult.photos.map((photo, idx) => {\r\n        photosResult.photos[idx] = this.savePhoto(photo, {type: 'profilePhoto', peerId: userId.toPeerId()});\r\n        return photo.id;\r\n      });\r\n\r\n      // ! WARNING !\r\n      if(maxId !== '0' && maxId) {\r\n        const idx = photoIds.indexOf(maxId);\r\n        if(idx !== -1) {\r\n          photoIds.splice(idx, 1);\r\n        }\r\n      }\r\n      \r\n      return {\r\n        count: (photosResult as PhotosPhotos.photosPhotosSlice).count || photoIds.length,\r\n        photos: photoIds\r\n      };\r\n    });\r\n  }\r\n\r\n  public getPreviewURLFromBytes(bytes: Uint8Array | number[], isSticker = false) {\r\n    let arr: Uint8Array;\r\n    if(!isSticker) {\r\n      arr = new Uint8Array(AppPhotosManager.jpegHeader.concat(Array.from(bytes.slice(3)), AppPhotosManager.jpegTail));\r\n      arr[164] = bytes[1];\r\n      arr[166] = bytes[2];\r\n    } else {\r\n      arr = bytes instanceof Uint8Array ? bytes : new Uint8Array(bytes);\r\n    }\r\n\r\n    let mimeType: string;\r\n    if(isSticker) {\r\n      mimeType = IS_SAFARI ? 'image/png' : 'image/webp';\r\n    } else {\r\n      mimeType = 'image/jpeg';\r\n    }\r\n\r\n    return bytesToDataURL(arr, mimeType);\r\n  }\r\n\r\n  /**\r\n   * https://core.telegram.org/api/files#vector-thumbnails\r\n   */\r\n  public getPathFromPhotoPathSize(size: PhotoSize.photoPathSize) {\r\n    const bytes = size.bytes;\r\n    const lookup = \"AACAAAAHAAALMAAAQASTAVAAAZaacaaaahaaalmaaaqastava.az0123456789-,\";\r\n\r\n    let path = 'M';\r\n    for(let i = 0, length = bytes.length; i < length; ++i) {\r\n      const num = bytes[i];\r\n\r\n      if(num >= (128 + 64)) {\r\n        path += lookup[num - 128 - 64];\r\n      } else {\r\n        if(num >= 128) {\r\n          path += ',';\r\n        } else if(num >= 64) {\r\n          path += '-'; \r\n        }\r\n        path += '' + (num & 63);\r\n      }\r\n    }\r\n    path += 'z';\r\n\r\n    return path;\r\n  }\r\n\r\n  public getPreviewURLFromThumb(photo: MyPhoto | MyDocument, thumb: PhotoSize.photoCachedSize | PhotoSize.photoStrippedSize, isSticker = false) {\r\n    const cacheContext = appDownloadManager.getCacheContext(photo, thumb.type);\r\n    return cacheContext.url || (cacheContext.url = this.getPreviewURLFromBytes(thumb.bytes, isSticker));\r\n  }\r\n  \r\n  public getImageFromStrippedThumb(photo: MyPhoto | MyDocument, thumb: PhotoSize.photoCachedSize | PhotoSize.photoStrippedSize, useBlur: boolean) {\r\n    const url = this.getPreviewURLFromThumb(photo, thumb, false);\r\n\r\n    let element: HTMLImageElement | HTMLCanvasElement, loadPromise: Promise<void>;\r\n    if(!useBlur) {\r\n      element = new Image();\r\n      loadPromise = renderImageFromUrlPromise(element, url);\r\n    } else {\r\n      const result = blur(url);\r\n      element = result.canvas;\r\n      loadPromise = result.promise;\r\n    }\r\n\r\n    element.classList.add('thumbnail');\r\n    \r\n    return {image: element, loadPromise};\r\n  }\r\n  \r\n  public setAttachmentSize(\r\n    photo: MyPhoto | MyDocument, \r\n    element: HTMLElement | SVGForeignObjectElement, \r\n    boxWidth: number, \r\n    boxHeight: number, \r\n    noZoom = true, \r\n    message?: any,\r\n    pushDocumentSize?: boolean,\r\n    photoSize?: ReturnType<AppPhotosManager['choosePhotoSize']>\r\n  ) {\r\n    if(!photoSize) {\r\n      photoSize = this.choosePhotoSize(photo, boxWidth, boxHeight, undefined, pushDocumentSize);\r\n    }\r\n    //console.log('setAttachmentSize', photo, photo.sizes[0].bytes, div);\r\n    \r\n    let size: MediaSize;\r\n    const isDocument = photo._ === 'document';\r\n    if(isDocument) {\r\n      size = makeMediaSize((photo as MyDocument).w || (photoSize as PhotoSize.photoSize).w || 512, (photo as MyDocument).h || (photoSize as PhotoSize.photoSize).h || 512);\r\n    } else {\r\n      size = makeMediaSize((photoSize as PhotoSize.photoSize).w || 100, (photoSize as PhotoSize.photoSize).h || 100);\r\n    }\r\n\r\n    let boxSize = makeMediaSize(boxWidth, boxHeight);\r\n\r\n    boxSize = size = size.aspect(boxSize, noZoom);\r\n\r\n    let isFit = true;\r\n\r\n    if(!isDocument || ['video', 'gif'].includes((photo as MyDocument).type)) {\r\n      if(boxSize.width < 200 && boxSize.height < 200) { // make at least one side this big\r\n        boxSize = size = size.aspectCovered(makeMediaSize(200, 200));\r\n      }\r\n  \r\n      if(message && \r\n        (message.message || \r\n          message.reply_to_mid || \r\n          message.media.webpage || \r\n          (message.replies && message.replies.pFlags.comments && message.replies.channel_id.toChatId() !== REPLIES_HIDDEN_CHANNEL_ID)\r\n        )\r\n      ) { // make sure that bubble block is human-readable\r\n        if(boxSize.width < 320) {\r\n          boxSize = makeMediaSize(320, boxSize.height);\r\n          isFit = false;\r\n        }\r\n      }\r\n  \r\n      if(isFit && boxSize.width < 120 && message) { // if image is too narrow\r\n        boxSize = makeMediaSize(120, boxSize.height);\r\n        isFit = false;\r\n      }\r\n    }\r\n\r\n    // if(element instanceof SVGForeignObjectElement) {\r\n    //   element.setAttributeNS(null, 'width', '' + w);\r\n    //   element.setAttributeNS(null, 'height', '' + h);\r\n\r\n    //   //console.log('set dimensions to svg element:', element, w, h);\r\n    // } else {\r\n      element.style.width = boxSize.width + 'px';\r\n      element.style.height = boxSize.height + 'px';\r\n    // }\r\n    \r\n    return {photoSize, size, isFit};\r\n  }\r\n\r\n  public getStrippedThumbIfNeeded(photo: MyPhoto | MyDocument, cacheContext: ThumbCache, useBlur: boolean, ignoreCache = false): ReturnType<AppPhotosManager['getImageFromStrippedThumb']> {\r\n    if(!cacheContext.downloaded || (['video', 'gif'] as MyDocument['type'][]).includes((photo as MyDocument).type) || ignoreCache) {\r\n      if(photo._ === 'document' && cacheContext.downloaded && !ignoreCache) {\r\n        return null;\r\n      }\r\n\r\n      const sizes = (photo as MyPhoto).sizes || (photo as MyDocument).thumbs;\r\n      const thumb = sizes?.length ? sizes.find(size => size._ === 'photoStrippedSize') : null;\r\n      if(thumb && ('bytes' in thumb)) {\r\n        return this.getImageFromStrippedThumb(photo, thumb as any, useBlur);\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n  \r\n  public getPhotoDownloadOptions(photo: MyPhoto | MyDocument, photoSize: PhotoSize, queueId?: number, onlyCache?: boolean): DownloadOptions {\r\n    const isDocument = photo._ === 'document';\r\n\r\n    if(!photoSize || photoSize._ === 'photoSizeEmpty') {\r\n      //console.error('no photoSize by photo:', photo);\r\n      throw new Error('photoSizeEmpty!');\r\n    }\r\n    \r\n    // maybe it's a thumb\r\n    const isPhoto = (photoSize._ === 'photoSize' || photoSize._ === 'photoSizeProgressive') && photo.access_hash && photo.file_reference;\r\n    const location: InputFileLocation.inputPhotoFileLocation | InputFileLocation.inputDocumentFileLocation = {\r\n      _: isDocument ? 'inputDocumentFileLocation' : 'inputPhotoFileLocation',\r\n      id: photo.id,\r\n      access_hash: photo.access_hash,\r\n      file_reference: photo.file_reference,\r\n      thumb_size: photoSize.type\r\n    };\r\n\r\n    return {\r\n      dcId: photo.dc_id, \r\n      location, \r\n      size: isPhoto ? (photoSize as PhotoSize.photoSize).size : undefined, \r\n      queueId, \r\n      onlyCache\r\n    };\r\n  }\r\n\r\n  /* public getPhotoURL(photo: MTPhoto | MTMyDocument, photoSize: MTPhotoSize) {\r\n    const downloadOptions = this.getPhotoDownloadOptions(photo, photoSize);\r\n\r\n    return {url: getFileURL('photo', downloadOptions), location: downloadOptions.location};\r\n  } */\r\n\r\n  /* public isDownloaded(media: any) {\r\n    const isPhoto = media._ === 'photo';\r\n    const photo = isPhoto ? this.getPhoto(media.id) : null;\r\n    let isDownloaded: boolean;\r\n    if(photo) {\r\n      isDownloaded = photo.downloaded > 0;\r\n    } else {\r\n      const cachedThumb = this.getDocumentCachedThumb(media.id);\r\n      isDownloaded = cachedThumb?.downloaded > 0;\r\n    }\r\n\r\n    return isDownloaded;\r\n  } */\r\n  \r\n  public preloadPhoto(photoId: MyPhoto | MyDocument | string, photoSize?: PhotoSize, queueId?: number, onlyCache?: boolean): CancellablePromise<Blob> {\r\n    const photo = this.getPhoto(photoId);\r\n\r\n    // @ts-ignore\r\n    if(!photo || photo._ === 'photoEmpty') {\r\n      throw new Error('preloadPhoto photoEmpty!');\r\n    }\r\n\r\n    if(!photoSize) {\r\n      const fullWidth = windowSize.width;\r\n      const fullHeight = windowSize.height;\r\n      \r\n      photoSize = this.choosePhotoSize(photo, fullWidth, fullHeight);\r\n    }\r\n\r\n    const cacheContext = appDownloadManager.getCacheContext(photo, photoSize.type);\r\n    if(cacheContext.downloaded >= ('size' in photoSize ? photoSize.size : 0) && cacheContext.url) {\r\n      return Promise.resolve() as any;\r\n    }\r\n    \r\n    const downloadOptions = this.getPhotoDownloadOptions(photo, photoSize, queueId, onlyCache);\r\n    const fileName = getFileNameByLocation(downloadOptions.location);\r\n\r\n    let download = appDownloadManager.getDownload(fileName);\r\n    if(download) {\r\n      return download;\r\n    }\r\n\r\n    download = appDownloadManager.download(downloadOptions);\r\n    download.then(blob => {\r\n      if(!cacheContext.downloaded || cacheContext.downloaded < blob.size) {\r\n        const url = URL.createObjectURL(blob);\r\n        cacheContext.downloaded = blob.size;\r\n        cacheContext.url = url;\r\n\r\n        //console.log('wrote photo:', photo, photoSize, cacheContext, blob);\r\n      }\r\n\r\n      return blob;\r\n    }).catch(() => {});\r\n\r\n    return download;\r\n  }\r\n  \r\n  public getPhoto(photoId: any/* MyPhoto | string */): MyPhoto {\r\n    return isObject(photoId) ? photoId as MyPhoto : this.photos[photoId as any as string];\r\n  }\r\n\r\n  public getInput(photo: MyPhoto): InputPhoto.inputPhoto {\r\n    return {\r\n      _: 'inputPhoto',\r\n      id: photo.id,\r\n      access_hash: photo.access_hash,\r\n      file_reference: photo.file_reference\r\n    };\r\n  }\r\n\r\n  public getMediaInput(photo: MyPhoto): InputMedia.inputMediaPhoto {\r\n    return {\r\n      _: 'inputMediaPhoto',\r\n      id: this.getInput(photo),\r\n      ttl_seconds: 0\r\n    };\r\n  }\r\n\r\n  public savePhotoFile(photo: MyPhoto | MyDocument, queueId?: number) {\r\n    const fullPhotoSize = this.choosePhotoSize(photo, 0xFFFF, 0xFFFF);\r\n    if(!(fullPhotoSize._ === 'photoSize' || fullPhotoSize._ === 'photoSizeProgressive')) {\r\n      return;\r\n    }\r\n\r\n    const downloadOptions = this.getPhotoDownloadOptions(photo, fullPhotoSize, queueId);\r\n    downloadOptions.fileName = 'photo' + photo.id + '.jpg';\r\n    appDownloadManager.downloadToDisc(downloadOptions, downloadOptions.fileName);\r\n  }\r\n}\r\n\r\nconst appPhotosManager = new AppPhotosManager();\r\nMOUNT_CLASS_TO && (MOUNT_CLASS_TO.appPhotosManager = appPhotosManager);\r\nexport default appPhotosManager;\r\n","export default function bytesToDataURL(bytes: Uint8Array, mimeType: string = 'image/jpeg') {\r\n  return `data:${mimeType};base64,${btoa(String.fromCharCode(...bytes))}`;\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n * \r\n * Originally from:\r\n * https://github.com/zhukov/webogram\r\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\r\n * https://github.com/zhukov/webogram/blob/master/LICENSE\r\n */\r\n\r\nimport { MOUNT_CLASS_TO } from \"../../config/debug\";\r\nimport { tsNow } from \"../../helpers/date\";\r\nimport numberThousandSplitter from \"../../helpers/number/numberThousandSplitter\";\r\nimport { ChannelParticipantsFilter, ChannelsChannelParticipants, ChannelParticipant, Chat, ChatFull, ChatParticipants, ChatPhoto, ExportedChatInvite, InputChannel, InputFile, SendMessageAction, Update, UserFull, Photo, PhotoSize } from \"../../layer\";\r\nimport { LangPackKey, i18n } from \"../langPack\";\r\n//import apiManager from '../mtproto/apiManager';\r\nimport apiManager from '../mtproto/mtprotoworker';\r\nimport { RichTextProcessor } from \"../richtextprocessor\";\r\nimport rootScope from \"../rootScope\";\r\nimport SearchIndex from \"../searchIndex\";\r\nimport apiUpdatesManager from \"./apiUpdatesManager\";\r\nimport appChatsManager from \"./appChatsManager\";\r\nimport appMessagesIdsManager from \"./appMessagesIdsManager\";\r\nimport appNotificationsManager from \"./appNotificationsManager\";\r\nimport appPeersManager from \"./appPeersManager\";\r\nimport appPhotosManager from \"./appPhotosManager\";\r\nimport appUsersManager, { MyTopPeer, User } from \"./appUsersManager\";\r\n\r\nexport type UserTyping = Partial<{userId: UserId, action: SendMessageAction, timeout: number}>;\r\n\r\nexport class AppProfileManager {\r\n  //private botInfos: any = {};\r\n  private usersFull: {[id: UserId]: UserFull.userFull} = {};\r\n  private chatsFull: {[id: ChatId]: ChatFull} = {};\r\n  private typingsInPeer: {[peerId: PeerId]: UserTyping[]};\r\n\r\n  constructor() {\r\n    rootScope.addMultipleEventsListeners({\r\n      updateChatParticipants: (update) => {\r\n        const participants = update.participants;\r\n        if(participants._ === 'chatParticipants') {\r\n          const chatId = participants.chat_id;\r\n          const chatFull = this.chatsFull[chatId] as ChatFull.chatFull;\r\n          if(chatFull !== undefined) {\r\n            chatFull.participants = participants;\r\n            rootScope.dispatchEvent('chat_full_update', chatId);\r\n          }\r\n        }\r\n      },\r\n\r\n      updateChatParticipantAdd: (update) => {\r\n        const chatFull = this.chatsFull[update.chat_id] as ChatFull.chatFull;\r\n        if(chatFull !== undefined) {\r\n          const _participants = chatFull.participants as ChatParticipants.chatParticipants;\r\n          const participants = _participants.participants || [];\r\n          for(let i = 0, length = participants.length; i < length; i++) {\r\n            if(participants[i].user_id === update.user_id) {\r\n              return;\r\n            }\r\n          }\r\n\r\n          participants.push({\r\n            _: 'chatParticipant',\r\n            user_id: update.user_id,\r\n            inviter_id: update.inviter_id,\r\n            date: tsNow(true)\r\n          });\r\n\r\n          _participants.version = update.version;\r\n          rootScope.dispatchEvent('chat_full_update', update.chat_id);\r\n        }\r\n      },\r\n\r\n      updateChatParticipantDelete: (update) => {\r\n        const chatFull = this.chatsFull[update.chat_id] as ChatFull.chatFull;\r\n        if(chatFull !== undefined) {\r\n          const _participants = chatFull.participants as ChatParticipants.chatParticipants;\r\n          const participants = _participants.participants || [];\r\n          for(let i = 0, length = participants.length; i < length; i++) {\r\n            if(participants[i].user_id === update.user_id) {\r\n              participants.splice(i, 1);\r\n              _participants.version = update.version;\r\n              rootScope.dispatchEvent('chat_full_update', update.chat_id);\r\n              return;\r\n            }\r\n          }\r\n        }\r\n      },\r\n\r\n      updateUserTyping: this.onUpdateUserTyping,\r\n      updateChatUserTyping: this.onUpdateUserTyping,\r\n      updateChannelUserTyping: this.onUpdateUserTyping,\r\n\r\n      updatePeerBlocked: this.onUpdatePeerBlocked\r\n    });\r\n\r\n    rootScope.addEventListener('chat_update', (chatId) => {\r\n      const fullChat = this.chatsFull[chatId];\r\n      const chat: Chat.chat | Chat.channel | Chat.chatForbidden | Chat.channelForbidden = appChatsManager.getChat(chatId);\r\n      if(!fullChat || !chat) {\r\n        return;\r\n      }\r\n\r\n      let updated = false;\r\n      if(!!fullChat.call !== !!(chat as Chat.chat).pFlags?.call_active) {\r\n        updated = true;\r\n      }\r\n\r\n      const {photo} = chat as Chat.chat;\r\n      if(photo) {\r\n        const hasChatPhoto = photo._ !== 'chatPhotoEmpty';\r\n        const hasFullChatPhoto = !!(fullChat.chat_photo && fullChat.chat_photo._ !== 'photoEmpty'); // chat_photo can be missing\r\n        if(\r\n          hasChatPhoto !== hasFullChatPhoto || (\r\n            hasChatPhoto && \r\n            photo.photo_id !== fullChat.chat_photo?.id\r\n          )\r\n        ) {\r\n          updated = true;\r\n        }\r\n      }\r\n\r\n      if(updated) {\r\n        this.refreshFullPeer(chatId.toPeerId(true));\r\n      }\r\n    });\r\n\r\n    rootScope.addEventListener('channel_update', (chatId) => {\r\n      this.refreshFullPeer(chatId.toPeerId(true));\r\n    });\r\n\r\n    // * genius\r\n    rootScope.addEventListener('chat_full_update', (chatId) => {\r\n      rootScope.dispatchEvent('peer_full_update', chatId.toPeerId(true));\r\n    });\r\n    \r\n    // * genius\r\n    rootScope.addEventListener('user_full_update', (userId) => {\r\n      rootScope.dispatchEvent('peer_full_update', userId.toPeerId(false));\r\n    });\r\n\r\n    rootScope.addEventListener('invalidate_participants', (chatId) => {\r\n      this.invalidateChannelParticipants(chatId);\r\n    });\r\n\r\n    this.typingsInPeer = {};\r\n  }\r\n\r\n  /* public saveBotInfo(botInfo: any) {\r\n    const botId = botInfo && botInfo.user_id;\r\n    if(!botId) {\r\n      return null;\r\n    }\r\n\r\n    const commands: any = {};\r\n    botInfo.commands.forEach((botCommand: any) => {\r\n      commands[botCommand.command] = botCommand.description;\r\n    });\r\n\r\n    return this.botInfos[botId] = {\r\n      id: botId,\r\n      version: botInfo.version,\r\n      shareText: botInfo.share_text,\r\n      description: botInfo.description,\r\n      commands: commands\r\n    };\r\n  } */\r\n\r\n  public getProfile(id: UserId, override?: true) {\r\n    if(this.usersFull[id] && !override) {\r\n      return this.usersFull[id];\r\n    }\r\n\r\n    return apiManager.invokeApiSingleProcess({\r\n      method: 'users.getFullUser', \r\n      params: {\r\n        id: appUsersManager.getUserInput(id)\r\n      },\r\n      processResult: (usersUserFull) => {\r\n        appChatsManager.saveApiChats(usersUserFull.chats, true);\r\n        appUsersManager.saveApiUsers(usersUserFull.users);\r\n\r\n        const userFull = usersUserFull.full_user;\r\n        const peerId = id.toPeerId(false);\r\n        if(userFull.profile_photo) {\r\n          userFull.profile_photo = appPhotosManager.savePhoto(userFull.profile_photo, {type: 'profilePhoto', peerId});\r\n        }\r\n\r\n        appNotificationsManager.savePeerSettings({\r\n          peerId, \r\n          settings: userFull.notify_settings\r\n        });\r\n\r\n        this.usersFull[id] = userFull;\r\n\r\n        /* if(userFull.bot_info) {\r\n          userFull.bot_info = this.saveBotInfo(userFull.bot_info) as any;\r\n        } */\r\n\r\n        //appMessagesManager.savePinnedMessage(id, userFull.pinned_msg_id);\r\n\r\n        rootScope.dispatchEvent('user_full_update', id);\r\n        return userFull;\r\n      }\r\n    });\r\n  }\r\n\r\n  public getProfileByPeerId(peerId: PeerId, override?: true) {\r\n    if(appPeersManager.isAnyChat(peerId)) return this.getChatFull(peerId.toChatId(), override);\r\n    else return this.getProfile(peerId.toUserId(), override);\r\n  }\r\n\r\n  public getCachedFullChat(chatId: ChatId) {\r\n    return this.chatsFull[chatId];\r\n  }\r\n\r\n  public getCachedFullUser(userId: UserId) {\r\n    return this.usersFull[userId];\r\n  }\r\n\r\n  public getCachedProfileByPeerId(peerId: PeerId) {\r\n    return peerId.isUser() ? this.getCachedFullUser(peerId.toUserId()) : this.getCachedFullChat(peerId.toChatId());\r\n  }\r\n\r\n  public async getFullPhoto(peerId: PeerId) {\r\n    const profile = await this.getProfileByPeerId(peerId);\r\n    switch(profile._) {\r\n      case 'userFull':\r\n        return profile.profile_photo;\r\n      case 'channelFull':\r\n      case 'chatFull':\r\n        return profile.chat_photo;\r\n    }\r\n  }\r\n\r\n  /* public getPeerBots(peerId: PeerId) {\r\n    var peerBots: any[] = [];\r\n    if(peerId >= 0 && !appUsersManager.isBot(peerId) ||\r\n      (appPeersManager.isChannel(peerId) && !appPeersManager.isMegagroup(peerId))) {\r\n      return Promise.resolve(peerBots);\r\n    }\r\n    if(peerId >= 0) {\r\n      return this.getProfile(peerId).then((userFull: any) => {\r\n        var botInfo = userFull.bot_info;\r\n        if(botInfo && botInfo._ !== 'botInfoEmpty') {\r\n          peerBots.push(botInfo);\r\n        }\r\n        return peerBots;\r\n      });\r\n    }\r\n\r\n    return this.getChatFull(peerId.toChatId()).then((chatFull: any) => {\r\n      chatFull.bot_info.forEach((botInfo: any) => {\r\n        peerBots.push(this.saveBotInfo(botInfo))\r\n      });\r\n      return peerBots;\r\n    });\r\n  } */\r\n\r\n  public getChatFull(id: ChatId, override?: true) {\r\n    if(appChatsManager.isChannel(id)) {\r\n      return this.getChannelFull(id, override);\r\n    }\r\n\r\n    const fullChat = this.chatsFull[id] as ChatFull.chatFull;\r\n    if(fullChat && !override) {\r\n      const chat = appChatsManager.getChat(id);\r\n      if(chat.version === (fullChat.participants as ChatParticipants.chatParticipants).version ||\r\n        chat.pFlags.left) {\r\n        return fullChat as ChatFull;\r\n      }\r\n    }\r\n    \r\n    return apiManager.invokeApiSingleProcess({\r\n      method: 'messages.getFullChat', \r\n      params: {\r\n        chat_id: id\r\n      },\r\n      processResult: (result) => {\r\n        appChatsManager.saveApiChats(result.chats, true);\r\n        appUsersManager.saveApiUsers(result.users);\r\n        const fullChat = result.full_chat as ChatFull.chatFull;\r\n        const peerId = id.toPeerId(true);\r\n        if(fullChat && fullChat.chat_photo && fullChat.chat_photo.id) {\r\n          fullChat.chat_photo = appPhotosManager.savePhoto(fullChat.chat_photo, {type: 'profilePhoto', peerId});\r\n        }\r\n\r\n        //appMessagesManager.savePinnedMessage(peerId, fullChat.pinned_msg_id);\r\n        appNotificationsManager.savePeerSettings({\r\n          peerId, \r\n          settings: fullChat.notify_settings\r\n        });\r\n        \r\n        this.chatsFull[id] = fullChat;\r\n        rootScope.dispatchEvent('chat_full_update', id);\r\n\r\n        return fullChat;\r\n      }\r\n    });\r\n  }\r\n\r\n  public async getChatInviteLink(id: ChatId, force?: boolean) {\r\n    const chatFull = await this.getChatFull(id);\r\n    if(!force &&\r\n      chatFull.exported_invite &&\r\n      chatFull.exported_invite._ == 'chatInviteExported') {\r\n      return chatFull.exported_invite.link;\r\n    }\r\n    \r\n    return apiManager.invokeApi('messages.exportChatInvite', {\r\n      peer: appPeersManager.getInputPeerById(id.toPeerId(true))\r\n    }).then((exportedInvite) => {\r\n      if(this.chatsFull[id] !== undefined) {\r\n        this.chatsFull[id].exported_invite = exportedInvite;\r\n      }\r\n\r\n      return (exportedInvite as ExportedChatInvite.chatInviteExported).link;\r\n    });\r\n  }\r\n\r\n  public getChannelParticipants(id: ChatId, filter: ChannelParticipantsFilter = {_: 'channelParticipantsRecent'}, limit = 200, offset = 0) {\r\n    if(filter._ === 'channelParticipantsRecent') {\r\n      const chat = appChatsManager.getChat(id);\r\n      if(chat &&\r\n          chat.pFlags && (\r\n            // chat.pFlags.kicked ||\r\n            chat.pFlags.broadcast && !chat.pFlags.creator && !chat.admin_rights\r\n          )) {\r\n        return Promise.reject();\r\n      }\r\n    }\r\n\r\n    return apiManager.invokeApiCacheable('channels.getParticipants', {\r\n      channel: appChatsManager.getChannelInput(id),\r\n      filter,\r\n      offset,\r\n      limit,\r\n      hash: '0'\r\n    }, {cacheSeconds: 60}).then(result => {\r\n      appUsersManager.saveApiUsers((result as ChannelsChannelParticipants.channelsChannelParticipants).users);\r\n      return result as ChannelsChannelParticipants.channelsChannelParticipants;\r\n    });\r\n    /* let maybeAddSelf = (participants: any[]) => {\r\n      let chat = appChatsManager.getChat(id);\r\n      let selfMustBeFirst = filter._ === 'channelParticipantsRecent' &&\r\n                            !offset &&\r\n                            !chat.pFlags.kicked &&\r\n                            !chat.pFlags.left;\r\n\r\n      if(selfMustBeFirst) {\r\n        participants = copy(participants);\r\n        let myID = appUsersManager.getSelf().id;\r\n        let myIndex = participants.findIndex(p => p.user_id === myID);\r\n        let myParticipant;\r\n\r\n        if(myIndex !== -1) {\r\n          myParticipant = participants[myIndex];\r\n          participants.splice(myIndex, 1);\r\n        } else {\r\n          myParticipant = {_: 'channelParticipantSelf', user_id: myID};\r\n        }\r\n\r\n        participants.unshift(myParticipant);\r\n      }\r\n\r\n      return participants;\r\n    } */\r\n  }\r\n\r\n  public getChannelParticipant(id: ChatId, peerId: PeerId) {\r\n    return apiManager.invokeApiSingle('channels.getParticipant', {\r\n      channel: appChatsManager.getChannelInput(id),\r\n      participant: appPeersManager.getInputPeerById(peerId),\r\n    }).then(channelParticipant => {\r\n      appUsersManager.saveApiUsers(channelParticipant.users);\r\n      return channelParticipant.participant;\r\n    });\r\n  }\r\n\r\n  public getChannelFull(id: ChatId, override?: true) {\r\n    if(this.chatsFull[id] !== undefined && !override) {\r\n      return this.chatsFull[id] as ChatFull.channelFull;\r\n    }\r\n\r\n    return apiManager.invokeApiSingleProcess({\r\n      method: 'channels.getFullChannel', \r\n      params: {\r\n        channel: appChatsManager.getChannelInput(id)\r\n      }, \r\n      processResult: (result) => {\r\n        const peerId = id.toPeerId(true);\r\n        appChatsManager.saveApiChats(result.chats, true);\r\n        appUsersManager.saveApiUsers(result.users);\r\n        const fullChannel = result.full_chat as ChatFull.channelFull;\r\n        if(fullChannel && fullChannel.chat_photo.id) {\r\n          fullChannel.chat_photo = appPhotosManager.savePhoto(fullChannel.chat_photo, {type: 'profilePhoto', peerId});\r\n          //appPhotosManager.savePhoto(fullChannel.chat_photo);\r\n        }\r\n        appNotificationsManager.savePeerSettings({\r\n          peerId, \r\n          settings: fullChannel.notify_settings\r\n        });\r\n\r\n        this.chatsFull[id] = fullChannel;\r\n        rootScope.dispatchEvent('chat_full_update', id);\r\n\r\n        return fullChannel;\r\n      }, \r\n      processError: (error) => {\r\n        switch(error.type) {\r\n          case 'CHANNEL_PRIVATE':\r\n            let channel = appChatsManager.getChat(id);\r\n            channel = {_: 'channelForbidden', access_hash: channel.access_hash, title: channel.title};\r\n            apiUpdatesManager.processUpdateMessage({\r\n              _: 'updates',\r\n              updates: [{\r\n                _: 'updateChannel',\r\n                channel_id: id\r\n              } as Update.updateChannel],\r\n              chats: [channel],\r\n              users: []\r\n            });\r\n            break;\r\n        }\r\n\r\n        throw error;\r\n      }\r\n    });\r\n  }\r\n\r\n  public getMentions(chatId: ChatId, query: string, threadId?: number): Promise<PeerId[]> {\r\n    const processUserIds = (topPeers: MyTopPeer[]) => {\r\n      const startsWithAt = query.charAt(0) === '@';\r\n      if(startsWithAt) query = query.slice(1);\r\n      /* const startsWithAt = query.charAt(0) === '@';\r\n      if(startsWithAt) query = query.slice(1);\r\n      \r\n      const index = new SearchIndex<number>(!startsWithAt, !startsWithAt); */\r\n      const index = new SearchIndex<PeerId>({\r\n        ignoreCase: true\r\n      });\r\n\r\n      const ratingMap: Map<PeerId, number> = new Map();\r\n      topPeers.forEach(peer => {\r\n        index.indexObject(peer.id, appUsersManager.getUserSearchText(peer.id));\r\n        ratingMap.set(peer.id, peer.rating);\r\n      });\r\n\r\n      const peerIds = Array.from(index.search(query));\r\n      peerIds.sort((a, b) => ratingMap.get(b) - ratingMap.get(a));\r\n      return peerIds;\r\n    };\r\n\r\n    let promise: Promise<PeerId[]>;\r\n    if(appChatsManager.isChannel(chatId)) {\r\n      promise = this.getChannelParticipants(chatId, {\r\n        _: 'channelParticipantsMentions',\r\n        q: query,\r\n        top_msg_id: appMessagesIdsManager.getServerMessageId(threadId)\r\n      }, 50, 0).then(cP => {\r\n        return cP.participants.map(p => appChatsManager.getParticipantPeerId(p));\r\n      });\r\n    } else if(chatId) {\r\n      promise = Promise.resolve(this.getChatFull(chatId)).then(chatFull => {\r\n        return ((chatFull as ChatFull.chatFull).participants as ChatParticipants.chatParticipants).participants.map(p => p.user_id.toPeerId());\r\n      });\r\n    } else {\r\n      promise = Promise.resolve([]);\r\n    }\r\n\r\n    return Promise.all([\r\n      // [],\r\n      appUsersManager.getTopPeers('bots_inline').catch(() => [] as MyTopPeer[]), \r\n      promise\r\n    ]).then(results => {\r\n      const peers = results[0].concat(results[1].map(peerId => ({id: peerId, rating: 0})));\r\n\r\n      return processUserIds(peers);\r\n    });\r\n  }\r\n\r\n  public invalidateChannelParticipants(id: ChatId) {\r\n    apiManager.clearCache('channels.getParticipants', (params) => (params.channel as InputChannel.inputChannel).channel_id === id);\r\n    this.refreshFullPeer(id.toPeerId(true));\r\n  }\r\n\r\n  private refreshFullPeer(peerId: PeerId) {\r\n    if(peerId.isUser()) {\r\n      const userId = peerId.toUserId();\r\n      delete this.usersFull[userId];\r\n      rootScope.dispatchEvent('user_full_update', userId);\r\n    } else {\r\n      const chatId = peerId.toChatId();\r\n      delete this.chatsFull[chatId];\r\n      rootScope.dispatchEvent('chat_full_update', chatId);\r\n    }\r\n\r\n    // ! эта строчка будет создавать race condition:\r\n    // ! запрос вернёт chat с установленным флагом call_not_empty, хотя сам апдейт уже будет применён\r\n    // this.getProfileByPeerId(peerId, true);\r\n  }\r\n\r\n  public updateProfile(first_name?: string, last_name?: string, about?: string) {\r\n    return apiManager.invokeApi('account.updateProfile', {\r\n      first_name,\r\n      last_name,\r\n      about\r\n    }).then(user => {\r\n      appUsersManager.saveApiUser(user);\r\n\r\n      if(about !== undefined) {\r\n        const peerId = user.id.toPeerId();\r\n        const userFull = this.usersFull[user.id];\r\n        if(userFull) {\r\n          userFull.about = about;\r\n        }\r\n  \r\n        rootScope.dispatchEvent('peer_bio_edit', peerId);\r\n      }\r\n      \r\n      return this.getProfile(rootScope.myId, true);\r\n    });\r\n  }\r\n\r\n  public uploadProfilePhoto(inputFile: InputFile) {\r\n    return apiManager.invokeApi('photos.uploadProfilePhoto', {\r\n      file: inputFile\r\n    }).then((updateResult) => {\r\n      // ! sometimes can have no user in users\r\n      const photo = updateResult.photo as Photo.photo;\r\n      if(!updateResult.users.length) {\r\n        const strippedThumb = photo.sizes.find(size => size._ === 'photoStrippedSize') as PhotoSize.photoStrippedSize;\r\n        updateResult.users.push({\r\n          ...appUsersManager.getSelf(), \r\n          photo: {\r\n            _: 'userProfilePhoto',\r\n            dc_id: photo.dc_id,\r\n            photo_id: photo.id,\r\n            stripped_thumb: strippedThumb?.bytes,\r\n            pFlags: {\r\n\r\n            }\r\n          }\r\n        });\r\n      }\r\n      appUsersManager.saveApiUsers(updateResult.users);\r\n\r\n      const myId = rootScope.myId;\r\n      appPhotosManager.savePhoto(updateResult.photo, {\r\n        type: 'profilePhoto',\r\n        peerId: myId\r\n      });\r\n\r\n      const userId = myId.toUserId();\r\n      apiUpdatesManager.processLocalUpdate({\r\n        _: 'updateUserPhoto',\r\n        user_id: userId,\r\n        date: tsNow(true),\r\n        photo: appUsersManager.getUser(userId).photo,\r\n        previous: true\r\n      });\r\n    });\r\n  }\r\n\r\n  public deletePhotos(photoIds: string[]) {\r\n    return apiManager.invokeApiSingle('photos.deletePhotos', {\r\n      id: photoIds.map(photoId => {\r\n        const photo = appPhotosManager.getPhoto(photoId);\r\n        return appPhotosManager.getInput(photo);\r\n      })\r\n    }).then((deletedList) => {\r\n      \r\n    });\r\n  }\r\n\r\n  public getChatMembersString(chatId: ChatId) {\r\n    const chat: Chat = appChatsManager.getChat(chatId);\r\n    if(chat._ === 'chatForbidden') {\r\n      return i18n('YouWereKicked');\r\n    }\r\n\r\n    const chatFull = this.chatsFull[chatId];\r\n    let count: number;\r\n    if(chatFull) {\r\n      if(chatFull._ === 'channelFull') {\r\n        count = chatFull.participants_count;\r\n      } else {\r\n        count = (chatFull.participants as ChatParticipants.chatParticipants).participants?.length;\r\n      }\r\n    } else {\r\n      count = (chat as Chat.chat).participants_count || (chat as any).participants?.participants.length;\r\n    }\r\n\r\n    const isChannel = appChatsManager.isBroadcast(chatId);\r\n    count = count || 1;\r\n\r\n    let key: LangPackKey = isChannel ? 'Peer.Status.Subscribers' : 'Peer.Status.Member';\r\n    return i18n(key, [numberThousandSplitter(count)]);\r\n  }\r\n\r\n  private verifyParticipantForOnlineCount(participant: {user_id: UserId}) {\r\n    const user = appUsersManager.getUser(participant.user_id);\r\n    return !!(user && user.status && user.status._ === 'userStatusOnline');\r\n  }\r\n\r\n  private reduceParticipantsForOnlineCount(participants: {user_id: UserId}[]) {\r\n    return participants.reduce((acc, participant) => {\r\n      return acc + +this.verifyParticipantForOnlineCount(participant);\r\n    }, 0);\r\n  }\r\n\r\n  public async getOnlines(id: ChatId): Promise<number> {\r\n    const minOnline = 1;\r\n    if(appChatsManager.isBroadcast(id)) {\r\n      return minOnline;\r\n    }\r\n    \r\n    const chatInfo = await this.getChatFull(id);\r\n    if(appChatsManager.isMegagroup(id)) {\r\n      if((chatInfo as ChatFull.channelFull).participants_count <= 100) {\r\n        const channelParticipants = await this.getChannelParticipants(id, {_: 'channelParticipantsRecent'}, 100);\r\n        return this.reduceParticipantsForOnlineCount(channelParticipants.participants as ChannelParticipant.channelParticipant[]);\r\n      }\r\n\r\n      const res = await apiManager.invokeApiCacheable('messages.getOnlines', {\r\n        peer: appChatsManager.getChannelInputPeer(id)\r\n      }, {cacheSeconds: 60});\r\n\r\n      const onlines = res.onlines ?? minOnline;\r\n      return onlines;\r\n    }\r\n\r\n    const _participants = (chatInfo as ChatFull.chatFull).participants as ChatParticipants.chatParticipants;\r\n    if(_participants?.participants) {\r\n      return this.reduceParticipantsForOnlineCount(_participants.participants);\r\n    } else {\r\n      return minOnline;\r\n    }\r\n  }\r\n\r\n  private onUpdateUserTyping = (update: Update.updateUserTyping | Update.updateChatUserTyping | Update.updateChannelUserTyping) => {\r\n    const fromId = (update as Update.updateUserTyping).user_id ? \r\n      (update as Update.updateUserTyping).user_id.toPeerId() : \r\n      appPeersManager.getPeerId((update as Update.updateChatUserTyping).from_id);\r\n    if(rootScope.myId === fromId || update.action._ === 'speakingInGroupCallAction') {\r\n      return;\r\n    }\r\n    \r\n    const peerId = appPeersManager.getPeerId(update);\r\n    const typings = this.typingsInPeer[peerId] ?? (this.typingsInPeer[peerId] = []);\r\n    let typing = typings.find(t => t.userId === fromId);\r\n\r\n    const cancelAction = () => {\r\n      delete typing.timeout;\r\n      //typings.findAndSplice(t => t === typing);\r\n      const idx = typings.indexOf(typing);\r\n      if(idx !== -1) {\r\n        typings.splice(idx, 1);\r\n      }\r\n\r\n      rootScope.dispatchEvent('peer_typings', {peerId, typings});\r\n\r\n      if(!typings.length) {\r\n        delete this.typingsInPeer[peerId];\r\n      }\r\n    };\r\n\r\n    if(typing && typing.timeout !== undefined) {\r\n      clearTimeout(typing.timeout);\r\n    }\r\n\r\n    if(update.action._ === 'sendMessageCancelAction') {\r\n      if(!typing) {\r\n        return;\r\n      }\r\n\r\n      cancelAction();\r\n      return;\r\n    }\r\n\r\n    if(!typing) {\r\n      typing = {\r\n        userId: fromId\r\n      };\r\n\r\n      typings.push(typing);\r\n    }\r\n\r\n    //console.log('updateChatUserTyping', update, typings);\r\n    \r\n    typing.action = update.action;\r\n    \r\n    const hasUser = appUsersManager.hasUser(fromId);\r\n    if(!hasUser) {\r\n      // let's load user here\r\n      if(update._ === 'updateChatUserTyping') {\r\n        if(update.chat_id && appChatsManager.hasChat(update.chat_id) && !appChatsManager.isChannel(update.chat_id)) {\r\n          Promise.resolve(this.getChatFull(update.chat_id)).then(() => {\r\n            if(typing.timeout !== undefined && appUsersManager.hasUser(fromId)) {\r\n              rootScope.dispatchEvent('peer_typings', {peerId, typings});\r\n            }\r\n          });\r\n        }\r\n      }\r\n      \r\n      //return;\r\n    } else {\r\n      appUsersManager.forceUserOnline(fromId);\r\n    }\r\n\r\n    typing.timeout = window.setTimeout(cancelAction, 6000);\r\n    if(hasUser) {\r\n      rootScope.dispatchEvent('peer_typings', {peerId, typings});\r\n    }\r\n  };\r\n\r\n  private onUpdatePeerBlocked = (update: Update.updatePeerBlocked) => {\r\n    const peerId = appPeersManager.getPeerId(update.peer_id);\r\n    if(appPeersManager.isUser(peerId)) {\r\n      const userId = peerId.toUserId();\r\n      const userFull = this.usersFull[userId];\r\n      if(userFull) {\r\n        if(update.blocked) userFull.pFlags.blocked = true;\r\n        else delete userFull.pFlags.blocked;\r\n      }\r\n\r\n      rootScope.dispatchEvent('user_full_update', userId);\r\n    }\r\n\r\n    rootScope.dispatchEvent('peer_block', {peerId, blocked: update.blocked});\r\n  };\r\n\r\n  public getPeerTypings(peerId: PeerId) {\r\n    return this.typingsInPeer[peerId];\r\n  }\r\n}\r\n\r\nconst appProfileManager = new AppProfileManager();\r\nMOUNT_CLASS_TO.appProfileManager = appProfileManager;\r\nexport default appProfileManager;\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n * \r\n * Originally from:\r\n * https://github.com/zhukov/webogram\r\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\r\n * https://github.com/zhukov/webogram/blob/master/LICENSE\r\n */\r\n\r\n//import apiManager from '../mtproto/apiManager';\r\nimport DEBUG, { MOUNT_CLASS_TO } from '../../config/debug';\r\nimport { Message, MessageEntity, MessageFwdHeader, Peer, Update, Updates } from '../../layer';\r\nimport { logger, LogTypes } from '../logger';\r\nimport apiManager from '../mtproto/mtprotoworker';\r\nimport rootScope from '../rootScope';\r\n//import networkerFactory from '../mtproto/networkerFactory';\r\nimport appUsersManager from \"./appUsersManager\";\r\nimport appChatsManager from \"./appChatsManager\";\r\nimport appPeersManager from \"./appPeersManager\";\r\nimport appStateManager from './appStateManager';\r\nimport serverTimeManager from '../mtproto/serverTimeManager';\r\nimport assumeType from '../../helpers/assumeType';\r\nimport RichTextProcessor from '../richtextprocessor';\r\nimport App from '../../config/app';\r\nimport filterUnique from '../../helpers/array/filterUnique';\r\n\r\ntype UpdatesState = {\r\n  pendingPtsUpdates: (Update & {pts: number, pts_count: number})[],\r\n  pendingSeqUpdates?: {[seq: number]: {seq: number, date: number, updates: any[]}},\r\n  syncPending: {\r\n    seqAwaiting?: number,\r\n    ptsAwaiting?: true,\r\n    timeout: number\r\n  },\r\n  syncLoading: Promise<void>,\r\n\r\n  seq?: number,\r\n  pts?: number,\r\n  date?: number,\r\n  lastPtsUpdateTime?: number\r\n};\r\n\r\nconst SYNC_DELAY = 6;\r\n\r\nexport class ApiUpdatesManager {\r\n  public updatesState: UpdatesState = {\r\n    pendingPtsUpdates: [],\r\n    pendingSeqUpdates: {},\r\n    syncPending: null,\r\n    syncLoading: null\r\n  };\r\n\r\n  private channelStates: {[channelId: ChatId]: UpdatesState} = {};\r\n  private attached = false;\r\n\r\n  private log = logger('UPDATES', LogTypes.Error | LogTypes.Warn | LogTypes.Log/*  | LogTypes.Debug */);\r\n  private debug = DEBUG;\r\n\r\n  private setProxy() {\r\n    const self = this;\r\n    this.updatesState = new Proxy(this.updatesState, {\r\n      set: function(target: ApiUpdatesManager['updatesState'], key: keyof ApiUpdatesManager['updatesState'], value: ApiUpdatesManager['updatesState'][typeof key]) {\r\n        // @ts-ignore\r\n        target[key] = value;\r\n        self.saveUpdatesState();\r\n        return true;\r\n      }\r\n    });\r\n  }\r\n\r\n  public saveUpdatesState() {\r\n    const us = this.updatesState;\r\n    appStateManager.pushToState('updates', {\r\n      seq: us.seq,\r\n      pts: us.pts,\r\n      date: us.date\r\n    });\r\n  }\r\n\r\n  private popPendingSeqUpdate() {\r\n    const state = this.updatesState;\r\n    const nextSeq = state.seq + 1;\r\n    const pendingUpdatesData = state.pendingSeqUpdates[nextSeq];\r\n    if(!pendingUpdatesData) {\r\n      return false;\r\n    }\r\n\r\n    const updates = pendingUpdatesData.updates;\r\n    for(let i = 0, length = updates.length; i < length; ++i) {\r\n      this.saveUpdate(updates[i]);\r\n    }\r\n\r\n    state.seq = pendingUpdatesData.seq;\r\n    if(pendingUpdatesData.date && state.date < pendingUpdatesData.date) {\r\n      state.date = pendingUpdatesData.date;\r\n    }\r\n    delete state.pendingSeqUpdates[nextSeq];\r\n  \r\n    if(!this.popPendingSeqUpdate() &&\r\n      state.syncPending &&\r\n      state.syncPending.seqAwaiting &&\r\n      state.seq >= state.syncPending.seqAwaiting) {\r\n      if(!state.syncPending.ptsAwaiting) {\r\n        clearTimeout(state.syncPending.timeout);\r\n        state.syncPending = null;\r\n      } else {\r\n        delete state.syncPending.seqAwaiting;\r\n      }\r\n    }\r\n  \r\n    return true;\r\n  }\r\n\r\n  private popPendingPtsUpdate(channelId: ChatId) {\r\n    const curState = channelId ? this.getChannelState(channelId) : this.updatesState;\r\n    if(!curState.pendingPtsUpdates.length) {\r\n      return false;\r\n    }\r\n\r\n    curState.pendingPtsUpdates.sort((a, b) => {\r\n      return a.pts - b.pts;\r\n    });\r\n    // this.log('pop update', channelId, curState.pendingPtsUpdates)\r\n  \r\n    let curPts = curState.pts;\r\n    let goodPts = 0;\r\n    let goodIndex = 0;\r\n    for(let i = 0, length = curState.pendingPtsUpdates.length; i < length; ++i) {\r\n      const update = curState.pendingPtsUpdates[i];\r\n      curPts += update.pts_count;\r\n      if(curPts >= update.pts) {\r\n        goodPts = update.pts;\r\n        goodIndex = i;\r\n      }\r\n    }\r\n  \r\n    if(!goodPts) {\r\n      return false;\r\n    }\r\n  \r\n    this.debug && this.log.debug('pop pending pts updates', goodPts, curState.pendingPtsUpdates.slice(0, goodIndex + 1));\r\n  \r\n    curState.pts = goodPts;\r\n    for(let i = 0; i <= goodIndex; ++i) {\r\n      const update = curState.pendingPtsUpdates[i];\r\n\r\n      // @ts-ignore\r\n      this.saveUpdate(update);\r\n    }\r\n    curState.pendingPtsUpdates.splice(0, goodIndex + 1);\r\n  \r\n    if(!curState.pendingPtsUpdates.length && curState.syncPending) {\r\n      if(!curState.syncPending.seqAwaiting) {\r\n        clearTimeout(curState.syncPending.timeout);\r\n        curState.syncPending = null;\r\n      } else {\r\n        delete curState.syncPending.ptsAwaiting;\r\n      }\r\n    }\r\n  \r\n    return true;\r\n  }\r\n\r\n  public forceGetDifference() {\r\n    if(!this.updatesState.syncLoading) {\r\n      this.getDifference();\r\n    }\r\n  }\r\n\r\n  public processLocalUpdate(update: Update) {\r\n    this.processUpdateMessage({\r\n      _: 'updateShort',\r\n      update\r\n    } as Updates);\r\n  }\r\n\r\n  public processUpdateMessage = (updateMessage: any, options: Partial<{\r\n    override: boolean\r\n  }> = {}) => {\r\n    // return forceGetDifference()\r\n    const processOpts = {\r\n      date: updateMessage.date,\r\n      seq: updateMessage.seq,\r\n      seqStart: updateMessage.seq_start,\r\n      //ignoreSyncLoading: options.ignoreSyncLoading\r\n    };\r\n\r\n    this.debug && this.log.debug('processUpdateMessage', updateMessage);\r\n  \r\n    switch(updateMessage._) {\r\n      case 'updatesTooLong':\r\n      case 'new_session_created':\r\n        this.forceGetDifference();\r\n        break;\r\n  \r\n      case 'updateShort':\r\n        this.processUpdate(updateMessage.update, processOpts);\r\n        break;\r\n  \r\n      case 'updateShortMessage':\r\n      case 'updateShortChatMessage': {\r\n        assumeType<Updates.updateShortChatMessage | Updates.updateShortMessage>(updateMessage);\r\n        this.debug && this.log.debug('updateShortMessage | updateShortChatMessage', {...updateMessage});\r\n        const isOut = updateMessage.pFlags.out;\r\n        const fromId = (updateMessage as Updates.updateShortChatMessage).from_id || (isOut ? rootScope.myId : (updateMessage as Updates.updateShortMessage).user_id);\r\n        const toId = (updateMessage as Updates.updateShortChatMessage).chat_id\r\n          ? (updateMessage as Updates.updateShortChatMessage).chat_id.toPeerId(true)\r\n          : ((updateMessage as Updates.updateShortMessage).user_id.toPeerId(false) || rootScope.myId);\r\n  \r\n        this.processUpdate({\r\n          _: 'updateNewMessage',\r\n          message: {\r\n            _: 'message',\r\n            pFlags: updateMessage.pFlags,\r\n            id: updateMessage.id,\r\n            from_id: appPeersManager.getOutputPeer(fromId.toPeerId()),\r\n            peer_id: appPeersManager.getOutputPeer(toId),\r\n            date: updateMessage.date,\r\n            message: updateMessage.message,\r\n            fwd_from: updateMessage.fwd_from,\r\n            reply_to: updateMessage.reply_to,\r\n            entities: updateMessage.entities\r\n          },\r\n          pts: updateMessage.pts,\r\n          pts_count: updateMessage.pts_count\r\n        }, processOpts);\r\n        break;\r\n      }\r\n  \r\n      case 'updatesCombined':\r\n      case 'updates':\r\n        appUsersManager.saveApiUsers(updateMessage.users, options.override);\r\n        appChatsManager.saveApiChats(updateMessage.chats, options.override);\r\n  \r\n        updateMessage.updates.forEach((update: Update) => {\r\n          this.processUpdate(update, processOpts);\r\n        });\r\n        break;\r\n  \r\n      default:\r\n        this.log.warn('Unknown update message', updateMessage);\r\n    }\r\n  };\r\n  \r\n  private getDifference(first = false): Promise<void> {\r\n    // this.trace('Get full diff')\r\n    const updatesState = this.updatesState;\r\n    let wasSyncing = updatesState.syncLoading;\r\n    if(!wasSyncing) {\r\n      updatesState.pendingSeqUpdates = {};\r\n      updatesState.pendingPtsUpdates = [];\r\n    }\r\n  \r\n    if(updatesState.syncPending) {\r\n      clearTimeout(updatesState.syncPending.timeout);\r\n      updatesState.syncPending = null;\r\n    }\r\n\r\n    const promise = apiManager.invokeApi('updates.getDifference', {\r\n      pts: updatesState.pts, \r\n      pts_total_limit: first /* && false  */? /* 50 */1200 : undefined,\r\n      date: updatesState.date, \r\n      qts: -1\r\n    }, {\r\n      timeout: 0x7fffffff\r\n    }).then((differenceResult) => {\r\n      this.debug && this.log.debug('Get diff result', differenceResult);\r\n\r\n      if(differenceResult._ === 'updates.differenceEmpty') {\r\n        this.debug && this.log.debug('apply empty diff', differenceResult.seq);\r\n        updatesState.date = differenceResult.date;\r\n        updatesState.seq = differenceResult.seq;\r\n        return;\r\n      }\r\n\r\n      // ! SORRY I'M SORRY I'M SORRY\r\n      if(first) {\r\n        rootScope.dispatchEvent('state_synchronizing');\r\n      }\r\n\r\n      if(differenceResult._ !== 'updates.differenceTooLong') {\r\n        appUsersManager.saveApiUsers(differenceResult.users);\r\n        appChatsManager.saveApiChats(differenceResult.chats);\r\n\r\n        // Should be first because of updateMessageID\r\n        // this.log('applying', differenceResult.other_updates.length, 'other updates')\r\n    \r\n        differenceResult.other_updates.forEach((update) => {\r\n          switch(update._) {\r\n            case 'updateChannelTooLong':\r\n            case 'updateNewChannelMessage':\r\n            case 'updateEditChannelMessage':\r\n              this.processUpdate(update);\r\n              return;\r\n          }\r\n          \r\n          this.saveUpdate(update);\r\n        });\r\n\r\n        // this.log('applying', differenceResult.new_messages.length, 'new messages')\r\n        differenceResult.new_messages.forEach((apiMessage) => {\r\n          this.saveUpdate({\r\n            _: 'updateNewMessage',\r\n            message: apiMessage,\r\n            pts: updatesState.pts,\r\n            pts_count: 0\r\n          });\r\n        });\r\n\r\n        const nextState = differenceResult._ === 'updates.difference' ? differenceResult.state : differenceResult.intermediate_state;\r\n        updatesState.seq = nextState.seq;\r\n        updatesState.pts = nextState.pts;\r\n        updatesState.date = nextState.date;\r\n      } else {\r\n        updatesState.pts = differenceResult.pts;\r\n        updatesState.date = (Date.now() / 1000 | 0) + serverTimeManager.serverTimeOffset;\r\n        delete updatesState.seq;\r\n        \r\n        this.channelStates = {};\r\n        \r\n        this.log.warn('getDifference:', differenceResult._);\r\n        rootScope.dispatchEvent('state_cleared');\r\n      }\r\n  \r\n      // this.log('apply diff', updatesState.seq, updatesState.pts)\r\n  \r\n      if(differenceResult._ === 'updates.differenceSlice') {\r\n        return this.getDifference();\r\n      } else {\r\n        this.debug && this.log.debug('finished get diff');\r\n      }\r\n    });\r\n\r\n    if(!wasSyncing) {\r\n      this.justAName(updatesState, promise);\r\n    }\r\n  \r\n    return promise;\r\n  }\r\n\r\n  private getChannelDifference(channelId: ChatId): Promise<void> {\r\n    const channelState = this.getChannelState(channelId);\r\n    const wasSyncing = channelState.syncLoading;\r\n    if(!wasSyncing) {\r\n      channelState.pendingPtsUpdates = [];\r\n    }\r\n\r\n    if(channelState.syncPending) {\r\n      clearTimeout(channelState.syncPending.timeout);\r\n      channelState.syncPending = null;\r\n    }\r\n\r\n    //this.log.trace('Get channel diff', appChatsManager.getChat(channelId), channelState.pts);\r\n    const promise = apiManager.invokeApi('updates.getChannelDifference', {\r\n      channel: appChatsManager.getChannelInput(channelId),\r\n      filter: {_: 'channelMessagesFilterEmpty'},\r\n      pts: channelState.pts,\r\n      limit: 30\r\n    }, {timeout: 0x7fffffff}).then((differenceResult) => {\r\n      this.debug && this.log.debug('Get channel diff result', differenceResult)\r\n      channelState.pts = 'pts' in differenceResult ? differenceResult.pts : undefined;\r\n  \r\n      if(differenceResult._ === 'updates.channelDifferenceEmpty') {\r\n        this.debug && this.log.debug('apply channel empty diff', differenceResult);\r\n        return;\r\n      }\r\n  \r\n      if(differenceResult._ === 'updates.channelDifferenceTooLong') {\r\n        this.debug && this.log.debug('channel diff too long', differenceResult);\r\n        delete this.channelStates[channelId];\r\n\r\n        this.saveUpdate({_: 'updateChannelReload', channel_id: channelId});\r\n        return;\r\n      }\r\n  \r\n      appUsersManager.saveApiUsers(differenceResult.users);\r\n      appChatsManager.saveApiChats(differenceResult.chats);\r\n  \r\n      // Should be first because of updateMessageID\r\n      this.debug && this.log.debug('applying', differenceResult.other_updates.length, 'channel other updates');\r\n      differenceResult.other_updates.forEach((update) => {\r\n        this.saveUpdate(update);\r\n      });\r\n  \r\n      this.debug && this.log.debug('applying', differenceResult.new_messages.length, 'channel new messages');\r\n      differenceResult.new_messages.forEach((apiMessage) => {\r\n        this.saveUpdate({\r\n          _: 'updateNewChannelMessage',\r\n          message: apiMessage,\r\n          pts: channelState.pts,\r\n          pts_count: 0\r\n        });\r\n      });\r\n  \r\n      this.debug && this.log.debug('apply channel diff', channelState.pts);\r\n  \r\n      if(differenceResult._ === 'updates.channelDifference' &&\r\n        !differenceResult.pFlags['final']) {\r\n        return this.getChannelDifference(channelId);\r\n      } else {\r\n        this.debug && this.log.debug('finished channel get diff');\r\n      }\r\n    });\r\n\r\n    if(!wasSyncing) {\r\n      this.justAName(channelState, promise, channelId);\r\n    }\r\n\r\n    return promise;\r\n  }\r\n\r\n  private justAName(state: UpdatesState, promise: UpdatesState['syncLoading'], channelId?: ChatId) {\r\n    state.syncLoading = promise;\r\n    rootScope.dispatchEvent('state_synchronizing', channelId);\r\n\r\n    promise.then(() => {\r\n      state.syncLoading = null;\r\n      rootScope.dispatchEvent('state_synchronized', channelId);\r\n    }, () => {\r\n      state.syncLoading = null;\r\n    });\r\n  }\r\n  \r\n  public addChannelState(channelId: ChatId, pts: number) {\r\n    if(!pts) {\r\n      throw new Error('Add channel state without pts ' + channelId);\r\n    }\r\n\r\n    if(!(channelId in this.channelStates)) {\r\n      this.channelStates[channelId] = {\r\n        pts,\r\n        pendingPtsUpdates: [],\r\n        syncPending: null,\r\n        syncLoading: null\r\n      };\r\n\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  public getChannelState(channelId: ChatId, pts?: number) {\r\n    if(this.channelStates[channelId] === undefined) {\r\n      this.addChannelState(channelId, pts);\r\n    }\r\n\r\n    return this.channelStates[channelId];\r\n  }\r\n\r\n  private processUpdate(update: Update, options: Partial<{\r\n    date: number,\r\n    seq: number,\r\n    seqStart: number/* ,\r\n    ignoreSyncLoading: boolean */\r\n  }> = {}) {\r\n    let channelId: ChatId;\r\n    switch(update._) {\r\n      case 'updateNewChannelMessage':\r\n      case 'updateEditChannelMessage':\r\n        channelId = appPeersManager.getPeerId(update.message.peer_id).toChatId();\r\n        break;\r\n      /* case 'updateDeleteChannelMessages':\r\n        channelId = update.channel_id;\r\n        break; */\r\n      case 'updateChannelTooLong':\r\n        channelId = update.channel_id;\r\n        if(!(channelId in this.channelStates)) {\r\n          return false;\r\n        }\r\n        break;\r\n      default:\r\n        if('channel_id' in update && 'pts' in update) {\r\n          channelId = update.channel_id;\r\n        }\r\n        break;\r\n    }\r\n  \r\n    const {pts, pts_count} = update as Update.updateNewMessage;\r\n    const curState = channelId ? this.getChannelState(channelId, pts) : this.updatesState;\r\n  \r\n    // this.log.log('process', channelId, curState.pts, update)\r\n  \r\n    if(curState.syncLoading/*  && !options.ignoreSyncLoading */) {\r\n      return false;\r\n    }\r\n  \r\n    if(update._ === 'updateChannelTooLong') {\r\n      if(!curState.lastPtsUpdateTime ||\r\n          curState.lastPtsUpdateTime < (Date.now() - SYNC_DELAY)) {\r\n        // this.log.trace('channel too long, get diff', channelId, update)\r\n        this.getChannelDifference(channelId);\r\n      }\r\n      return false;\r\n    }\r\n  \r\n    if(update._ === 'updateNewMessage' ||\r\n        update._ === 'updateEditMessage' ||\r\n        update._ === 'updateNewChannelMessage' ||\r\n        update._ === 'updateEditChannelMessage') {\r\n      const message = update.message as Message.message;\r\n      const toPeerId = appPeersManager.getPeerId(message.peer_id);\r\n      const fwdHeader: MessageFwdHeader.messageFwdHeader = message.fwd_from || {} as any;\r\n      let reason: string;\r\n      if(message.from_id && !appUsersManager.hasUser(appPeersManager.getPeerId(message.from_id), message.pFlags.post/* || channelId*/) && (reason = 'author') ||\r\n          fwdHeader.from_id && !appUsersManager.hasUser(appPeersManager.getPeerId(fwdHeader.from_id), !!(fwdHeader.from_id as Peer.peerChannel).channel_id) && (reason = 'fwdAuthor') ||\r\n          (fwdHeader.from_id as Peer.peerChannel)?.channel_id && !appChatsManager.hasChat((fwdHeader.from_id as Peer.peerChannel).channel_id, true) && (reason = 'fwdChannel') ||\r\n          toPeerId.isUser() && !appUsersManager.hasUser(toPeerId) && (reason = 'toPeer User') ||\r\n          toPeerId.isAnyChat() && !appChatsManager.hasChat(toPeerId.toChatId()) && (reason = 'toPeer Chat')) {\r\n        this.log.warn('Not enough data for message update', toPeerId, reason, message);\r\n        if(channelId && appChatsManager.hasChat(channelId)) {\r\n          this.getChannelDifference(channelId);\r\n        } else {\r\n          this.forceGetDifference();\r\n        }\r\n        return false;\r\n      }\r\n    } else if(channelId && !appChatsManager.hasChat(channelId)) {\r\n      // this.log.log('skip update, missing channel', channelId, update)\r\n      return false;\r\n    }\r\n  \r\n    let popPts: boolean;\r\n    let popSeq: boolean;\r\n  \r\n    if(pts) {\r\n      const newPts = curState.pts + (pts_count || 0);\r\n      if(newPts < pts) {\r\n        this.debug && this.log.warn('Pts hole', curState, update, channelId && appChatsManager.getChat(channelId));\r\n        curState.pendingPtsUpdates.push(update as Update.updateNewMessage);\r\n        if(!curState.syncPending && !curState.syncLoading) {\r\n          curState.syncPending = {\r\n            timeout: window.setTimeout(() => {\r\n              curState.syncPending = null;\r\n\r\n              if(curState.syncLoading) {\r\n                return;\r\n              }\r\n\r\n              if(channelId) {\r\n                this.getChannelDifference(channelId);\r\n              } else {\r\n                this.getDifference();\r\n              }\r\n            }, SYNC_DELAY)\r\n          };\r\n        }\r\n\r\n        curState.syncPending.ptsAwaiting = true;\r\n        return false;\r\n      }\r\n\r\n      if(pts > curState.pts) {\r\n        curState.pts = pts;\r\n        popPts = true;\r\n  \r\n        curState.lastPtsUpdateTime = Date.now();\r\n      } else if(pts_count) {\r\n        // this.log.warn('Duplicate update', update)\r\n        return false;\r\n      }\r\n\r\n      if(channelId && options.date && this.updatesState.date < options.date) {\r\n        this.updatesState.date = options.date;\r\n      }\r\n    } else if(!channelId && options.seq > 0) {\r\n      const seq = options.seq;\r\n      const seqStart = options.seqStart || seq;\r\n  \r\n      if(seqStart !== curState.seq + 1) {\r\n        if(seqStart > curState.seq) {\r\n          this.debug && this.log.warn('Seq hole', curState, curState.syncPending && curState.syncPending.seqAwaiting);\r\n  \r\n          if(curState.pendingSeqUpdates[seqStart] === undefined) {\r\n            curState.pendingSeqUpdates[seqStart] = {seq, date: options.date, updates: []};\r\n          }\r\n          curState.pendingSeqUpdates[seqStart].updates.push(update);\r\n  \r\n          if(!curState.syncPending) {\r\n            curState.syncPending = {\r\n              timeout: window.setTimeout(() => {\r\n                curState.syncPending = null;\r\n\r\n                if(curState.syncLoading) {\r\n                  return;\r\n                }\r\n\r\n                this.getDifference();\r\n              }, SYNC_DELAY)\r\n            };\r\n          }\r\n\r\n          if(!curState.syncPending.seqAwaiting ||\r\n            curState.syncPending.seqAwaiting < seqStart) {\r\n            curState.syncPending.seqAwaiting = seqStart;\r\n          }\r\n          return false;\r\n        }\r\n      }\r\n  \r\n      if(curState.seq !== seq) {\r\n        curState.seq = seq;\r\n        if(options.date && curState.date < options.date) {\r\n          curState.date = options.date;\r\n        }\r\n\r\n        popSeq = true;\r\n      }\r\n    }\r\n  \r\n    this.saveUpdate(update);\r\n  \r\n    if(popPts) {\r\n      this.popPendingPtsUpdate(channelId);\r\n    } else if(popSeq) {\r\n      this.popPendingSeqUpdate();\r\n    }\r\n  }\r\n\r\n  public saveUpdate(update: Update) {\r\n    //this.debug && this.log('saveUpdate', update);\r\n    rootScope.dispatchEvent(update._, update as any);\r\n  }\r\n  \r\n  public attach(langCode?: string) {\r\n    if(this.attached) return;\r\n\r\n    //return;\r\n\r\n    this.log('attach');\r\n    \r\n    this.attached = true;\r\n\r\n    appStateManager.getState().then(({updates: state}) => {\r\n      const newVersion = appStateManager.newVersion/*  || '0.8.6' */;\r\n\r\n      //rootScope.broadcast('state_synchronizing');\r\n      if(!state || !state.pts || !state.date/*  || !state.seq */) { // seq can be undefined because of updates.differenceTooLong\r\n        this.log('will get new state');\r\n\r\n        this.updatesState.syncLoading = new Promise((resolve) => {\r\n          apiManager.invokeApi('updates.getState', {}, {noErrorBox: true}).then((stateResult) => {\r\n            this.updatesState.seq = stateResult.seq;\r\n            this.updatesState.pts = stateResult.pts;\r\n            this.updatesState.date = stateResult.date;\r\n            this.saveUpdatesState();\r\n            //setTimeout(() => {\r\n              this.updatesState.syncLoading = null;\r\n              resolve();\r\n              //rootScope.broadcast('state_synchronized');\r\n            //}, 1000);\r\n        \r\n          // ! for testing\r\n          // updatesState.seq = 1\r\n          // updatesState.pts = stateResult.pts - 5000\r\n          // updatesState.date = 1\r\n          // getDifference()\r\n          });\r\n        });\r\n      } else {\r\n        // ! for testing\r\n        /* state.seq = 1;\r\n        state.pts = state.pts - 15;\r\n        state.date = 1; */\r\n        // state.pts -= 100;\r\n\r\n        /* state.date = 1628623682;\r\n        state.pts = 2007500;\r\n        state.seq = 503; */\r\n\r\n        Object.assign(this.updatesState, state);\r\n        \r\n        this.log('will get difference', Object.assign({}, state));\r\n        \r\n        this.getDifference(true)/* .finally(() => {\r\n          if(this.updatesState.syncLoading) {\r\n            rootScope.broadcast('state_synchronizing');\r\n          }\r\n        }) */;\r\n      }\r\n\r\n      apiManager.setUpdatesProcessor(this.processUpdateMessage);\r\n\r\n      // this.updatesState.syncLoading.then(() => {\r\n        this.setProxy();\r\n      // });\r\n\r\n      if(newVersion) {\r\n        this.updatesState.syncLoading.then(async() => {\r\n          const strs: Record<string, string> = {\r\n            en: 'was updated to version',\r\n            ru: 'обновлён до версии'\r\n          };\r\n\r\n          const getChangelog = (lang: string) => {\r\n            fetch(`changelogs/${lang}_${newVersion.split(' ')[0]}.md`)\r\n            .then(res => (res.status === 200 && res.ok && res.text()) || Promise.reject())\r\n            .then(text => {\r\n              const langStr = strs[lang] || strs.en;\r\n              const pre = `**Telegram Web${App.suffix} ${langStr} ${newVersion}**\\n\\n`;\r\n  \r\n              text = pre + text;\r\n  \r\n              const entities: MessageEntity[] = [];\r\n              const message = RichTextProcessor.parseMarkdown(text, entities);\r\n  \r\n              const update: Update.updateServiceNotification = {\r\n                _: 'updateServiceNotification',\r\n                entities,\r\n                message,\r\n                type: 'local',\r\n                pFlags: {},\r\n                inbox_date: Date.now() / 1000 | 0,\r\n                media: undefined\r\n              };\r\n\r\n              this.processLocalUpdate(update);\r\n            });\r\n          };\r\n          \r\n          const languages = filterUnique([langCode, 'en']);\r\n          for(const language of languages) {\r\n            try {\r\n              await getChangelog(language);\r\n              break;\r\n            } catch(err) {\r\n              \r\n            }\r\n          }\r\n        });\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nconst apiUpdatesManager = new ApiUpdatesManager();\r\nMOUNT_CLASS_TO.apiUpdatesManager = apiUpdatesManager;\r\nexport default apiUpdatesManager\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport { Document, InputFileLocation, InputStickerSet, MessagesAllStickers, MessagesFeaturedStickers, MessagesFoundStickerSets, MessagesRecentStickers, MessagesStickers, MessagesStickerSet, PhotoSize, StickerPack, StickerSet, StickerSetCovered } from '../../layer';\r\nimport { Modify } from '../../types';\r\nimport apiManager from '../mtproto/mtprotoworker';\r\nimport rootScope from '../rootScope';\r\nimport appDocsManager, { MyDocument } from './appDocsManager';\r\nimport AppStorage from '../storage';\r\nimport { MOUNT_CLASS_TO } from '../../config/debug';\r\nimport DATABASE_STATE from '../../config/databases/state';\r\nimport lottieLoader from '../rlottie/lottieLoader';\r\nimport mediaSizes from '../../helpers/mediaSizes';\r\nimport { getEmojiToneIndex } from '../../vendor/emoji';\r\nimport RichTextProcessor from '../richtextprocessor';\r\nimport assumeType from '../../helpers/assumeType';\r\nimport fixBase64String from '../../helpers/fixBase64String';\r\nimport IS_WEBM_SUPPORTED from '../../environment/webmSupport';\r\nimport forEachReverse from '../../helpers/array/forEachReverse';\r\nimport findAndSplice from '../../helpers/array/findAndSplice';\r\n\r\nconst CACHE_TIME = 3600e3;\r\n\r\nconst EMOJI_SET_LOCAL_ID = 'emoji';\r\nconst EMOJI_ANIMATIONS_SET_LOCAL_ID = 'emojiAnimations';\r\nconst LOCAL_IDS_SET = new Set([\r\n  EMOJI_SET_LOCAL_ID,\r\n  EMOJI_ANIMATIONS_SET_LOCAL_ID\r\n]);\r\n\r\n// let TEST_FILE_REFERENCE_REFRESH = true;\r\n\r\nexport type MyStickerSetInput = {\r\n  id: StickerSet.stickerSet['id'],\r\n  access_hash?: StickerSet.stickerSet['access_hash']\r\n};\r\n\r\nexport type MyMessagesStickerSet = MessagesStickerSet.messagesStickerSet;\r\n\r\nexport class AppStickersManager {\r\n  private storage = new AppStorage<Record<Long, MyMessagesStickerSet>, typeof DATABASE_STATE>(DATABASE_STATE, 'stickerSets');\r\n\r\n  private getStickerSetPromises: {[setId: Long]: Promise<MyMessagesStickerSet>};\r\n  private getStickersByEmoticonsPromises: {[emoticon: string]: Promise<Document[]>};\r\n\r\n  private greetingStickers: Document.document[];\r\n  private getGreetingStickersTimeout: number;\r\n  private getGreetingStickersPromise: Promise<void>;\r\n\r\n  private sounds: Record<string, MyDocument>;\r\n  private getAnimatedEmojiSoundsPromise: Promise<void>;\r\n  \r\n  constructor() {\r\n    this.getStickerSetPromises = {};\r\n    this.getStickersByEmoticonsPromises = {};    \r\n    this.sounds = {};\r\n\r\n    this.getAnimatedEmojiStickerSet();\r\n\r\n    rootScope.addMultipleEventsListeners({\r\n      updateNewStickerSet: (update) => {\r\n        const stickerSet = update.stickerset as MyMessagesStickerSet;\r\n        this.saveStickerSet(stickerSet, stickerSet.set.id);\r\n        rootScope.dispatchEvent('stickers_installed', stickerSet.set);\r\n      }\r\n    });\r\n\r\n    this.getGreetingStickersTimeout = window.setTimeout(() => {\r\n      this.getGreetingStickersTimeout = undefined;\r\n      this.getGreetingSticker(true);\r\n    }, 5000);\r\n  }\r\n\r\n  public getGreetingSticker(justPreload = false) {\r\n    if(this.getGreetingStickersTimeout) {\r\n      clearTimeout(this.getGreetingStickersTimeout);\r\n      this.getGreetingStickersTimeout = undefined;\r\n    }\r\n\r\n    if(!this.getGreetingStickersPromise) {\r\n      this.getGreetingStickersPromise = this.getStickersByEmoticon('👋⭐️', false).then(docs => {\r\n        if(!docs.length) throw 'NO_STICKERS';\r\n        this.greetingStickers = docs.slice() as Document.document[];\r\n        this.greetingStickers.sort((a, b) => Math.random() - Math.random());\r\n      });\r\n    }\r\n    \r\n    return this.getGreetingStickersPromise.then(() => {\r\n      let doc: Document.document;\r\n      if(!justPreload) {\r\n        doc = this.greetingStickers.shift();\r\n        this.greetingStickers.push(doc);\r\n      }\r\n\r\n      appDocsManager.downloadDoc(this.greetingStickers[0]); // preload next sticker\r\n\r\n      return doc;\r\n    });\r\n  }\r\n\r\n  public saveStickers(docs: Document[]) {\r\n    forEachReverse(docs, (doc, idx) => {\r\n      doc = appDocsManager.saveDoc(doc);\r\n\r\n      if(!doc) docs.splice(idx, 1);\r\n      else docs[idx] = doc;\r\n    });\r\n  }\r\n\r\n  public async getStickerSet(set: MyStickerSetInput, params: Partial<{\r\n    overwrite: boolean,\r\n    useCache: boolean,\r\n    saveById: boolean\r\n  }> = {}): Promise<MyMessagesStickerSet> {\r\n    const id = set.id;\r\n    if(this.getStickerSetPromises[id]) {\r\n      return this.getStickerSetPromises[id];\r\n    }\r\n\r\n    return this.getStickerSetPromises[id] = new Promise(async(resolve) => {\r\n      if(!params.overwrite) {\r\n        // const perf = performance.now();\r\n        const cachedSet = await this.storage.get(id);\r\n        if(cachedSet && cachedSet.documents?.length && ((Date.now() - cachedSet.refreshTime) < CACHE_TIME || params.useCache)) {\r\n          this.saveStickers(cachedSet.documents);\r\n          resolve(cachedSet);\r\n          delete this.getStickerSetPromises[id];\r\n          // console.log('get sticker set from cache time', id, performance.now() - perf);\r\n          return;\r\n        }\r\n      }\r\n\r\n      try {\r\n        const stickerSet = await apiManager.invokeApi('messages.getStickerSet', {\r\n          stickerset: this.getStickerSetInput(set),\r\n          hash: 0\r\n        }) as MyMessagesStickerSet;\r\n  \r\n        const saveById = params.saveById ? id : stickerSet.set.id;\r\n        this.saveStickerSet(stickerSet, saveById);\r\n  \r\n        resolve(stickerSet);\r\n      } catch(err) {\r\n        resolve(null);\r\n      }\r\n      \r\n      delete this.getStickerSetPromises[id];\r\n    });\r\n  }\r\n\r\n  public getAnimatedEmojiStickerSet() {\r\n    return Promise.all([\r\n      this.getStickerSet({id: EMOJI_SET_LOCAL_ID}, {saveById: true}),\r\n      this.getStickerSet({id: EMOJI_ANIMATIONS_SET_LOCAL_ID}, {saveById: true}),\r\n      this.getAnimatedEmojiSounds()\r\n    ]).then(([emoji, animations]) => {\r\n      return {emoji, animations};\r\n    });\r\n  }\r\n\r\n  public getAnimatedEmojiSounds(overwrite?: boolean) {\r\n    if(this.getAnimatedEmojiSoundsPromise && !overwrite) return this.getAnimatedEmojiSoundsPromise;\r\n    const promise = this.getAnimatedEmojiSoundsPromise = Promise.resolve(apiManager.getAppConfig(overwrite)).then(appConfig => {\r\n      if(this.getAnimatedEmojiSoundsPromise !== promise) {\r\n        return;\r\n      }\r\n\r\n      for(const emoji in appConfig.emojies_sounds) {\r\n        const sound = appConfig.emojies_sounds[emoji];\r\n        const bytesStr = atob(fixBase64String(sound.file_reference_base64, false));\r\n        const bytes = new Uint8Array(bytesStr.length);\r\n        for(let i = 0, length = bytes.length; i < length; ++i) {\r\n          bytes[i] = bytesStr[i].charCodeAt(0);\r\n        }\r\n\r\n        // if(TEST_FILE_REFERENCE_REFRESH) {\r\n        //   bytes[0] = bytes[1] = bytes[2] = bytes[3] = bytes[4] = 0;\r\n        //   sound.access_hash += '999';\r\n        // }\r\n        \r\n        const doc = appDocsManager.saveDoc({\r\n          _: 'document',\r\n          pFlags: {},\r\n          flags: 0,\r\n          id: sound.id,\r\n          access_hash: sound.access_hash,\r\n          attributes: [{\r\n            _: 'documentAttributeAudio',\r\n            duration: 1,\r\n            pFlags: {\r\n              voice: true\r\n            }\r\n          }],\r\n          date: 0,\r\n          dc_id: rootScope.config.this_dc,\r\n          file_reference: bytes,\r\n          mime_type: 'audio/ogg',\r\n          size: 1\r\n          // size: 101010 // test loading everytime\r\n        }, {\r\n          type: 'emojiesSounds'\r\n        });\r\n\r\n        this.sounds[emoji] = doc;\r\n      }\r\n\r\n      // if(TEST_FILE_REFERENCE_REFRESH) {\r\n      //   TEST_FILE_REFERENCE_REFRESH = false;\r\n      // }\r\n    });\r\n\r\n    return promise;\r\n  }\r\n\r\n  public async getRecentStickers(): Promise<Modify<MessagesRecentStickers.messagesRecentStickers, {\r\n    stickers: Document[]\r\n  }>> {\r\n    const res = await apiManager.invokeApiHashable({\r\n      method: 'messages.getRecentStickers',\r\n      processResult: (res) => {\r\n        assumeType<MessagesRecentStickers.messagesRecentStickers>(res);\r\n\r\n        this.saveStickers(res.stickers);\r\n        return res;\r\n      }\r\n    });\r\n\r\n    return res;\r\n  }\r\n\r\n  private cleanEmoji(emoji: string) {\r\n    return emoji.replace(/\\ufe0f/g, '').replace(/🏻|🏼|🏽|🏾|🏿/g, '');\r\n  }\r\n\r\n  public getAnimatedEmojiSticker(emoji: string, isAnimation?: boolean) {\r\n    const stickerSet = this.storage.getFromCache(isAnimation ? EMOJI_ANIMATIONS_SET_LOCAL_ID : EMOJI_SET_LOCAL_ID);\r\n    if(!stickerSet || !stickerSet.documents) return undefined;\r\n\r\n    if(isAnimation) {\r\n      if(['🧡', '💛', '💚', '💙', '💜', '🖤', '🤍', '🤎'].includes(emoji)) {\r\n        emoji = '❤️';\r\n      }\r\n    }\r\n\r\n    emoji = this.cleanEmoji(emoji);\r\n    const pack = stickerSet.packs.find(p => p.emoticon === emoji);\r\n    return pack ? appDocsManager.getDoc(pack.documents[0]) : undefined;\r\n  }\r\n\r\n  public getAnimatedEmojiSoundDocument(emoji: string) {\r\n    return this.sounds[this.cleanEmoji(emoji)];\r\n  }\r\n\r\n  public preloadAnimatedEmojiSticker(emoji: string, width?: number, height?: number) {\r\n    const preloadEmojiPromise = this.getAnimatedEmojiStickerSet().then(() => {\r\n      const doc = this.getAnimatedEmojiSticker(emoji);\r\n      if(doc) {\r\n        return appDocsManager.downloadDoc(doc)\r\n        .then(async(blob) => {\r\n          const mediaSize = mediaSizes.active.emojiSticker;\r\n          const toneIndex = getEmojiToneIndex(emoji);\r\n          const animation = await lottieLoader.loadAnimationWorker({\r\n            container: undefined,\r\n            animationData: blob,\r\n            width: width ?? mediaSize.width,\r\n            height: height ?? mediaSize.height,\r\n            name: 'doc' + doc.id,\r\n            autoplay: false,\r\n            loop: false,\r\n            toneIndex\r\n          }, 'none');\r\n\r\n          animation.addEventListener('firstFrame', () => {\r\n            appDocsManager.saveLottiePreview(doc, animation.canvas, toneIndex);\r\n            animation.remove();\r\n          }, {once: true});\r\n        });\r\n      }\r\n    });\r\n    \r\n    return Promise.all([\r\n      preloadEmojiPromise,\r\n      this.preloadAnimatedEmojiStickerAnimation(emoji)\r\n    ]);\r\n  }\r\n\r\n  public preloadAnimatedEmojiStickerAnimation(emoji: string) {\r\n    return this.getAnimatedEmojiStickerSet().then(() => {\r\n      const doc = this.getAnimatedEmojiSticker(emoji, true);\r\n      if(doc) {\r\n        const soundDoc = this.getAnimatedEmojiSoundDocument(emoji);\r\n        return Promise.all([\r\n          appDocsManager.downloadDoc(doc),\r\n          soundDoc ? appDocsManager.downloadDoc(soundDoc) : undefined\r\n        ]);\r\n      }\r\n    });\r\n  }\r\n  \r\n  public saveStickerSet(res: Omit<MessagesStickerSet.messagesStickerSet, '_'>, id: DocId) {\r\n    //console.log('stickers save set', res);w\r\n\r\n    const newSet: MessagesStickerSet = {\r\n      _: 'messages.stickerSet',\r\n      set: res.set,\r\n      packs: res.packs,\r\n      documents: res.documents as Document[]\r\n    };\r\n    \r\n    let stickerSet = this.storage.getFromCache(id);\r\n    if(stickerSet) {\r\n      Object.assign(stickerSet, newSet);\r\n    } else {\r\n      stickerSet = this.storage.setToCache(id, newSet);\r\n    }\r\n\r\n    this.saveStickers(res.documents);\r\n    \r\n    //console.log('stickers wrote', this.stickerSets);\r\n    const needSave = stickerSet.set.installed_date || LOCAL_IDS_SET.has(id as any);\r\n    stickerSet.refreshTime = Date.now();\r\n    this.storage.set({[id]: stickerSet}, !needSave);\r\n  }\r\n\r\n  public getStickerSetThumbDownloadOptions(stickerSet: StickerSet.stickerSet) {\r\n    const thumb = stickerSet.thumbs.find(thumb => thumb._ === 'photoSize') as PhotoSize.photoSize;\r\n    const dcId = stickerSet.thumb_dc_id;\r\n\r\n    const isAnimated = stickerSet.pFlags?.animated;\r\n\r\n    const input: InputFileLocation.inputStickerSetThumb = {\r\n      _: 'inputStickerSetThumb',\r\n      stickerset: this.getStickerSetInput(stickerSet),\r\n      thumb_version: stickerSet.thumb_version\r\n    };\r\n\r\n    return {dcId, location: input, size: thumb.size, mimeType: isAnimated ? 'application/x-tgsticker' : 'image/webp'};\r\n  }\r\n\r\n  /* public getStickerSetThumbURL(stickerSet: MTStickerSet) {\r\n    const thumb = stickerSet.thumb;\r\n    const dcId = stickerSet.thumb_dc_id;\r\n\r\n    const isAnimated = stickerSet.pFlags?.animated;\r\n\r\n    const input: inputStickerSetThumb = {\r\n      _: 'inputStickerSetThumb',\r\n      stickerset: this.getStickerSetInput(stickerSet),\r\n      volume_id: thumb.location.volume_id,\r\n      local_id: thumb.location.local_id\r\n    };\r\n\r\n    const url = getFileURL('document', this.getStickerSetThumbDownloadOptions(stickerSet));\r\n    return url;\r\n\r\n    //return promise;\r\n  } */\r\n\r\n  public getStickerSetInput(set: MyStickerSetInput): InputStickerSet {\r\n    if(set.id === EMOJI_SET_LOCAL_ID) {\r\n      return {\r\n        _: 'inputStickerSetAnimatedEmoji'\r\n      };\r\n    } else if(set.id === EMOJI_ANIMATIONS_SET_LOCAL_ID) {\r\n      return {\r\n        _: 'inputStickerSetAnimatedEmojiAnimations'\r\n      };\r\n    } else if(!set.access_hash) {\r\n      return {\r\n        _: 'inputStickerSetShortName',\r\n        short_name: '' + set.id\r\n      };\r\n    } else {\r\n      return {\r\n        _: 'inputStickerSetID',\r\n        id: set.id,\r\n        access_hash: set.access_hash\r\n      };\r\n    }\r\n  }\r\n\r\n  public async getFeaturedStickers() {\r\n    const res = await apiManager.invokeApiHashable({\r\n      method: 'messages.getFeaturedStickers',\r\n      processResult: (res) => {\r\n        assumeType<MessagesFeaturedStickers.messagesFeaturedStickers>(res);\r\n\r\n        forEachReverse(res.sets, (covered, idx, arr) => {\r\n          if(covered.set.pFlags.videos && !IS_WEBM_SUPPORTED) {\r\n            arr.splice(idx, 1);\r\n          }\r\n        });\r\n\r\n        res.sets.forEach(covered => {\r\n          this.saveStickerSet({set: covered.set, documents: [], packs: []}, covered.set.id);\r\n        });\r\n\r\n        return res;\r\n      }\r\n    });\r\n\r\n    return res.sets;\r\n  }\r\n\r\n  public async toggleStickerSet(set: StickerSet.stickerSet) {\r\n    if(set.installed_date) {\r\n      const res = await apiManager.invokeApi('messages.uninstallStickerSet', {\r\n        stickerset: this.getStickerSetInput(set)\r\n      });\r\n\r\n      if(res) {\r\n        delete set.installed_date;\r\n        rootScope.dispatchEvent('stickers_deleted', set);\r\n        this.storage.delete(set.id, true);\r\n        return true;\r\n      }\r\n    } else {\r\n      const res = await apiManager.invokeApi('messages.installStickerSet', {\r\n        stickerset: this.getStickerSetInput(set),\r\n        archived: false\r\n      });\r\n\r\n      if(res) {\r\n        set.installed_date = Date.now() / 1000 | 0;\r\n        rootScope.dispatchEvent('stickers_installed', set);\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  public async searchStickerSets(query: string, excludeFeatured = true) {\r\n    const flags = excludeFeatured ? 1 : 0;\r\n    const res = await apiManager.invokeApiHashable({\r\n      method: 'messages.searchStickerSets', \r\n      params: {\r\n        flags,\r\n        exclude_featured: excludeFeatured || undefined,\r\n        q: query\r\n      },\r\n      processResult: (res) => {\r\n        assumeType<MessagesFoundStickerSets.messagesFoundStickerSets>(res);\r\n\r\n        forEachReverse(res.sets, (covered, idx, arr) => {\r\n          if(covered.set.pFlags.videos && !IS_WEBM_SUPPORTED) {\r\n            arr.splice(idx, 1);\r\n          }\r\n        });\r\n\r\n        res.sets.forEach(covered => {\r\n          this.saveStickerSet({set: covered.set, documents: [], packs: []}, covered.set.id);\r\n        });\r\n\r\n        return res;\r\n      }\r\n    });\r\n\r\n    const foundSaved: StickerSetCovered[] = [];\r\n    const cache = this.storage.getCache();\r\n    for(let id in cache) {\r\n      const {set} = cache[id];\r\n\r\n      if(set.title.toLowerCase().includes(query.toLowerCase()) && !res.sets.find(c => c.set.id === set.id)) {\r\n        foundSaved.push({_: 'stickerSetCovered', set, cover: null});\r\n      }\r\n    }\r\n\r\n    return res.sets.concat(foundSaved);\r\n  }\r\n\r\n  public getAllStickers() {\r\n    return apiManager.invokeApiHashable({\r\n      method: 'messages.getAllStickers', \r\n      processResult: (allStickers) => {\r\n        assumeType<MessagesAllStickers.messagesAllStickers>(allStickers);\r\n\r\n        forEachReverse(allStickers.sets, (stickerSet, idx, arr) => {\r\n          if(stickerSet.pFlags.videos && !IS_WEBM_SUPPORTED) {\r\n            arr.splice(idx, 1);\r\n          }\r\n        });\r\n\r\n        return allStickers;\r\n      }\r\n    });\r\n  }\r\n\r\n  public preloadStickerSets() {\r\n    return this.getAllStickers().then(allStickers => {\r\n      return Promise.all((allStickers as MessagesAllStickers.messagesAllStickers).sets.map(set => this.getStickerSet(set, {useCache: true})));\r\n    });\r\n  }\r\n\r\n  // TODO: detect \"🤷\" by \"🤷‍♂️\"\r\n  public getStickersByEmoticon(emoticon: string, includeOurStickers = true) {\r\n    emoticon = RichTextProcessor.fixEmoji(emoticon);\r\n    if(this.getStickersByEmoticonsPromises[emoticon]) return this.getStickersByEmoticonsPromises[emoticon];\r\n\r\n    return this.getStickersByEmoticonsPromises[emoticon] = Promise.all([\r\n      apiManager.invokeApiHashable({\r\n        method: 'messages.getStickers', \r\n        params: {\r\n          emoticon\r\n        },\r\n        processResult: (stickers) => stickers\r\n      }),\r\n      includeOurStickers ? this.preloadStickerSets() : [],\r\n      includeOurStickers ? this.getRecentStickers() : undefined\r\n    ]).then(([messagesStickers, installedSets, recentStickers]) => {\r\n      const foundStickers = (messagesStickers as MessagesStickers.messagesStickers).stickers.map(sticker => appDocsManager.saveDoc(sticker));\r\n      const cachedStickersAnimated: Document.document[] = [], cachedStickersStatic: Document.document[] = [];\r\n\r\n      //console.log('getStickersByEmoticon', messagesStickers, installedSets, recentStickers);\r\n\r\n      const iteratePacks = (packs: StickerPack.stickerPack[]) => {\r\n        for(const pack of packs) {\r\n          const packEmoticon = RichTextProcessor.fixEmoji(pack.emoticon);\r\n          if(packEmoticon.includes(emoticon)) {\r\n            for(const docId of pack.documents) {\r\n              const doc = appDocsManager.getDoc(docId);\r\n              (doc.animated ? cachedStickersAnimated : cachedStickersStatic).push(doc);\r\n            }\r\n          }\r\n        }\r\n      };\r\n\r\n      if(recentStickers) {\r\n        iteratePacks(recentStickers.packs);\r\n        const stickers = recentStickers.stickers;\r\n        [cachedStickersAnimated, cachedStickersStatic].forEach(s => {\r\n          s.sort((a, b) => stickers.indexOf(a) - stickers.indexOf(b));\r\n        });\r\n      }\r\n\r\n      for(const set of installedSets) {\r\n        iteratePacks(set.packs);\r\n      }\r\n\r\n      /* const entities = RichTextProcessor.parseEntities(emoticon);\r\n      if(entities.length === 1) {\r\n        [cachedStickersAnimated, cachedStickersStatic].forEach(s => {\r\n          forEachReverse(s, (doc, idx) => {\r\n            const docEmoticon = RichTextProcessor.fixEmoji(doc.stickerEmojiRaw);\r\n            if(docEmoticon !== emoticon) {\r\n              s.splice(idx, 1);\r\n            }\r\n          });\r\n        });\r\n      } */\r\n\r\n      const stickers = [...new Set(cachedStickersAnimated.concat(cachedStickersStatic, foundStickers))]/* .filter(doc => !doc.animated) */;\r\n\r\n      forEachReverse(stickers, (sticker, idx, arr) => {\r\n        if(sticker.sticker === 3 && !IS_WEBM_SUPPORTED) {\r\n          arr.splice(idx, 1);\r\n        }\r\n      });\r\n\r\n      return stickers;\r\n    });\r\n  }\r\n\r\n  public pushRecentSticker(doc: MyDocument) {\r\n    const docEmoticon = RichTextProcessor.fixEmoji(doc.stickerEmojiRaw);\r\n    for(const emoticon in this.getStickersByEmoticonsPromises) {\r\n      const promise = this.getStickersByEmoticonsPromises[emoticon];\r\n      promise.then(stickers => {\r\n        const _doc = findAndSplice(stickers, _doc => _doc.id === doc.id);\r\n        if(_doc) {\r\n          stickers.unshift(_doc);\r\n        } else if(emoticon.includes(docEmoticon)) {\r\n          stickers.unshift(doc);\r\n        }\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\nconst appStickersManager = new AppStickersManager();\r\nMOUNT_CLASS_TO.appStickersManager = appStickersManager;\r\nexport default appStickersManager;\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n * \r\n * Originally from:\r\n * https://github.com/zhukov/webogram\r\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\r\n * https://github.com/zhukov/webogram/blob/master/LICENSE\r\n */\r\n\r\nimport { FileURLType, getFileNameByLocation, getFileURL } from '../../helpers/fileName';\r\nimport { Document, InputFileLocation, InputMedia, PhotoSize } from '../../layer';\r\nimport referenceDatabase, { ReferenceContext } from '../mtproto/referenceDatabase';\r\nimport opusDecodeController from '../opusDecodeController';\r\nimport { RichTextProcessor } from '../richtextprocessor';\r\nimport appDownloadManager, { DownloadBlob } from './appDownloadManager';\r\nimport appPhotosManager from './appPhotosManager';\r\nimport blur from '../../helpers/blur';\r\nimport apiManager from '../mtproto/mtprotoworker';\r\nimport { MOUNT_CLASS_TO } from '../../config/debug';\r\nimport { getFullDate } from '../../helpers/date';\r\nimport rootScope from '../rootScope';\r\nimport IS_WEBP_SUPPORTED from '../../environment/webpSupport';\r\nimport IS_WEBM_SUPPORTED from '../../environment/webmSupport';\r\nimport defineNotNumerableProperties from '../../helpers/object/defineNotNumerableProperties';\r\nimport isObject from '../../helpers/object/isObject';\r\nimport safeReplaceArrayInObject from '../../helpers/object/safeReplaceArrayInObject';\r\n\r\nexport type MyDocument = Document.document;\r\n\r\n// TODO: если залить картинку файлом, а потом перезайти в диалог - превьюшка заново скачается\r\n\r\nconst EXTENSION_MIME_TYPE_MAP = {\r\n  mov: 'video/quicktime',\r\n  gif: 'image/gif',\r\n  pdf: 'application/pdf',\r\n};\r\n\r\nexport class AppDocsManager {\r\n  private docs: {[docId: DocId]: MyDocument} = {};\r\n  private savingLottiePreview: {[docId: DocId]: true} = {};\r\n  public downloading: Map<DocId, DownloadBlob> = new Map();\r\n\r\n  constructor() {\r\n    apiManager.onServiceWorkerFail = this.onServiceWorkerFail;\r\n  }\r\n\r\n  public onServiceWorkerFail = () => {\r\n    for(const id in this.docs) {\r\n      const doc = this.docs[id];\r\n\r\n      if(doc.supportsStreaming) {\r\n        delete doc.supportsStreaming;\r\n        const cacheContext = appDownloadManager.getCacheContext(doc);\r\n        delete cacheContext.url;\r\n      }\r\n    }\r\n  };\r\n\r\n  public saveDoc(doc: Document, context?: ReferenceContext): MyDocument {\r\n    if(doc._ === 'documentEmpty') {\r\n      return undefined;\r\n    }\r\n\r\n    const oldDoc = this.docs[doc.id];\r\n\r\n    if(doc.file_reference) { // * because we can have a new object w/o the file_reference while sending\r\n      safeReplaceArrayInObject('file_reference', oldDoc, doc);\r\n      referenceDatabase.saveContext(doc.file_reference, context);\r\n    }\r\n    \r\n    //console.log('saveDoc', apiDoc, this.docs[apiDoc.id]);\r\n    // if(oldDoc) {\r\n    //   //if(doc._ !== 'documentEmpty' && doc._ === d._) {\r\n    //     if(doc.thumbs) {\r\n    //       if(!oldDoc.thumbs) oldDoc.thumbs = doc.thumbs;\r\n    //       /* else if(apiDoc.thumbs[0].bytes && !d.thumbs[0].bytes) {\r\n    //         d.thumbs.unshift(apiDoc.thumbs[0]);\r\n    //       } else if(d.thumbs[0].url) { // fix for converted thumb in safari\r\n    //         apiDoc.thumbs[0] = d.thumbs[0];\r\n    //       } */\r\n    //     }\r\n\r\n    //   //}\r\n\r\n    //   return oldDoc;\r\n\r\n    //   //return Object.assign(d, apiDoc, context);\r\n    //   //return context ? Object.assign(d, context) : d;\r\n    // }\r\n\r\n    if(!oldDoc) {\r\n      this.docs[doc.id] = doc;\r\n    }\r\n\r\n    // * exclude from state\r\n    // defineNotNumerableProperties(doc, [/* 'thumbs',  */'type', 'h', 'w', 'file_name', \r\n    // 'file', 'duration', 'downloaded', 'url', 'audioTitle', \r\n    // 'audioPerformer', 'sticker', 'stickerEmoji', 'stickerEmojiRaw', \r\n    // 'stickerSetInput', 'stickerThumbConverted', 'animated', 'supportsStreaming']);\r\n\r\n    for(let i = 0, length = doc.attributes.length; i < length; ++i) {\r\n      const attribute = doc.attributes[i];\r\n      switch(attribute._) {\r\n        case 'documentAttributeFilename':\r\n          doc.file_name = RichTextProcessor.wrapPlainText(attribute.file_name);\r\n          break;\r\n\r\n        case 'documentAttributeAudio':\r\n          doc.duration = attribute.duration;\r\n          doc.type = attribute.pFlags.voice && doc.mime_type === 'audio/ogg' ? 'voice' : 'audio';\r\n          /* if(apiDoc.type === 'audio') {\r\n            apiDoc.supportsStreaming = true;\r\n          } */\r\n          break;\r\n\r\n        case 'documentAttributeVideo':\r\n          doc.duration = attribute.duration;\r\n          doc.w = attribute.w;\r\n          doc.h = attribute.h;\r\n          //apiDoc.supportsStreaming = attribute.pFlags?.supports_streaming/*  && apiDoc.size > 524288 */;\r\n          if(/* apiDoc.thumbs &&  */attribute.pFlags.round_message) {\r\n            doc.type = 'round';\r\n          } else /* if(apiDoc.thumbs) */ {\r\n            doc.type = 'video';\r\n          }\r\n          break;\r\n\r\n        case 'documentAttributeSticker':\r\n          if(attribute.alt !== undefined) {\r\n            doc.stickerEmojiRaw = attribute.alt;\r\n          }\r\n\r\n          if(attribute.stickerset) {\r\n            if(attribute.stickerset._ === 'inputStickerSetEmpty') {\r\n              delete attribute.stickerset;\r\n            } else if(attribute.stickerset._ === 'inputStickerSetID') {\r\n              doc.stickerSetInput = attribute.stickerset;\r\n            }\r\n          }\r\n\r\n          // * there can be no thumbs, then it is a document\r\n          if(/* apiDoc.thumbs &&  */doc.mime_type === 'image/webp' && (doc.thumbs || IS_WEBP_SUPPORTED)) {\r\n            doc.type = 'sticker';\r\n            doc.sticker = 1;\r\n          } else if(doc.mime_type === 'video/webm') {\r\n            if(!IS_WEBM_SUPPORTED) {\r\n              return;\r\n            }\r\n\r\n            doc.type = 'sticker';\r\n            doc.sticker = 3;\r\n            doc.animated = true;\r\n          }\r\n          break;\r\n\r\n        case 'documentAttributeImageSize':\r\n          doc.type = 'photo';\r\n          doc.w = attribute.w;\r\n          doc.h = attribute.h;\r\n          break;\r\n\r\n        case 'documentAttributeAnimated':\r\n          if((doc.mime_type === 'image/gif' || doc.mime_type === 'video/mp4')/*  && apiDoc.thumbs */) {\r\n            doc.type = 'gif';\r\n          }\r\n\r\n          doc.animated = true;\r\n          break;\r\n      }\r\n    }\r\n    \r\n    if(!doc.mime_type) {\r\n      const ext = (doc.file_name || '').split('.').pop();\r\n      // @ts-ignore\r\n      const mappedMimeType = ext && EXTENSION_MIME_TYPE_MAP[ext.toLowerCase()];\r\n      if(mappedMimeType) {\r\n        doc.mime_type = mappedMimeType;\r\n      } else {\r\n        switch(doc.type) {\r\n          case 'gif':\r\n          case 'video':\r\n          case 'round':\r\n            doc.mime_type = 'video/mp4';\r\n            break;\r\n          case 'sticker':\r\n            doc.mime_type = 'image/webp';\r\n            break;\r\n          case 'audio':\r\n            doc.mime_type = 'audio/mpeg';\r\n            break;\r\n          case 'voice':\r\n            doc.mime_type = 'audio/ogg';\r\n            break;\r\n          default:\r\n            doc.mime_type = 'application/octet-stream';\r\n            break;\r\n        }\r\n      }\r\n    } else if(doc.mime_type === EXTENSION_MIME_TYPE_MAP.pdf) {\r\n      doc.type = 'pdf';\r\n    } else if(doc.mime_type === EXTENSION_MIME_TYPE_MAP.gif) {\r\n      doc.type = 'gif';\r\n    }\r\n\r\n    if(doc.type === 'voice' || doc.type === 'round') {\r\n      // browser will identify extension\r\n      doc.file_name = doc.type + '_' + getFullDate(new Date(doc.date * 1000), {monthAsNumber: true, leadingZero: true}).replace(/[:\\.]/g, '-').replace(', ', '_');\r\n    }\r\n\r\n    if(apiManager.isServiceWorkerOnline()) {\r\n      if((doc.type === 'gif' && doc.size > 8e6) || doc.type === 'audio' || doc.type === 'video'/*  || doc.mime_type.indexOf('video/') === 0 */) {\r\n        doc.supportsStreaming = true;\r\n        \r\n        const cacheContext = appDownloadManager.getCacheContext(doc);\r\n        if(!cacheContext.url) {\r\n          cacheContext.url = this.getFileURL(doc);\r\n        }\r\n      }\r\n    }\r\n\r\n    // for testing purposes\r\n    // doc.supportsStreaming = false;\r\n    // doc.url = ''; // * this will break upload urls\r\n    \r\n    if(!doc.file_name) {\r\n      doc.file_name = '';\r\n    }\r\n\r\n    if(doc.mime_type === 'application/x-tgsticker' && doc.file_name === 'AnimatedSticker.tgs') {\r\n      doc.type = 'sticker';\r\n      doc.animated = true;\r\n      doc.sticker = 2;\r\n    }\r\n\r\n    /* if(!doc.url) {\r\n      doc.url = this.getFileURL(doc);\r\n    } */\r\n\r\n    if(oldDoc) {\r\n      return Object.assign(oldDoc, doc);\r\n    }\r\n\r\n    return doc;\r\n  }\r\n  \r\n  public getDoc(docId: DocId | MyDocument): MyDocument {\r\n    return isObject<MyDocument>(docId) ? docId : this.docs[docId];\r\n  }\r\n\r\n  public getMediaInput(doc: MyDocument): InputMedia.inputMediaDocument {\r\n    return {\r\n      _: 'inputMediaDocument',\r\n      id: {\r\n        _: 'inputDocument',\r\n        id: doc.id,\r\n        access_hash: doc.access_hash,\r\n        file_reference: doc.file_reference\r\n      },\r\n      ttl_seconds: 0\r\n    };\r\n  }\r\n\r\n  public getInput(doc: MyDocument, thumbSize?: string): InputFileLocation.inputDocumentFileLocation {\r\n    return {\r\n      _: 'inputDocumentFileLocation',\r\n      id: doc.id,\r\n      access_hash: doc.access_hash,\r\n      file_reference: doc.file_reference,\r\n      thumb_size: thumbSize\r\n    };\r\n  }\r\n\r\n  public getFileDownloadOptions(doc: MyDocument, thumb?: PhotoSize.photoSize, queueId?: number, onlyCache?: boolean) {\r\n    const inputFileLocation = this.getInput(doc, thumb?.type);\r\n\r\n    let mimeType: string;\r\n    if(thumb) {\r\n      mimeType = doc.sticker ? 'image/webp' : 'image/jpeg'/* doc.mime_type */;\r\n    } else {\r\n      mimeType = doc.mime_type || 'application/octet-stream';\r\n    }\r\n\r\n    return {\r\n      dcId: doc.dc_id, \r\n      location: inputFileLocation, \r\n      size: thumb ? thumb.size : doc.size, \r\n      mimeType,\r\n      fileName: doc.file_name,\r\n      queueId,\r\n      onlyCache\r\n    };\r\n  }\r\n\r\n  public getFileURL(doc: MyDocument, download = false, thumb?: PhotoSize.photoSize) {\r\n    let type: FileURLType;\r\n    if(download) {\r\n      type = 'download';\r\n    } else if(thumb) {\r\n      type = 'thumb';\r\n    } else if(doc.supportsStreaming) {\r\n      type = 'stream';\r\n    } else {\r\n      type = 'document';\r\n    }\r\n\r\n    return getFileURL(type, this.getFileDownloadOptions(doc, thumb));\r\n  }\r\n\r\n  public getThumbURL(doc: MyDocument, thumb: PhotoSize.photoSize | PhotoSize.photoCachedSize | PhotoSize.photoStrippedSize) {\r\n    let promise: Promise<any> = Promise.resolve();\r\n\r\n    const cacheContext = appDownloadManager.getCacheContext(doc, thumb.type);\r\n    if(!cacheContext.url) {\r\n      if('bytes' in thumb) {\r\n        const result = blur(appPhotosManager.getPreviewURLFromBytes(thumb.bytes, !!doc.sticker));\r\n        promise = result.promise.then(() => {\r\n          cacheContext.url = result.canvas.toDataURL();\r\n        }) as any;\r\n      } else {\r\n        //return this.getFileURL(doc, false, thumb);\r\n        promise = appPhotosManager.preloadPhoto(doc, thumb) as any;\r\n      }\r\n    }\r\n\r\n    return {thumb, cacheContext, promise};\r\n  }\r\n\r\n  public getThumb(doc: MyDocument, tryNotToUseBytes = true) {\r\n    const thumb = appPhotosManager.choosePhotoSize(doc, 0, 0, !tryNotToUseBytes);\r\n    if(thumb._ === 'photoSizeEmpty') return null;\r\n    return this.getThumbURL(doc, thumb as any);\r\n  }\r\n\r\n  public getInputFileName(doc: MyDocument, thumbSize?: string) {\r\n    return getFileNameByLocation(this.getInput(doc, thumbSize), {fileName: doc.file_name});\r\n  }\r\n\r\n  public downloadDoc(doc: MyDocument, queueId?: number, onlyCache?: boolean): DownloadBlob {\r\n    const fileName = this.getInputFileName(doc);\r\n\r\n    let download: DownloadBlob = appDownloadManager.getDownload(fileName);\r\n    if(download) {\r\n      return download;\r\n    }\r\n\r\n    const downloadOptions = this.getFileDownloadOptions(doc, undefined, queueId, onlyCache);\r\n    download = appDownloadManager.download(downloadOptions);\r\n    this.downloading.set(doc.id, download);\r\n    rootScope.dispatchEvent('download_start', doc.id);\r\n\r\n    const cacheContext = appDownloadManager.getCacheContext(doc);\r\n    const originalPromise = download;\r\n    originalPromise.then((blob) => {\r\n      cacheContext.url = URL.createObjectURL(blob);\r\n      cacheContext.downloaded = blob.size;\r\n    }, () => {}).finally(() => {\r\n      this.downloading.delete(doc.id);\r\n    });\r\n    \r\n    if(doc.type === 'voice' && !opusDecodeController.isPlaySupported()) {\r\n      download = originalPromise.then(async(blob) => {\r\n        const reader = new FileReader();\r\n  \r\n        await new Promise<void>((resolve, reject) => {\r\n          reader.onloadend = (e) => {\r\n            const uint8 = new Uint8Array(e.target.result as ArrayBuffer);\r\n            //console.log('sending uint8 to decoder:', uint8);\r\n            opusDecodeController.decode(uint8).then(result => {\r\n              cacheContext.url = result.url;\r\n              resolve();\r\n            }, (err) => {\r\n              delete cacheContext.downloaded;\r\n              reject(err);\r\n            });\r\n          };\r\n    \r\n          reader.readAsArrayBuffer(blob);\r\n        });\r\n  \r\n        return blob;\r\n      });\r\n    }\r\n\r\n    download.then(() => {\r\n      rootScope.dispatchEvent('document_downloaded', doc);\r\n    });\r\n\r\n    return download;\r\n  }\r\n\r\n  public isSavingLottiePreview(doc: MyDocument, toneIndex: number) {\r\n    const key = doc.id + '-' + toneIndex;\r\n    return !!this.savingLottiePreview[key];\r\n  }\r\n\r\n  public saveLottiePreview(doc: MyDocument, canvas: HTMLCanvasElement, toneIndex: number) {\r\n    const key = doc.id + '-' + toneIndex;\r\n    if(this.savingLottiePreview[key]/*  || true */) return;\r\n\r\n    if(!doc.stickerCachedThumbs) {\r\n      defineNotNumerableProperties(doc, ['stickerCachedThumbs']);\r\n      doc.stickerCachedThumbs = {};\r\n    }\r\n\r\n    const thumb = doc.stickerCachedThumbs[toneIndex];\r\n    if(thumb && thumb.w >= canvas.width && thumb.h >= canvas.height) {\r\n      return;\r\n    }\r\n\r\n    /* if(doc.thumbs.find(t => t._ === 'photoStrippedSize') \r\n      || (doc.stickerCachedThumb || (doc.stickerSavedThumbWidth >= canvas.width && doc.stickerSavedThumbHeight >= canvas.height))) {\r\n      return;\r\n    } */\r\n\r\n    this.savingLottiePreview[key] = true;\r\n    canvas.toBlob((blob) => {\r\n      //console.log('got lottie preview', doc, blob, URL.createObjectURL(blob));\r\n\r\n      const thumb = {\r\n        url: URL.createObjectURL(blob),\r\n        w: canvas.width,\r\n        h: canvas.height\r\n      };\r\n\r\n      doc.stickerCachedThumbs[toneIndex] = thumb;\r\n\r\n      delete this.savingLottiePreview[key];\r\n      \r\n      /* const reader = new FileReader();\r\n      reader.onloadend = (e) => {\r\n        const uint8 = new Uint8Array(e.target.result as ArrayBuffer);\r\n        const thumb: PhotoSize.photoStrippedSize = {\r\n          _: 'photoStrippedSize',\r\n          bytes: uint8,\r\n          type: 'i'\r\n        };\r\n\r\n        doc.stickerSavedThumbWidth = canvas.width;\r\n        doc.stickerSavedThumbHeight = canvas.width;\r\n\r\n        defineNotNumerableProperties(thumb, ['url']);\r\n        thumb.url = URL.createObjectURL(blob);\r\n        doc.thumbs.findAndSplice(t => t._ === thumb._);\r\n        doc.thumbs.unshift(thumb);\r\n\r\n        if(!webpWorkerController.isWebpSupported()) {\r\n          doc.pFlags.stickerThumbConverted = true;\r\n        }\r\n\r\n        delete this.savingLottiePreview[doc.id];\r\n      };\r\n      reader.readAsArrayBuffer(blob); */\r\n    });\r\n  }\r\n\r\n  public saveDocFile(doc: MyDocument, queueId?: number) {\r\n    /* const options = this.getFileDownloadOptions(doc, undefined, queueId);\r\n    return appDownloadManager.downloadToDisc(options, doc.file_name); */\r\n    const promise = this.downloadDoc(doc, queueId);\r\n    promise.then(() => {\r\n      const cacheContext = appDownloadManager.getCacheContext(doc);\r\n      appDownloadManager.createDownloadAnchor(cacheContext.url, doc.file_name);\r\n    });\r\n    return promise;\r\n  }\r\n}\r\n\r\nconst appDocsManager = new AppDocsManager();\r\nMOUNT_CLASS_TO.appDocsManager = appDocsManager;\r\nexport default appDocsManager;\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n * \r\n * Originally from:\r\n * https://github.com/zhukov/webogram\r\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\r\n * https://github.com/zhukov/webogram/blob/master/LICENSE\r\n */\r\n\r\nimport type { ApplyServerTimeOffsetTask } from './timeManager';\r\nimport { MOUNT_CLASS_TO } from '../../config/debug';\r\n// import { tsNow } from '../../helpers/date';\r\nimport sessionStorage from '../sessionStorage';\r\nimport apiManager from './mtprotoworker';\r\n\r\nexport class ServerTimeManager {\r\n  /* private midnightNoOffset: number;\r\n  private midnightOffseted: Date;\r\n\r\n  private midnightOffset: number; */\r\n\r\n  public serverTimeOffset: number; // in seconds\r\n  /* private timeParams: {\r\n    midnightOffset: number,\r\n    serverTimeOffset: number\r\n  }; */\r\n\r\n  constructor() {\r\n    /* const timestampNow = tsNow(true);\r\n    this.midnightNoOffset = timestampNow - (timestampNow % 86400);\r\n    this.midnightOffseted = new Date();\r\n    this.midnightOffseted.setHours(0, 0, 0, 0);\r\n    \r\n    this.midnightOffset = this.midnightNoOffset - (Math.floor(+this.midnightOffseted / 1000)); */\r\n\r\n    this.serverTimeOffset = 0;\r\n    /* this.timeParams = {\r\n      midnightOffset: this.midnightOffset,\r\n      serverTimeOffset: this.serverTimeOffset\r\n    }; */\r\n\r\n    sessionStorage.get('server_time_offset').then((to) => {\r\n      if(to) {\r\n        this.serverTimeOffset = to;\r\n        // this.timeParams.serverTimeOffset = to;\r\n      }\r\n    });\r\n\r\n    apiManager.addTaskListener('applyServerTimeOffset', (task: ApplyServerTimeOffsetTask) => {\r\n      this.serverTimeOffset = task.payload;\r\n    });\r\n  }\r\n}\r\n\r\nconst serverTimeManager = new ServerTimeManager();\r\nMOUNT_CLASS_TO && (MOUNT_CLASS_TO.serverTimeManager = serverTimeManager);\r\nexport default serverTimeManager;\r\n","export default function assumeType<T>(x: unknown): asserts x is T {\r\n  return; // ¯\\_(ツ)_/¯\r\n}\r\n","// * Jolly Cobra's schedulers\r\n\r\nimport ctx from \"../../environment/ctx\";\r\nimport { AnyFunction, Awaited } from \"../../types\";\r\nimport noop from \"../noop\";\r\n\r\nexport type DebounceReturnType<F extends AnyFunction> = { \r\n  (...args: Parameters<F>): Promise<Awaited<ReturnType<F>>>; \r\n  clearTimeout(): void; \r\n};\r\n\r\nexport default function debounce<F extends AnyFunction>(\r\n  fn: F,\r\n  ms: number,\r\n  shouldRunFirst = true,\r\n  shouldRunLast = true,\r\n): DebounceReturnType<F> {\r\n  let waitingTimeout: number;\r\n  let waitingPromise: Promise<Awaited<ReturnType<F>>>, resolve: (result: any) => void, reject: () => void;\r\n  let hadNewCall = false;\r\n\r\n  const invoke = (args: Parameters<F>) => {\r\n    const _resolve = resolve, _reject = reject;\r\n    try {\r\n      const result = fn.apply(null, args);\r\n      _resolve(result);\r\n    } catch(err) {\r\n      console.error('debounce error', err);\r\n      // @ts-ignore\r\n      _reject(err);\r\n    }\r\n  };\r\n\r\n  const debounce = (...args: Parameters<F>) => {\r\n    if(!waitingPromise) waitingPromise = new Promise((_resolve, _reject) => (resolve = _resolve, reject = _reject));\r\n\r\n    if(waitingTimeout) {\r\n      clearTimeout(waitingTimeout);\r\n      hadNewCall = true;\r\n      reject();\r\n      waitingPromise = new Promise((_resolve, _reject) => (resolve = _resolve, reject = _reject));\r\n    } else if(shouldRunFirst) {\r\n      invoke(args);\r\n      hadNewCall = false;\r\n    }\r\n\r\n    const _waitingTimeout = ctx.setTimeout(() => {\r\n      // will run if should run last or first but with new call\r\n      if(shouldRunLast && (!shouldRunFirst || hadNewCall)) {\r\n        invoke(args);\r\n      }\r\n      \r\n      // if debounce was called during invoking\r\n      if(waitingTimeout === _waitingTimeout) {\r\n        waitingTimeout = waitingPromise = resolve = reject = undefined;\r\n        hadNewCall = false;\r\n      }\r\n    }, ms);\r\n\r\n    waitingTimeout = _waitingTimeout;\r\n    waitingPromise.catch(noop);\r\n    return waitingPromise;\r\n  };\r\n\r\n  debounce.clearTimeout = () => {\r\n    if(waitingTimeout) {\r\n      ctx.clearTimeout(waitingTimeout);\r\n      reject();\r\n      waitingTimeout = waitingPromise = resolve = reject = undefined;\r\n      hadNewCall = false;\r\n    }\r\n  };\r\n\r\n  return debounce;\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\ntype TargetType = HTMLElement;\r\nexport type OnVisibilityChange = (target: TargetType, visible: boolean) => void;\r\n\r\nexport default class VisibilityIntersector {\r\n  private observer: IntersectionObserver;\r\n  private items: Map<TargetType, boolean> = new Map();\r\n  private locked = false;\r\n\r\n  constructor(onVisibilityChange: OnVisibilityChange) {\r\n    this.observer = new IntersectionObserver((entries) => {\r\n      if(this.locked) {\r\n        return;\r\n      }\r\n\r\n      const changed: {target: TargetType, visible: boolean}[] = [];\r\n\r\n      entries.forEach(entry => {\r\n        const target = entry.target as TargetType;\r\n\r\n        if(this.items.get(target) === entry.isIntersecting) {\r\n          return;\r\n        } else {\r\n          this.items.set(target, entry.isIntersecting);\r\n        }\r\n\r\n        /* if(entry.isIntersecting) {\r\n          console.log('ooo', entry);\r\n        } */\r\n\r\n        /* if(this.locked) {\r\n          return;\r\n        } */\r\n\r\n        changed[entry.isIntersecting ? 'unshift' : 'push']({target, visible: entry.isIntersecting});\r\n\r\n        //onVisibilityChange(target, entry.isIntersecting);\r\n      });\r\n\r\n      changed.forEach(smth => {\r\n        onVisibilityChange(smth.target, smth.visible);\r\n      });\r\n    });\r\n  }\r\n\r\n  public getVisible() {\r\n    const items: TargetType[] = [];\r\n    this.items.forEach((value, key) => {\r\n      if(value) {\r\n        items.push(key);\r\n      }\r\n    });\r\n\r\n    return items;\r\n  }\r\n\r\n  public clearVisible() {\r\n    const visible = this.getVisible();\r\n    for(const target of visible) {\r\n      this.items.set(target, false);\r\n    }\r\n  }\r\n\r\n  public isVisible(target: TargetType) {\r\n    return this.items.get(target);\r\n  }\r\n\r\n  public disconnect() {\r\n    this.observer.disconnect();\r\n    this.items.clear();\r\n  }\r\n\r\n  public refresh() {\r\n    this.observer.disconnect();\r\n\r\n    //window.requestAnimationFrame(() => {\r\n      const targets = [...this.items.keys()];\r\n      for(const target of targets) {\r\n        //this.items.set(target, false);\r\n        this.observer.observe(target);\r\n      }\r\n    //});\r\n  }\r\n\r\n  public refreshVisible() {\r\n    const visible = this.getVisible();\r\n    for(const target of visible) {\r\n      this.observer.unobserve(target);\r\n    }\r\n\r\n    for(const target of visible) {\r\n      this.observer.observe(target);\r\n    }\r\n  }\r\n\r\n  public observe(target: TargetType) {\r\n    this.items.set(target, false);\r\n    this.observer.observe(target);\r\n  }\r\n\r\n  public unobserve(target: TargetType) {\r\n    this.observer.unobserve(target);\r\n    this.items.delete(target);\r\n  }\r\n\r\n  public unlock() {\r\n    this.locked = false;\r\n  }\r\n\r\n  public unlockAndRefresh() {\r\n    this.unlock();\r\n    this.refresh();\r\n  }\r\n\r\n  public lock() {\r\n    this.locked = true;\r\n  }\r\n}\r\n","export default function findAndSpliceAll<T>(array: Array<T>, verify: (value: T, index: number, arr: typeof array) => boolean) {\r\n  const out: typeof array = [];\r\n  let idx = -1;\r\n  while((idx = array.findIndex(verify)) !== -1) {\r\n    out.push(array.splice(idx, 1)[0]);\r\n  }\r\n\r\n  return out;\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport { logger, LogTypes } from \"../lib/logger\";\r\nimport VisibilityIntersector, { OnVisibilityChange } from \"./visibilityIntersector\";\r\nimport throttle from \"../helpers/schedulers/throttle\";\r\nimport findAndSpliceAll from \"../helpers/array/findAndSpliceAll\";\r\nimport indexOfAndSplice from \"../helpers/array/indexOfAndSplice\";\r\nimport findAndSplice from \"../helpers/array/findAndSplice\";\r\n\r\ntype LazyLoadElementBase = {\r\n  load: () => Promise<any>\r\n};\r\n\r\ntype LazyLoadElement = Omit<LazyLoadElementBase, 'load'> & {\r\n  load: (target?: HTMLElement) => Promise<any>,\r\n  div: HTMLElement\r\n  wasSeen?: boolean,\r\n};\r\n\r\nconst PARALLEL_LIMIT = 8;\r\n\r\nexport class LazyLoadQueueBase {\r\n  public queueId = 0;\r\n  protected queue: Array<LazyLoadElementBase> = [];\r\n  protected inProcess: Set<LazyLoadElementBase> = new Set();\r\n\r\n  protected lockPromise: Promise<void> = null;\r\n  protected unlockResolve: () => void = null;\r\n\r\n  protected log = logger('LL', LogTypes.Error);\r\n  protected processQueue: () => void;\r\n\r\n  constructor(protected parallelLimit = PARALLEL_LIMIT) {\r\n    this.processQueue = throttle(() => this._processQueue(), 20, false);\r\n  }\r\n\r\n  public clear() {\r\n    this.inProcess.clear(); // ацтеки забьются, будет плохо\r\n\r\n    this.queue.length = 0;\r\n    // unreachable code\r\n    /* for(let item of this.inProcess) { \r\n      this.lazyLoadMedia.push(item);\r\n    } */\r\n  }\r\n\r\n  public lock() {\r\n    if(this.lockPromise) return;\r\n\r\n    //const perf = performance.now();\r\n    this.lockPromise = new Promise((resolve, reject) => {\r\n      this.unlockResolve = resolve;\r\n    });\r\n\r\n    /* if(DEBUG) {\r\n      this.lockPromise.then(() => {\r\n        this.log('was locked for:', performance.now() - perf);\r\n      });\r\n    } */\r\n  }\r\n\r\n  public unlock() {\r\n    if(!this.unlockResolve) return;\r\n\r\n    this.unlockResolve();\r\n    this.unlockResolve = this.lockPromise = null;\r\n\r\n    this.processQueue();\r\n  }\r\n\r\n  protected async processItem(item: LazyLoadElementBase) {\r\n    if(this.lockPromise) {\r\n      return;\r\n    }\r\n\r\n    this.inProcess.add(item);\r\n\r\n    /* if(DEBUG) {\r\n      this.log('will load media', this.lockPromise, item);\r\n    } */\r\n\r\n    try {\r\n      //await new Promise((resolve) => setTimeout(resolve, 2e3));\r\n      //await new Promise((resolve, reject) => window.requestAnimationFrame(() => window.requestAnimationFrame(resolve)));\r\n      //await item.load(item.div);\r\n      await this.loadItem(item);\r\n    } catch(err) {\r\n      if(!['NO_ENTRY_FOUND', 'STORAGE_OFFLINE'].includes(err as string)) {\r\n        this.log.error('loadMediaQueue error:', err/* , item */);\r\n      }\r\n    }\r\n\r\n    this.inProcess.delete(item);\r\n\r\n    /* if(DEBUG) {\r\n      this.log('loaded media', item);\r\n    } */\r\n\r\n    this.processQueue();\r\n  }\r\n\r\n  protected loadItem(item: LazyLoadElementBase) {\r\n    return item.load();\r\n  }\r\n\r\n  protected getItem() {\r\n    return this.queue.shift();\r\n  }\r\n\r\n  protected addElement(method: 'push' | 'unshift', el: LazyLoadElementBase) {\r\n    this.queue[method](el);\r\n    this.processQueue();\r\n  }\r\n\r\n  protected _processQueue(item?: LazyLoadElementBase) {\r\n    if(!this.queue.length || this.lockPromise || (this.parallelLimit > 0 && this.inProcess.size >= this.parallelLimit)) return;\r\n\r\n    //console.log('_processQueue start');\r\n    let added = 0;\r\n    do {\r\n      if(item) {\r\n        indexOfAndSplice(this.queue, item);\r\n      } else {\r\n        item = this.getItem();\r\n      }\r\n  \r\n      if(item) {\r\n        this.processItem(item);\r\n      } else {\r\n        break;\r\n      }\r\n\r\n      item = null;\r\n      ++added;\r\n    } while(this.inProcess.size < this.parallelLimit && this.queue.length);\r\n    //console.log('_processQueue end, added', added, this.queue.length);\r\n  }\r\n\r\n  public push(el: LazyLoadElementBase) {\r\n    this.addElement('push', el);\r\n  }\r\n\r\n  public unshift(el: LazyLoadElementBase) {\r\n    this.addElement('unshift', el);\r\n  }\r\n}\r\n\r\nexport class LazyLoadQueueIntersector extends LazyLoadQueueBase {\r\n  protected queue: Array<LazyLoadElement> = [];\r\n  protected inProcess: Set<LazyLoadElement> = new Set();\r\n\r\n  public intersector: VisibilityIntersector;\r\n  protected intersectorTimeout: number;\r\n\r\n  constructor(protected parallelLimit = PARALLEL_LIMIT) {\r\n    super(parallelLimit);\r\n  }\r\n\r\n  public lock() {\r\n    super.lock();\r\n    this.intersector.lock();\r\n  }\r\n\r\n  public unlock() {\r\n    super.unlock();\r\n    this.intersector.unlock();\r\n  }\r\n\r\n  public unlockAndRefresh() {\r\n    super.unlock();\r\n    this.intersector.unlockAndRefresh();\r\n  }\r\n\r\n  public clear() {\r\n    super.clear();\r\n    this.intersector.disconnect();\r\n  }\r\n\r\n  public refresh() {\r\n    this.intersector.refresh();\r\n  }\r\n\r\n  protected loadItem(item: LazyLoadElement) {\r\n    return item.load(item.div);\r\n  }\r\n\r\n  protected addElement(method: 'push' | 'unshift', el: LazyLoadElement) {\r\n    const item = this.queue.find(i => i.div === el.div && i.load === el.load);\r\n    if(item) {\r\n      return false;\r\n    } else {\r\n      for(const item of this.inProcess) {\r\n        if(item.div === el.div && item.load === el.load) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    this.queue[method](el);\r\n    return true;\r\n  }\r\n\r\n  protected setProcessQueueTimeout() {\r\n    if(!this.intersectorTimeout) {\r\n      this.intersectorTimeout = window.setTimeout(() => {\r\n        this.intersectorTimeout = 0;\r\n        this.processQueue();\r\n      }, 0);\r\n    }\r\n  }\r\n\r\n  public push(el: LazyLoadElement) {\r\n    super.push(el);\r\n  }\r\n\r\n  public unshift(el: LazyLoadElement) {\r\n    super.unshift(el);\r\n  }\r\n\r\n  public unobserve(el: HTMLElement) {\r\n    findAndSpliceAll(this.queue, (i) => i.div === el);\r\n\r\n    this.intersector.unobserve(el);\r\n  }\r\n}\r\n\r\nexport default class LazyLoadQueue extends LazyLoadQueueIntersector {\r\n  constructor(protected parallelLimit = PARALLEL_LIMIT) {\r\n    super(parallelLimit);\r\n\r\n    this.intersector = new VisibilityIntersector(this.onVisibilityChange);\r\n  }\r\n\r\n  private onVisibilityChange = (target: HTMLElement, visible: boolean) => {\r\n    if(visible) {\r\n      /* if(DEBUG) {\r\n        this.log('isIntersecting', target);\r\n      } */\r\n\r\n      // need for set element first if scrolled\r\n      findAndSpliceAll(this.queue, (i) => i.div === target).forEach(item => {\r\n        item.wasSeen = true;\r\n        this.queue.unshift(item);\r\n        //this.processQueue(item);\r\n      });\r\n\r\n      this.setProcessQueueTimeout();\r\n    }\r\n  };\r\n\r\n  protected getItem() {\r\n    return findAndSplice(this.queue, item => item.wasSeen);\r\n  }\r\n\r\n  public async processItem(item: LazyLoadElement) {\r\n    await super.processItem(item);\r\n    this.intersector.unobserve(item.div);\r\n  }\r\n\r\n  protected addElement(method: 'push' | 'unshift', el: LazyLoadElement) {\r\n    const inserted = super.addElement(method, el);\r\n\r\n    if(!inserted) return false;\r\n\r\n    this.intersector.observe(el.div);\r\n    /* if(el.wasSeen) {\r\n      this.processQueue(el);\r\n    } else  */if(!el.hasOwnProperty('wasSeen')) {\r\n      el.wasSeen = false;\r\n    }\r\n    \r\n    return true;\r\n  }\r\n}\r\n\r\nexport class LazyLoadQueueRepeat extends LazyLoadQueueIntersector {\r\n  private _queue: Map<HTMLElement, LazyLoadElement> = new Map();\r\n\r\n  constructor(protected parallelLimit = PARALLEL_LIMIT, protected onVisibilityChange?: OnVisibilityChange) {\r\n    super(parallelLimit);\r\n\r\n    this.intersector = new VisibilityIntersector((target, visible) => {\r\n      const spliced = findAndSpliceAll(this.queue, (i) => i.div === target);\r\n      if(visible) {\r\n        const items = spliced.length ? spliced : [this._queue.get(target)];\r\n        items.forEach(item => {\r\n          this.queue.unshift(item || this._queue.get(target));\r\n        });\r\n      }\r\n  \r\n      this.onVisibilityChange && this.onVisibilityChange(target, visible);\r\n      this.setProcessQueueTimeout();\r\n    });\r\n  }\r\n\r\n  public clear() {\r\n    super.clear();\r\n    this._queue.clear();\r\n  }\r\n\r\n  /* public async processItem(item: LazyLoadElement) {\r\n    //await super.processItem(item);\r\n    await LazyLoadQueueBase.prototype.processItem.call(this, item);\r\n\r\n    if(this.lazyLoadMedia.length) {\r\n      this.processQueue();\r\n    }\r\n  } */\r\n\r\n  public observe(el: LazyLoadElement) {\r\n    this._queue.set(el.div, el);\r\n    this.intersector.observe(el.div);\r\n  }\r\n}\r\n\r\nexport class LazyLoadQueueRepeat2 extends LazyLoadQueueIntersector {\r\n  constructor(protected parallelLimit = PARALLEL_LIMIT, protected onVisibilityChange?: OnVisibilityChange) {\r\n    super(parallelLimit);\r\n\r\n    this.intersector = new VisibilityIntersector((target, visible) => {\r\n      const spliced = findAndSpliceAll(this.queue, (i) => i.div === target);\r\n      if(visible && spliced.length) {\r\n        spliced.forEach(item => {\r\n          this.queue.unshift(item);\r\n        });\r\n      }\r\n  \r\n      this.onVisibilityChange && this.onVisibilityChange(target, visible);\r\n      this.setProcessQueueTimeout();\r\n    });\r\n  }\r\n\r\n  public observe(el: HTMLElement) {\r\n    this.intersector.observe(el);\r\n  }\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport { MOUNT_CLASS_TO } from \"../../config/debug\";\r\n\r\nexport class AppMessagesIdsManager {\r\n  private static MESSAGE_ID_INCREMENT = 0x10000;\r\n  private static MESSAGE_ID_OFFSET = 0xFFFFFFFF;\r\n\r\n  private tempNum = 0;\r\n\r\n  public generateMessageId(messageId: number, temp = false) {\r\n    const q = AppMessagesIdsManager.MESSAGE_ID_OFFSET;\r\n    const num = temp ? ++this.tempNum : 0;\r\n    if(messageId >= q) {\r\n      if(temp) {\r\n        return messageId + (num & (AppMessagesIdsManager.MESSAGE_ID_INCREMENT - 1));\r\n      }\r\n\r\n      return messageId;\r\n    }\r\n\r\n    return q + (messageId * AppMessagesIdsManager.MESSAGE_ID_INCREMENT + (num & (AppMessagesIdsManager.MESSAGE_ID_INCREMENT - 1)));\r\n  }\r\n\r\n  /**\r\n   * * will ignore outgoing offset\r\n   */\r\n  public getServerMessageId(messageId: number) {\r\n    return this.clearMessageId(messageId, true);\r\n  }\r\n\r\n  public clearMessageId(messageId: number, toServer?: boolean) {\r\n    const q = AppMessagesIdsManager.MESSAGE_ID_OFFSET;\r\n    if(messageId < q) { // id 0 -> mid 0xFFFFFFFF, so 0xFFFFFFFF must convert to 0\r\n      return messageId;\r\n    }\r\n\r\n    const l = AppMessagesIdsManager.MESSAGE_ID_INCREMENT - 1;\r\n    const used = messageId & l;\r\n    if(used !== l) {\r\n      messageId -= used + 1;\r\n    }\r\n\r\n    return toServer ? (messageId - q) / AppMessagesIdsManager.MESSAGE_ID_INCREMENT : messageId;\r\n  }\r\n\r\n  public incrementMessageId(messageId: number, increment: number) {\r\n    return this.generateMessageId(this.getServerMessageId(messageId) + increment);\r\n  }\r\n}\r\n\r\nconst appMessagesIdsManager = new AppMessagesIdsManager();\r\nMOUNT_CLASS_TO && (MOUNT_CLASS_TO.appMessagesIdsManager = appMessagesIdsManager);\r\nexport default appMessagesIdsManager;\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\n// import { getHeavyAnimationPromise } from \"../../hooks/useHeavyAnimationCheck\";\r\n\r\nexport const loadedURLs: {[url: string]: boolean} = {};\r\nconst set = (elem: HTMLElement | HTMLImageElement | SVGImageElement | HTMLVideoElement, url: string) => {\r\n  if(elem instanceof HTMLImageElement || elem instanceof HTMLVideoElement) elem.src = url;\r\n  else if(elem instanceof SVGImageElement) elem.setAttributeNS(null, 'href', url);\r\n  else elem.style.backgroundImage = 'url(' + url + ')';\r\n};\r\n\r\n// проблема функции в том, что она не подходит для ссылок, пригодна только для blob'ов, потому что обычным ссылкам нужен 'load' каждый раз.\r\nexport default function renderImageFromUrl(\r\n  elem: HTMLElement | HTMLImageElement | SVGImageElement | HTMLVideoElement, \r\n  url: string, \r\n  callback?: () => void, \r\n  useCache = true\r\n) {\r\n  if(!url) {\r\n    console.error('renderImageFromUrl: no url?', elem, url);\r\n    callback && callback();\r\n    return;\r\n  }\r\n\r\n  if(((loadedURLs[url]/*  && false */) && useCache) || elem instanceof HTMLVideoElement) {\r\n    if(elem) {\r\n      set(elem, url);\r\n    }\r\n    \r\n    callback && callback();\r\n    // callback && getHeavyAnimationPromise().then(() => callback());\r\n  } else {\r\n    const isImage = elem instanceof HTMLImageElement;\r\n    const loader = isImage ? elem as HTMLImageElement : new Image();\r\n    //const loader = new Image();\r\n    loader.src = url;\r\n    //let perf = performance.now();\r\n    loader.addEventListener('load', () => {\r\n      if(!isImage && elem) {\r\n        set(elem, url);\r\n      }\r\n\r\n      loadedURLs[url] = true;\r\n      //console.log('onload:', url, performance.now() - perf);\r\n      // TODO: переделать прогрузки аватаров до начала анимации, иначе с этим ожиданием они неприятно появляются\r\n      // callback && getHeavyAnimationPromise().then(() => callback());\r\n      callback && callback();\r\n    }, {once: true});\r\n\r\n    if(callback) {\r\n      loader.addEventListener('error', (err) => {\r\n        console.error('Render image from url failed:', err, url, loader);\r\n        callback();\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\nexport function renderImageFromUrlPromise(elem: Parameters<typeof renderImageFromUrl>[0], url: string, useCache?: boolean) {\r\n  return new Promise<void>((resolve) => {\r\n    renderImageFromUrl(elem, url, resolve, useCache);\r\n  });\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nexport class WindowSize {\r\n  public width: number;\r\n  public height: number;\r\n\r\n  constructor() {\r\n    // @ts-ignore\r\n    const w: any = 'visualViewport' in window ? window.visualViewport : window;\r\n    const set = () => {\r\n      this.width = w.width || w.innerWidth;\r\n      this.height = w.height || w.innerHeight;\r\n    };\r\n    w.addEventListener('resize', set);\r\n    set();\r\n  }\r\n}\r\n\r\nconst windowSize = new WindowSize();\r\nexport default windowSize;\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport {Awaited} from '../types';\r\n\r\nexport default function callbackifyAll<T extends readonly unknown[] | [], R extends any>(\r\n  values: T, \r\n  callback: (result: { -readonly [P in keyof T]: Awaited<T[P]> }) => R\r\n): PromiseLike<R> | R {\r\n  if(values.some(value => value instanceof Promise)) {\r\n    return Promise.all(values).then(callback as any);\r\n  } else {\r\n    return callback(values as any);\r\n  }\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport { MOUNT_CLASS_TO } from \"../../config/debug\";\r\nimport findAndSplice from \"../../helpers/array/findAndSplice\";\r\nimport assumeType from \"../../helpers/assumeType\";\r\nimport callbackify from \"../../helpers/callbackify\";\r\nimport callbackifyAll from \"../../helpers/callbackifyAll\";\r\nimport copy from \"../../helpers/object/copy\";\r\nimport { AvailableReaction, Message, MessagePeerReaction, MessagesAvailableReactions, Update, Updates } from \"../../layer\";\r\nimport apiManager from \"../mtproto/mtprotoworker\";\r\nimport { ReferenceContext } from \"../mtproto/referenceDatabase\";\r\nimport rootScope from \"../rootScope\";\r\nimport apiUpdatesManager from \"./apiUpdatesManager\";\r\nimport appDocsManager from \"./appDocsManager\";\r\nimport appMessagesIdsManager from \"./appMessagesIdsManager\";\r\nimport appPeersManager from \"./appPeersManager\";\r\nimport appProfileManager from \"./appProfileManager\";\r\nimport appUsersManager from \"./appUsersManager\";\r\n\r\nconst SAVE_DOC_KEYS = [\r\n  'static_icon' as const,\r\n  'appear_animation' as const,\r\n  'select_animation' as const,\r\n  'activate_animation' as const,\r\n  'effect_animation' as const,\r\n  'around_animation' as const,\r\n  'center_icon' as const\r\n];\r\n\r\nconst REFERENCE_CONTEXT: ReferenceContext = {\r\n  type: 'reactions'\r\n};\r\n\r\nexport class AppReactionsManager {\r\n  private availableReactions: AvailableReaction[];\r\n  private sendReactionPromises: Map<string, Promise<any>>;\r\n  private lastSendingTimes: Map<string, number>;\r\n\r\n  constructor() {\r\n    rootScope.addEventListener('language_change', () => {\r\n      this.availableReactions = undefined;\r\n      this.getAvailableReactions();\r\n    });\r\n\r\n    this.sendReactionPromises = new Map();\r\n    this.lastSendingTimes = new Map();\r\n\r\n    setTimeout(() => {\r\n      Promise.resolve(this.getAvailableReactions()).then(async(availableReactions) => {\r\n        for(const availableReaction of availableReactions) {\r\n          await Promise.all([\r\n            availableReaction.around_animation && appDocsManager.downloadDoc(availableReaction.around_animation),\r\n            availableReaction.static_icon && appDocsManager.downloadDoc(availableReaction.static_icon),\r\n            availableReaction.appear_animation && appDocsManager.downloadDoc(availableReaction.appear_animation),\r\n            availableReaction.center_icon && appDocsManager.downloadDoc(availableReaction.center_icon)\r\n          ]);\r\n        }\r\n      });\r\n    }, 7.5e3);\r\n  }\r\n\r\n  public getAvailableReactions() {\r\n    if(this.availableReactions) return this.availableReactions;\r\n    return apiManager.invokeApiSingleProcess({\r\n      method: 'messages.getAvailableReactions',\r\n      processResult: (messagesAvailableReactions) => {\r\n        assumeType<MessagesAvailableReactions.messagesAvailableReactions>(messagesAvailableReactions);\r\n\r\n        const availableReactions = this.availableReactions = messagesAvailableReactions.reactions;\r\n        for(const reaction of availableReactions) {\r\n          for(const key of SAVE_DOC_KEYS) {\r\n            if(!reaction[key]) {\r\n              continue;\r\n            }\r\n            \r\n            reaction[key] = appDocsManager.saveDoc(reaction[key], REFERENCE_CONTEXT);\r\n          }\r\n        }\r\n\r\n        return availableReactions;\r\n      },\r\n      params: {\r\n        hash: 0\r\n      }\r\n    });\r\n  }\r\n\r\n  public getActiveAvailableReactions() {\r\n    return callbackify(this.getAvailableReactions(), (availableReactions) => {\r\n      return availableReactions.filter(availableReaction => !availableReaction.pFlags.inactive);\r\n    });\r\n  }\r\n\r\n  public getAvailableReactionsForPeer(peerId: PeerId) {\r\n    const activeAvailableReactions = this.getActiveAvailableReactions();\r\n    if(peerId.isUser()) {\r\n      return this.unshiftQuickReaction(activeAvailableReactions);\r\n    }\r\n\r\n    const chatFull = appProfileManager.getChatFull(peerId.toChatId());\r\n    return callbackifyAll([activeAvailableReactions, chatFull, this.getQuickReaction()], ([activeAvailableReactions, chatFull, quickReaction]) => {\r\n      const chatAvailableReactions = chatFull.available_reactions ?? [];\r\n\r\n      const filteredChatAvailableReactions = chatAvailableReactions.map(reaction => {\r\n        return activeAvailableReactions.find(availableReaction => availableReaction.reaction === reaction);\r\n      }).filter(Boolean);\r\n\r\n      return this.unshiftQuickReactionInner(filteredChatAvailableReactions, quickReaction);\r\n    });\r\n  }\r\n\r\n  private unshiftQuickReactionInner(availableReactions: AvailableReaction.availableReaction[], quickReaction: AvailableReaction.availableReaction) {\r\n    const availableReaction = findAndSplice(availableReactions, availableReaction => availableReaction.reaction === quickReaction.reaction);\r\n    if(availableReaction) {\r\n      availableReactions.unshift(availableReaction);\r\n    }\r\n\r\n    return availableReactions;\r\n  }\r\n\r\n  private unshiftQuickReaction(\r\n    availableReactions: AvailableReaction.availableReaction[] | PromiseLike<AvailableReaction.availableReaction[]>, \r\n    quickReaction: ReturnType<AppReactionsManager['getQuickReaction']> = this.getQuickReaction()\r\n  ) {\r\n    return callbackifyAll([\r\n      availableReactions,\r\n      quickReaction\r\n    ], ([availableReactions, quickReaction]) => {\r\n      return this.unshiftQuickReactionInner(availableReactions, quickReaction);\r\n    });\r\n  }\r\n\r\n  public getAvailableReactionsByMessage(message: Message.message) {\r\n    const peerId = (message.fwd_from?.channel_post && appPeersManager.isMegagroup(message.peerId) && message.fwdFromId) || message.peerId;\r\n    return this.getAvailableReactionsForPeer(peerId);\r\n  }\r\n\r\n  public isReactionActive(reaction: string) {\r\n    if(!this.availableReactions) return false;\r\n    return !!this.availableReactions.find(availableReaction => availableReaction.reaction === reaction);\r\n  }\r\n\r\n  public getQuickReaction() {\r\n    return callbackifyAll([\r\n      apiManager.getAppConfig(),\r\n      this.getAvailableReactions()\r\n    ], ([appConfig, availableReactions]) => {\r\n      return availableReactions.find(reaction => reaction.reaction === appConfig.reactions_default);\r\n    });\r\n  }\r\n\r\n  public getReactionCached(reaction: string) {\r\n    return this.availableReactions.find(availableReaction => availableReaction.reaction === reaction);\r\n  }\r\n\r\n  public getReaction(reaction: string) {\r\n    return callbackify(this.getAvailableReactions(), () => {\r\n      return this.getReactionCached(reaction);\r\n    });\r\n  }\r\n\r\n  public getMessagesReactions(peerId: PeerId, mids: number[]) {\r\n    return apiManager.invokeApiSingleProcess({\r\n      method: 'messages.getMessagesReactions',\r\n      params: {\r\n        id: mids.map(mid => appMessagesIdsManager.getServerMessageId(mid)),\r\n        peer: appPeersManager.getInputPeerById(peerId)\r\n      },\r\n      processResult: (updates) => {\r\n        apiUpdatesManager.processUpdateMessage(updates);\r\n\r\n        // const update = (updates as Updates.updates).updates.find(update => update._ === 'updateMessageReactions') as Update.updateMessageReactions;\r\n        // return update.reactions;\r\n      }\r\n    });\r\n  }\r\n\r\n  public getMessageReactionsList(peerId: PeerId, mid: number, limit: number, reaction?: string, offset?: string) {\r\n    return apiManager.invokeApiSingleProcess({\r\n      method: 'messages.getMessageReactionsList',\r\n      params: {\r\n        peer: appPeersManager.getInputPeerById(peerId),\r\n        id: appMessagesIdsManager.getServerMessageId(mid),\r\n        limit,\r\n        reaction,\r\n        offset\r\n      },\r\n      processResult: (messageReactionsList) => {\r\n        appUsersManager.saveApiUsers(messageReactionsList.users);\r\n        return messageReactionsList;\r\n      }\r\n    });\r\n  }\r\n\r\n  public setDefaultReaction(reaction: string) {\r\n    return apiManager.invokeApi('messages.setDefaultReaction', {reaction}).then(value => {\r\n      if(value) {\r\n        const appConfig = rootScope.appConfig;\r\n        if(appConfig) {\r\n          appConfig.reactions_default = reaction;\r\n        } else { // if no config or loading it - overwrite\r\n          apiManager.getAppConfig(true);\r\n        }\r\n\r\n        rootScope.dispatchEvent('quick_reaction', reaction);\r\n      }\r\n\r\n      return value;\r\n    });\r\n  }\r\n\r\n  public sendReaction(message: Message.message, reaction?: string, onlyLocal?: boolean) {\r\n    const lastSendingTimeKey = message.peerId + '_' + message.mid;\r\n    const lastSendingTime = this.lastSendingTimes.get(lastSendingTimeKey);\r\n    if(lastSendingTime) {\r\n      return;\r\n    } else {\r\n      this.lastSendingTimes.set(lastSendingTimeKey, Date.now());\r\n      setTimeout(() => {\r\n        this.lastSendingTimes.delete(lastSendingTimeKey);\r\n      }, 333);\r\n    }\r\n\r\n    const {peerId, mid} = message;\r\n    const myPeerId = rootScope.myId;\r\n\r\n    let reactions = onlyLocal ? message.reactions : copy(message.reactions);\r\n    let chosenReactionIdx = reactions ? reactions.results.findIndex((reactionCount) => reactionCount.pFlags.chosen) : -1;\r\n    let chosenReaction = chosenReactionIdx !== -1 && reactions.results[chosenReactionIdx];\r\n    if(chosenReaction) { // clear current reaction\r\n      --chosenReaction.count;\r\n      delete chosenReaction.pFlags.chosen;\r\n\r\n      if(reaction === chosenReaction.reaction) {\r\n        reaction = undefined;\r\n      }\r\n\r\n      if(!chosenReaction.count) {\r\n        reactions.results.splice(chosenReactionIdx, 1);\r\n      }/*  else {\r\n        insertInDescendSortedArray(reactions.results, chosenReaction, 'count', chosenReactionIdx);\r\n      } */\r\n\r\n      if(reactions.recent_reactions) {\r\n        findAndSplice(reactions.recent_reactions, (recentReaction) => appPeersManager.getPeerId(recentReaction.peer_id) === myPeerId);\r\n      }\r\n\r\n      if(!reactions.results.length) {\r\n        reactions = undefined;\r\n      }\r\n    }\r\n\r\n    if(reaction) {\r\n      if(!reactions) {\r\n        reactions/*  = message.reactions */ = {\r\n          _: 'messageReactions',\r\n          results: [],\r\n          pFlags: {}\r\n        };\r\n\r\n        if(!appPeersManager.isBroadcast(message.peerId)) {\r\n          reactions.pFlags.can_see_list = true;\r\n        }\r\n      }\r\n\r\n      let reactionCountIdx = reactions.results.findIndex((reactionCount) => reactionCount.reaction === reaction);\r\n      let reactionCount = reactionCountIdx !== -1 && reactions.results[reactionCountIdx];\r\n      if(!reactionCount) {\r\n        reactionCount = {\r\n          _: 'reactionCount',\r\n          count: 0,\r\n          reaction,\r\n          pFlags: {}\r\n        };\r\n\r\n        reactionCountIdx = reactions.results.push(reactionCount) - 1;\r\n      }\r\n\r\n      ++reactionCount.count;\r\n      reactionCount.pFlags.chosen = true;\r\n\r\n      if(!reactions.recent_reactions && reactions.pFlags.can_see_list) {\r\n        reactions.recent_reactions = [];\r\n      }\r\n\r\n      if(reactions.recent_reactions) {\r\n        const userReaction: MessagePeerReaction = {\r\n          _: 'messagePeerReaction',\r\n          reaction,\r\n          peer_id: appPeersManager.getOutputPeer(myPeerId)\r\n        };\r\n\r\n        if(!appPeersManager.isMegagroup(peerId)) {\r\n          reactions.recent_reactions.push(userReaction);\r\n          reactions.recent_reactions = reactions.recent_reactions.slice(-3);\r\n        } else {\r\n          reactions.recent_reactions.unshift(userReaction);\r\n          reactions.recent_reactions = reactions.recent_reactions.slice(0, 3);\r\n        }\r\n      }\r\n\r\n      // insertInDescendSortedArray(reactions.results, reactionCount, 'count', reactionCountIdx);\r\n    }\r\n\r\n    const availableReactions = this.availableReactions;\r\n    if(reactions && availableReactions?.length) {\r\n      const indexes: Map<string, number> = new Map();\r\n      availableReactions.forEach((availableReaction, idx) => {\r\n        indexes.set(availableReaction.reaction, idx);\r\n      });\r\n\r\n      reactions.results.sort((a, b) => {\r\n        return (b.count - a.count) || (indexes.get(a.reaction) - indexes.get(b.reaction));\r\n      });\r\n    }\r\n\r\n    if(onlyLocal) {\r\n      message.reactions = reactions;\r\n      rootScope.dispatchEvent('messages_reactions', [{message, changedResults: []}]);\r\n      return Promise.resolve();\r\n    }\r\n\r\n    apiUpdatesManager.processLocalUpdate({\r\n      _: 'updateMessageReactions',\r\n      peer: message.peer_id,\r\n      msg_id: message.id,\r\n      reactions: reactions,\r\n      local: true\r\n    });\r\n\r\n    const promiseKey = [peerId, mid].join('-');\r\n    const msgId = appMessagesIdsManager.getServerMessageId(mid);\r\n    const promise = apiManager.invokeApi('messages.sendReaction', {\r\n      peer: appPeersManager.getInputPeerById(peerId),\r\n      msg_id: msgId,\r\n      reaction\r\n    }).then((updates) => {\r\n      assumeType<Updates.updates>(updates);\r\n      \r\n      const editMessageUpdateIdx = updates.updates.findIndex(update => update._ === 'updateEditMessage' || update._ === 'updateEditChannelMessage');\r\n      if(editMessageUpdateIdx !== -1) {\r\n        const editMessageUpdate = updates.updates[editMessageUpdateIdx] as Update.updateEditMessage | Update.updateEditChannelMessage;\r\n        updates.updates[editMessageUpdateIdx] = {\r\n          _: 'updateMessageReactions',\r\n          msg_id: msgId,\r\n          peer: appPeersManager.getOutputPeer(peerId),\r\n          reactions: (editMessageUpdate.message as Message.message).reactions,\r\n          pts: editMessageUpdate.pts,\r\n          pts_count: editMessageUpdate.pts_count\r\n        };\r\n      }\r\n\r\n      apiUpdatesManager.processUpdateMessage(updates);\r\n    }).catch(err => {\r\n      if(err.type === 'REACTION_INVALID' && this.sendReactionPromises.get(promiseKey) === promise) {\r\n        this.sendReaction(message, chosenReaction?.reaction, true);\r\n      }\r\n    }).finally(() => {\r\n      if(this.sendReactionPromises.get(promiseKey) === promise) {\r\n        this.sendReactionPromises.delete(promiseKey);\r\n      }\r\n    });\r\n    \r\n    this.sendReactionPromises.set(promiseKey, promise);\r\n    return promise;\r\n  }\r\n}\r\n\r\nconst appReactionsManager = new AppReactionsManager();\r\nMOUNT_CLASS_TO && (MOUNT_CLASS_TO.appReactionsManager = appReactionsManager);\r\nexport default appReactionsManager;\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nexport default function htmlToSpan(html: string | DocumentFragment) {\r\n  const span = document.createElement('span');\r\n  if(typeof(html) === 'string') span.innerHTML = html;\r\n  else span.append(html);\r\n  return span;\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n * \r\n * Originally from:\r\n * https://github.com/zhukov/webogram\r\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\r\n * https://github.com/zhukov/webogram/blob/master/LICENSE\r\n */\r\n\r\nimport { fontFamily } from \"../../components/middleEllipsis\";\r\nimport { MOUNT_CLASS_TO } from \"../../config/debug\";\r\nimport deferredPromise, { CancellablePromise } from \"../../helpers/cancellablePromise\";\r\nimport { tsNow } from \"../../helpers/date\";\r\nimport { IS_MOBILE } from \"../../environment/userAgent\";\r\nimport { InputNotifyPeer, InputPeerNotifySettings, NotifyPeer, PeerNotifySettings, Update } from \"../../layer\";\r\nimport I18n from \"../langPack\";\r\nimport apiManager from \"../mtproto/mtprotoworker\";\r\nimport webPushApiManager, { PushSubscriptionNotify } from \"../mtproto/webPushApiManager\";\r\nimport rootScope from \"../rootScope\";\r\nimport stateStorage from \"../stateStorage\";\r\nimport apiUpdatesManager from \"./apiUpdatesManager\";\r\nimport appChatsManager from \"./appChatsManager\";\r\nimport appPeersManager from \"./appPeersManager\";\r\nimport appRuntimeManager from \"./appRuntimeManager\";\r\nimport appStateManager from \"./appStateManager\";\r\nimport appUsersManager from \"./appUsersManager\";\r\nimport IS_VIBRATE_SUPPORTED from \"../../environment/vibrateSupport\";\r\nimport { MUTE_UNTIL } from \"../mtproto/mtproto_config\";\r\nimport throttle from \"../../helpers/schedulers/throttle\";\r\nimport deepEqual from \"../../helpers/object/deepEqual\";\r\nimport convertInputKeyToKey from \"../../helpers/string/convertInputKeyToKey\";\r\n\r\ntype MyNotification = Notification & {\r\n  hidden?: boolean,\r\n  show?: () => void,\r\n};\r\n\r\nexport type NotifyOptions = Partial<{\r\n  tag: string;\r\n  image: string;\r\n  key: string;\r\n  title: string;\r\n  message: string;\r\n  silent: boolean;\r\n  onclick: () => void;\r\n  noIncrement: boolean;\r\n}>;\r\n\r\nexport type NotificationSettings = {\r\n  nodesktop: boolean,\r\n  volume: number,\r\n  novibrate: boolean,\r\n  nopreview: boolean,\r\n  nopush: boolean,\r\n  nosound: boolean\r\n};\r\n\r\ntype ImSadAboutIt = Promise<PeerNotifySettings> | PeerNotifySettings;\r\nexport class AppNotificationsManager {\r\n  private notificationsUiSupport: boolean;\r\n  private notificationsShown: {[key: string]: MyNotification | true} = {};\r\n  private notificationIndex = 0;\r\n  private notificationsCount = 0;\r\n  private soundsPlayed: {[tag: string]: number} = {};\r\n  private vibrateSupport = IS_VIBRATE_SUPPORTED;\r\n  private nextSoundAt: number;\r\n  private prevSoundVolume: number;\r\n  private peerSettings = {\r\n    notifyPeer: {} as {[peerId: PeerId]: ImSadAboutIt},\r\n    notifyUsers: null as ImSadAboutIt,\r\n    notifyChats: null as ImSadAboutIt,\r\n    notifyBroadcasts: null as ImSadAboutIt\r\n  };\r\n  //private exceptions: {[peerId: string]: PeerNotifySettings} = {};\r\n  private notifyContactsSignUp: Promise<boolean>;\r\n  private faviconEl: HTMLLinkElement = document.head.querySelector('link[rel=\"icon\"]');\r\n\r\n  private titleBackup = document.title;\r\n  private titleChanged = false;\r\n  private titleInterval: number;\r\n  private prevFavicon: string;\r\n  private stopped = false;\r\n\r\n  private settings: NotificationSettings = {} as any;\r\n\r\n  private registeredDevice: any;\r\n  private pushInited = false;\r\n\r\n  private topMessagesDeferred: CancellablePromise<void>;\r\n\r\n  private notifySoundEl: HTMLElement;\r\n\r\n  private getNotifyPeerTypePromise: Promise<any>;\r\n\r\n  private checkMuteUntilTimeout: number;\r\n  private checkMuteUntilThrottled: () => void;\r\n\r\n  constructor() {\r\n    // @ts-ignore\r\n    navigator.vibrate = navigator.vibrate || navigator.mozVibrate || navigator.webkitVibrate;\r\n\r\n    this.notificationsUiSupport = ('Notification' in window) || ('mozNotification' in navigator);\r\n\r\n    this.topMessagesDeferred = deferredPromise<void>();\r\n\r\n    this.notifySoundEl = document.createElement('div');\r\n    this.notifySoundEl.id = 'notify-sound';\r\n    document.body.append(this.notifySoundEl);\r\n\r\n    this.checkMuteUntilThrottled = throttle(this.checkMuteUntil, 1000, false);\r\n\r\n    rootScope.addEventListener('instance_deactivated', () => {\r\n      this.stop();\r\n    });\r\n\r\n    rootScope.addEventListener('instance_activated', () => {\r\n      if(this.stopped) {\r\n        this.start();\r\n      }\r\n    });\r\n\r\n    rootScope.addEventListener('idle', (newVal) => {\r\n      if(this.stopped) {\r\n        return;\r\n      }\r\n\r\n      if(!newVal) {\r\n        this.clear();\r\n      }\r\n\r\n      this.toggleToggler();\r\n    });\r\n\r\n    rootScope.addMultipleEventsListeners({\r\n      updateNotifySettings: (update) => {\r\n        const peerId = update.peer._ === 'notifyPeer' && appPeersManager.getPeerId(update.peer.peer);\r\n        const key = update.peer._ !== 'notifyPeer' ? update.peer._ : undefined;\r\n        this.savePeerSettings({\r\n          key,\r\n          peerId, \r\n          settings: update.notify_settings\r\n        });\r\n        rootScope.dispatchEvent('notify_settings', update);\r\n      }\r\n    });\r\n\r\n    rootScope.addEventListener('push_init', (tokenData) => {\r\n      this.pushInited = true;\r\n      if(!this.settings.nodesktop && !this.settings.nopush) {\r\n        if(tokenData) {\r\n          this.registerDevice(tokenData);\r\n        } else {\r\n          webPushApiManager.subscribe();\r\n        }\r\n      } else {\r\n        this.unregisterDevice(tokenData);\r\n      }\r\n    });\r\n    rootScope.addEventListener('push_subscribe', (tokenData) => {\r\n      this.registerDevice(tokenData);\r\n    });\r\n    rootScope.addEventListener('push_unsubscribe', (tokenData) => {\r\n      this.unregisterDevice(tokenData);\r\n    });\r\n\r\n    rootScope.addEventListener('dialogs_multiupdate', () => {\r\n      //unregisterTopMsgs()\r\n      this.topMessagesDeferred.resolve();\r\n    }, {once: true});\r\n\r\n    rootScope.addEventListener('push_notification_click', (notificationData) => {\r\n      if(notificationData.action === 'push_settings') {\r\n        /* this.topMessagesDeferred.then(() => {\r\n          $modal.open({\r\n            templateUrl: templateUrl('settings_modal'),\r\n            controller: 'SettingsModalController',\r\n            windowClass: 'settings_modal_window mobile_modal',\r\n            backdrop: 'single'\r\n          })\r\n        }); */\r\n        return;\r\n      }\r\n\r\n      if(notificationData.action === 'mute1d') {\r\n        apiManager.invokeApi('account.updateDeviceLocked', {\r\n          period: 86400\r\n        }).then(() => {\r\n          // var toastData = toaster.pop({\r\n          //   type: 'info',\r\n          //   body: _('push_action_mute1d_success'),\r\n          //   bodyOutputType: 'trustedHtml',\r\n          //   clickHandler: () => {\r\n          //     toaster.clear(toastData)\r\n          //   },\r\n          //   showCloseButton: false\r\n          // })\r\n        });\r\n\r\n        return;\r\n      }\r\n\r\n      const peerId = notificationData.custom && notificationData.custom.peerId.toPeerId();\r\n      console.log('click', notificationData, peerId);\r\n      if(peerId) {\r\n        this.topMessagesDeferred.then(() => {\r\n          if(notificationData.custom.channel_id &&\r\n              !appChatsManager.hasChat(notificationData.custom.channel_id)) {\r\n            return;\r\n          }\r\n\r\n          if(peerId.isUser() && !appUsersManager.hasUser(peerId)) {\r\n            return;\r\n          }\r\n\r\n          rootScope.dispatchEvent('history_focus', {\r\n            peerId,\r\n            mid: +notificationData.custom.msg_id\r\n          });\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  private toggleToggler(enable = rootScope.idle.isIDLE) {\r\n    if(IS_MOBILE) return;\r\n\r\n    const resetTitle = () => {\r\n      this.titleChanged = false;\r\n      document.title = this.titleBackup;\r\n      this.setFavicon();\r\n    };\r\n\r\n    window.clearInterval(this.titleInterval);\r\n    this.titleInterval = 0;\r\n\r\n    if(!enable) {\r\n      resetTitle();\r\n    } else {\r\n      this.titleInterval = window.setInterval(() => {\r\n        const count = this.notificationsCount;\r\n        if(!count) {\r\n          this.toggleToggler(false);\r\n        } else if(this.titleChanged) {\r\n          resetTitle();\r\n        } else {\r\n          this.titleChanged = true;\r\n          document.title = I18n.format('Notifications.Count', true, [count]);\r\n          //this.setFavicon('assets/img/favicon_unread.ico');\r\n\r\n          // fetch('assets/img/favicon.ico')\r\n          // .then(res => res.blob())\r\n          // .then(blob => {\r\n            // const img = document.createElement('img');\r\n            // img.src = URL.createObjectURL(blob);\r\n\r\n            const canvas = document.createElement('canvas');\r\n            canvas.width = 32 * window.devicePixelRatio;\r\n            canvas.height = canvas.width;\r\n  \r\n            const ctx = canvas.getContext('2d');\r\n            ctx.beginPath();\r\n            ctx.arc(canvas.width / 2, canvas.height / 2, canvas.width / 2, 0, 2 * Math.PI, false);\r\n            ctx.fillStyle = '#3390ec';\r\n            ctx.fill();\r\n\r\n            let fontSize = 24;\r\n            let str = '' + count;\r\n            if(count < 10) {\r\n              fontSize = 22;\r\n            } else if(count < 100) {\r\n              fontSize = 20;\r\n            } else {\r\n              str = '99+';\r\n              fontSize = 16;\r\n            }\r\n\r\n            fontSize *= window.devicePixelRatio;\r\n            \r\n            ctx.font = `700 ${fontSize}px ${fontFamily}`;\r\n            ctx.textBaseline = 'middle';\r\n            ctx.textAlign = 'center';\r\n            ctx.fillStyle = 'white';\r\n            ctx.fillText(str, canvas.width / 2, canvas.height * .5625);\r\n\r\n            /* const ctx = canvas.getContext('2d');\r\n            ctx.drawImage(img, 0, 0, canvas.width, canvas.height); */\r\n  \r\n            this.setFavicon(canvas.toDataURL());\r\n          // });\r\n        }\r\n      }, 1000);\r\n    }\r\n  }\r\n\r\n  public updateLocalSettings = () => {\r\n    Promise.all(['notify_nodesktop', 'notify_volume', 'notify_novibrate', 'notify_nopreview', 'notify_nopush'].map(k => stateStorage.get(k as any)))\r\n    .then((updSettings) => {\r\n      this.settings.nodesktop = updSettings[0];\r\n      this.settings.volume = updSettings[1] === undefined ? 0.5 : updSettings[1];\r\n      this.settings.novibrate = updSettings[2];\r\n      this.settings.nopreview = updSettings[3];\r\n      this.settings.nopush = updSettings[4];\r\n\r\n      if(this.pushInited) {\r\n        const needPush = !this.settings.nopush && !this.settings.nodesktop && webPushApiManager.isAvailable || false;\r\n        const hasPush = this.registeredDevice !== false;\r\n        if(needPush !== hasPush) {\r\n          if(needPush) {\r\n            webPushApiManager.subscribe();\r\n          } else {\r\n            webPushApiManager.unsubscribe();\r\n          }\r\n        }\r\n      }\r\n\r\n      webPushApiManager.setSettings(this.settings);\r\n    });\r\n\r\n    appStateManager.getState().then(state => {\r\n      this.settings.nosound = !state.settings.notifications.sound;\r\n    });\r\n  }\r\n\r\n  public getLocalSettings() {\r\n    return this.settings;\r\n  }\r\n\r\n  public getNotifySettings(peer: InputNotifyPeer): ImSadAboutIt {\r\n    let key: any = convertInputKeyToKey(peer._);\r\n    let obj: any = this.peerSettings[key as NotifyPeer['_']];\r\n\r\n    let peerId: PeerId;\r\n    if(peer._ === 'inputNotifyPeer') {\r\n      peerId = key = appPeersManager.getPeerId(peer.peer);\r\n      obj = obj[key];\r\n    }\r\n\r\n    if(obj) {\r\n      return obj;\r\n    }\r\n\r\n    return (obj || this.peerSettings)[key] = apiManager.invokeApi('account.getNotifySettings', {peer})\r\n    .then(settings => {\r\n      this.savePeerSettings({\r\n        key,\r\n        peerId, \r\n        settings\r\n      });\r\n      \r\n      return settings;\r\n    });\r\n  }\r\n\r\n  public getNotifyPeerTypeSettings() {\r\n    if(this.getNotifyPeerTypePromise) return this.getNotifyPeerTypePromise;\r\n\r\n    const promises = (['inputNotifyBroadcasts', 'inputNotifyUsers', 'inputNotifyChats'] as Exclude<InputNotifyPeer['_'], 'inputNotifyPeer'>[])\r\n    .map((inputKey) => {\r\n      return this.getNotifySettings({_: inputKey});\r\n    });\r\n\r\n    return this.getNotifyPeerTypePromise = Promise.all(promises);\r\n  }\r\n\r\n  public updateNotifySettings(peer: InputNotifyPeer, settings: InputPeerNotifySettings) {\r\n    //this.savePeerSettings(peerId, settings);\r\n\r\n    /* const inputSettings: InputPeerNotifySettings = copy(settings) as any;\r\n    inputSettings._ = 'inputPeerNotifySettings'; */\r\n\r\n    return apiManager.invokeApi('account.updateNotifySettings', {\r\n      peer,\r\n      settings\r\n    }).then(value => {\r\n      if(value) {\r\n        apiUpdatesManager.processLocalUpdate({\r\n          _: 'updateNotifySettings', \r\n          peer: {\r\n            ...peer as any,\r\n            _: convertInputKeyToKey(peer._)\r\n          }, \r\n          notify_settings: { // ! WOW, IT WORKS !\r\n            ...settings,\r\n            _: 'peerNotifySettings',\r\n          }\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  public getNotifyExceptions() {\r\n    apiManager.invokeApi('account.getNotifyExceptions', {compare_sound: true})\r\n    .then((updates) => {\r\n      apiUpdatesManager.processUpdateMessage(updates);\r\n    });\r\n  }\r\n\r\n  public getContactSignUpNotification() {\r\n    if(this.notifyContactsSignUp) return this.notifyContactsSignUp;\r\n    return this.notifyContactsSignUp = apiManager.invokeApi('account.getContactSignUpNotification');\r\n  }\r\n\r\n  public setContactSignUpNotification(silent: boolean) {\r\n    apiManager.invokeApi('account.setContactSignUpNotification', {silent})\r\n    .then(value => {\r\n      this.notifyContactsSignUp = Promise.resolve(!silent);\r\n    });\r\n  }\r\n\r\n  private setFavicon(href: string = 'assets/img/favicon.ico') {\r\n    if(this.prevFavicon === href) {\r\n      return;\r\n    }\r\n\r\n    const link = this.faviconEl.cloneNode() as HTMLLinkElement;\r\n    link.href = href;\r\n    this.faviconEl.parentNode.replaceChild(link, this.faviconEl);\r\n    this.faviconEl = link;\r\n\r\n    this.prevFavicon = href;\r\n  }\r\n\r\n  private checkMuteUntil = () => {\r\n    if(this.checkMuteUntilTimeout !== undefined) {\r\n      clearTimeout(this.checkMuteUntilTimeout);\r\n      this.checkMuteUntilTimeout = undefined;\r\n    }\r\n\r\n    const timestamp = tsNow(true);\r\n    let closestMuteUntil = MUTE_UNTIL;\r\n    for(const peerId in this.peerSettings.notifyPeer) {\r\n      const peerNotifySettings = this.peerSettings.notifyPeer[peerId];\r\n      if(peerNotifySettings instanceof Promise) {\r\n        continue;\r\n      }\r\n\r\n      const muteUntil = peerNotifySettings.mute_until;\r\n      if(!muteUntil) {\r\n        continue;\r\n      }\r\n\r\n      if(muteUntil <= timestamp) {\r\n        // ! do not delete it because peer's unique settings will be overwritten in getPeerLocalSettings with type's settings\r\n        peerNotifySettings.mute_until = 0;\r\n\r\n        rootScope.dispatchEvent('updateNotifySettings', {\r\n          _: 'updateNotifySettings',\r\n          peer: {\r\n            _: 'notifyPeer',\r\n            peer: appPeersManager.getOutputPeer(peerId.toPeerId())\r\n          },\r\n          notify_settings: peerNotifySettings\r\n        });\r\n      } else if(muteUntil < closestMuteUntil) {\r\n        closestMuteUntil = muteUntil;\r\n      }\r\n    }\r\n\r\n    const timeout = Math.min(1800e3, (closestMuteUntil - timestamp) * 1000);\r\n    this.checkMuteUntilTimeout = window.setTimeout(this.checkMuteUntil, timeout);\r\n  };\r\n\r\n  public savePeerSettings({key, peerId, settings}: {\r\n    key?: Exclude<NotifyPeer['_'], 'notifyPeer'>,\r\n    peerId?: PeerId, \r\n    settings: PeerNotifySettings\r\n  }) {\r\n    let obj: any;\r\n    if(peerId) {\r\n      key = peerId as any;\r\n      obj = this.peerSettings['notifyPeer'];\r\n    }\r\n    \r\n    (obj || this.peerSettings)[key] = settings;\r\n\r\n    if(!peerId) {\r\n      rootScope.dispatchEvent('notify_peer_type_settings', {key, settings});\r\n      appStateManager.getState().then(state => {\r\n        const notifySettings = state.notifySettings;\r\n        notifySettings[key] = settings;\r\n        appStateManager.pushToState('notifySettings', notifySettings);\r\n      });\r\n    } else {\r\n      this.checkMuteUntilThrottled();\r\n    }\r\n\r\n    //rootScope.broadcast('notify_settings', {peerId: peerId});\r\n  }\r\n\r\n  public isMuted(peerNotifySettings: PeerNotifySettings) {\r\n    return peerNotifySettings._ === 'peerNotifySettings' &&\r\n      (peerNotifySettings.silent || (peerNotifySettings.mute_until !== undefined && (peerNotifySettings.mute_until * 1000) > tsNow()));\r\n  }\r\n\r\n  public getPeerMuted(peerId: PeerId) {\r\n    const ret = this.getNotifySettings({_: 'inputNotifyPeer', peer: appPeersManager.getInputPeerById(peerId)});\r\n    return (ret instanceof Promise ? ret : Promise.resolve(ret))\r\n    .then((peerNotifySettings) => this.isMuted(peerNotifySettings));\r\n  }\r\n\r\n  public getPeerLocalSettings(peerId: PeerId, respectType = true): PeerNotifySettings {\r\n    const n: PeerNotifySettings = {\r\n      _: 'peerNotifySettings'\r\n    };\r\n\r\n    const notifySettings = this.peerSettings['notifyPeer'][peerId];\r\n    //if(!notifySettings || (notifySettings instanceof Promise)) return false;\r\n    if(notifySettings && !(notifySettings instanceof Promise)) {\r\n      Object.assign(n, notifySettings);\r\n    }\r\n\r\n    if(respectType) {\r\n      const inputNotify = appPeersManager.getInputNotifyPeerById(peerId, true);\r\n      const key = convertInputKeyToKey(inputNotify._);\r\n      const typeNotifySettings = this.peerSettings[key as NotifyPeer['_']];\r\n      if(typeNotifySettings && !(typeNotifySettings instanceof Promise)) {\r\n        for(let i in typeNotifySettings) {\r\n          // @ts-ignore\r\n          if(n[i] === undefined) {\r\n            // @ts-ignore\r\n            n[i] = typeNotifySettings[i];\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return n;\r\n  }\r\n\r\n  public isPeerLocalMuted(peerId: PeerId, respectType = true) {\r\n    if(peerId === rootScope.myId) return false;\r\n\r\n    const notifySettings = this.getPeerLocalSettings(peerId, respectType);\r\n    return this.isMuted(notifySettings);\r\n  }\r\n\r\n  public start() {\r\n    this.updateLocalSettings();\r\n    rootScope.addEventListener('settings_updated', this.updateLocalSettings);\r\n    webPushApiManager.start();\r\n\r\n    if(!this.notificationsUiSupport) {\r\n      return false;\r\n    }\r\n\r\n    if('Notification' in window && Notification.permission !== 'granted' && Notification.permission !== 'denied') {\r\n      window.addEventListener('click', this.requestPermission);\r\n    }\r\n\r\n    try {\r\n      if('onbeforeunload' in window) {\r\n        window.addEventListener('beforeunload', this.clear);\r\n      }\r\n    } catch (e) {}\r\n  }\r\n\r\n  private stop() {\r\n    this.clear();\r\n    window.clearInterval(this.titleInterval);\r\n    this.titleInterval = 0;\r\n    this.setFavicon();\r\n    this.stopped = true;\r\n  }\r\n\r\n  private requestPermission = () => {\r\n    Notification.requestPermission();\r\n    window.removeEventListener('click', this.requestPermission);\r\n  };\r\n\r\n  public notify(data: NotifyOptions) {\r\n    //console.log('notify', data, rootScope.idle.isIDLE, this.notificationsUiSupport, this.stopped);\r\n    \r\n    if(this.stopped) {\r\n      return;\r\n    }\r\n\r\n    // FFOS Notification blob src bug workaround\r\n    /* if(Config.Navigator.ffos && !Config.Navigator.ffos2p) {\r\n      data.image = 'https://telegram.org/img/t_logo.png'\r\n    }\r\n    else if (data.image && !angular.isString(data.image)) {\r\n      if (Config.Navigator.ffos2p) {\r\n        FileManager.getDataUrl(data.image, 'image/jpeg').then(function (url) {\r\n          data.image = url\r\n          notify(data)\r\n        })\r\n        return false\r\n      } else {\r\n        data.image = FileManager.getUrl(data.image, 'image/jpeg')\r\n      }\r\n    }\r\n    else */ if(!data.image) {\r\n      data.image = 'assets/img/logo_filled_rounded.png';\r\n    }\r\n    // console.log('notify image', data.image)\r\n\r\n    if(!data.noIncrement) {\r\n      ++this.notificationsCount;\r\n    }\r\n\r\n    if(!this.titleInterval) {\r\n      this.toggleToggler();\r\n    }\r\n\r\n    const idx = ++this.notificationIndex;\r\n    const key = data.key || 'k' + idx;\r\n    this.notificationsShown[key] = true;\r\n\r\n    const now = tsNow();\r\n    if(this.settings.volume > 0 && !this.settings.nosound/* &&\r\n      (\r\n        !data.tag ||\r\n        !this.soundsPlayed[data.tag] ||\r\n        now > this.soundsPlayed[data.tag] + 60000\r\n      ) */\r\n    ) {\r\n      this.testSound(this.settings.volume);\r\n      this.soundsPlayed[data.tag] = now;\r\n    }\r\n\r\n    if(!this.notificationsUiSupport ||\r\n      'Notification' in window && Notification.permission !== 'granted') {\r\n      return false;\r\n    }\r\n\r\n    if(this.settings.nodesktop) {\r\n      if(this.vibrateSupport && !this.settings.novibrate) {\r\n        navigator.vibrate([200, 100, 200]);\r\n        return;\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    let notification: MyNotification;\r\n\r\n    if('Notification' in window) {\r\n      try {\r\n        if(data.tag) {\r\n          for(let i in this.notificationsShown) {\r\n            const notification = this.notificationsShown[i];\r\n            if(typeof(notification) !== 'boolean' && notification.tag === data.tag) {\r\n              notification.hidden = true;\r\n            }\r\n          }\r\n        }\r\n\r\n        notification = new Notification(data.title, {\r\n          icon: data.image || '',\r\n          body: data.message || '',\r\n          tag: data.tag || '',\r\n          silent: data.silent || false\r\n        });\r\n\r\n        //console.log('notify constructed notification');\r\n      } catch(e) {\r\n        this.notificationsUiSupport = false;\r\n        webPushApiManager.setLocalNotificationsDisabled();\r\n        return;\r\n      }\r\n    } /* else if('mozNotification' in navigator) {\r\n      notification = navigator.mozNotification.createNotification(data.title, data.message || '', data.image || '')\r\n    } else if(notificationsMsSiteMode) {\r\n      window.external.msSiteModeClearIconOverlay()\r\n      window.external.msSiteModeSetIconOverlay('img/icons/icon16.png', data.title)\r\n      window.external.msSiteModeActivate()\r\n      notification = {\r\n        index: idx\r\n      }\r\n    } */ else {\r\n      return;\r\n    }\r\n\r\n    notification.onclick = () => {\r\n      notification.close();\r\n      appRuntimeManager.focus();\r\n      this.clear();\r\n      if(data.onclick) {\r\n        data.onclick();\r\n      }\r\n    };\r\n\r\n    notification.onclose = () => {\r\n      if(!notification.hidden) {\r\n        delete this.notificationsShown[key];\r\n        this.clear();\r\n      }\r\n    };\r\n\r\n    if(notification.show) {\r\n      notification.show();\r\n    }\r\n    this.notificationsShown[key] = notification;\r\n\r\n    if(!IS_MOBILE) {\r\n      setTimeout(() => {\r\n        this.hide(key);\r\n      }, 8000);\r\n    }\r\n  }\r\n\r\n  public testSound(volume: number) {\r\n    const now = tsNow();\r\n    if(this.nextSoundAt && now < this.nextSoundAt && this.prevSoundVolume === volume) {\r\n      return;\r\n    }\r\n\r\n    this.nextSoundAt = now + 1000;\r\n    this.prevSoundVolume = volume;\r\n    const filename = 'assets/audio/notification.mp3';\r\n    const audio = document.createElement('audio');\r\n    audio.autoplay = true;\r\n    audio.setAttribute('mozaudiochannel', 'notification');\r\n    audio.volume = volume;\r\n    audio.innerHTML = `\r\n      <source src=\"${filename}\" type=\"audio/mpeg\" />\r\n      <embed hidden=\"true\" autostart=\"true\" loop=\"false\" volume=\"${volume * 100}\" src=\"${filename}\" />\r\n    `;\r\n    this.notifySoundEl.append(audio);\r\n\r\n    audio.addEventListener('ended', () => {\r\n      audio.remove();\r\n    }, {once: true});\r\n  }\r\n\r\n  public cancel(key: string) {\r\n    const notification = this.notificationsShown[key];\r\n    if(notification) {\r\n      if(this.notificationsCount > 0) {\r\n        --this.notificationsCount;\r\n      }\r\n\r\n      try {\r\n        if(typeof(notification) !== 'boolean' && notification.close) {\r\n          notification.hidden = true;\r\n          notification.close();\r\n        }/*  else if(notificationsMsSiteMode &&\r\n          notification.index === notificationIndex) {\r\n          window.external.msSiteModeClearIconOverlay()\r\n        } */\r\n      } catch(e) {}\r\n\r\n      delete this.notificationsShown[key];\r\n    }\r\n  }\r\n\r\n  private hide(key: string) {\r\n    const notification = this.notificationsShown[key];\r\n    if(notification && typeof(notification) !== 'boolean') {\r\n      try {\r\n        if(notification.close) {\r\n          notification.hidden = true;\r\n          notification.close();\r\n        }\r\n      } catch(e) {}\r\n    }\r\n  }\r\n\r\n  public soundReset(tag: string) {\r\n    delete this.soundsPlayed[tag];\r\n  }\r\n\r\n  public clear() {\r\n    /* if(notificationsMsSiteMode) {\r\n      window.external.msSiteModeClearIconOverlay()\r\n    } else { */\r\n      for(const i in this.notificationsShown) {\r\n        const notification = this.notificationsShown[i];\r\n        try {\r\n          if(typeof(notification) !== 'boolean' && notification.close) {\r\n            notification.close();\r\n          }\r\n        } catch(e) {}\r\n      }\r\n    /* } */\r\n    this.notificationsShown = {};\r\n    this.notificationsCount = 0;\r\n\r\n    webPushApiManager.hidePushNotifications();\r\n  }\r\n\r\n  private registerDevice(tokenData: PushSubscriptionNotify) {\r\n    if(this.registeredDevice && deepEqual(this.registeredDevice, tokenData)) {\r\n      return false;\r\n    }\r\n\r\n    apiManager.invokeApi('account.registerDevice', {\r\n      token_type: tokenData.tokenType,\r\n      token: tokenData.tokenValue,\r\n      other_uids: [],\r\n      app_sandbox: false,\r\n      secret: new Uint8Array()\r\n    }).then(() => {\r\n      this.registeredDevice = tokenData;\r\n    }, (error) => {\r\n      error.handled = true;\r\n    });\r\n  }\r\n\r\n  private unregisterDevice(tokenData: PushSubscriptionNotify) {\r\n    if(!this.registeredDevice) {\r\n      return false;\r\n    }\r\n\r\n    apiManager.invokeApi('account.unregisterDevice', {\r\n      token_type: tokenData.tokenType,\r\n      token: tokenData.tokenValue,\r\n      other_uids: []\r\n    }).then(() => {\r\n      this.registeredDevice = false;\r\n    }, (error) => {\r\n      error.handled = true;\r\n    });\r\n  }\r\n\r\n  public getVibrateSupport() {\r\n    return this.vibrateSupport\r\n  }\r\n}\r\n\r\nconst appNotificationsManager = new AppNotificationsManager();\r\nMOUNT_CLASS_TO.appNotificationsManager = appNotificationsManager;\r\nexport default appNotificationsManager;\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport { makeMediaSize, MediaSize } from \"./mediaSizes\";\r\nimport pause from \"./schedulers/pause\";\r\nimport { IS_APPLE_MOBILE } from \"../environment/userAgent\";\r\n\r\nexport function scaleMediaElement(options: {\r\n  media: CanvasImageSource, \r\n  mediaSize: MediaSize, \r\n  boxSize: MediaSize, \r\n  quality?: number,\r\n  mimeType?: 'image/jpeg' | 'image/png'\r\n}): Promise<{blob: Blob, size: MediaSize}> {\r\n  return new Promise((resolve) => {\r\n    const canvas = document.createElement('canvas');\r\n    const size = options.mediaSize.aspectFitted(options.boxSize);\r\n    canvas.width = size.width * window.devicePixelRatio;\r\n    canvas.height = size.height * window.devicePixelRatio;\r\n    const ctx = canvas.getContext('2d');\r\n    ctx.drawImage(options.media, 0, 0, canvas.width, canvas.height);\r\n    canvas.toBlob(blob => {\r\n      resolve({blob, size});\r\n    }, options.mimeType ?? 'image/jpeg', options.quality ?? 1);\r\n  });\r\n}\r\n\r\nexport function preloadVideo(url: string): Promise<HTMLVideoElement> {\r\n  return new Promise((resolve, reject) => {\r\n    const video = document.createElement('video');\r\n    video.volume = 0;\r\n    video.addEventListener('loadedmetadata', () => resolve(video), {once: true});\r\n    video.addEventListener('error', reject, {once: true});\r\n    video.src = url;\r\n  });\r\n}\r\n\r\nexport function createPosterFromMedia(media: HTMLVideoElement | HTMLImageElement) {\r\n  let width: number, height: number;\r\n  if(media instanceof HTMLVideoElement) {\r\n    width = media.videoWidth;\r\n    height = media.videoHeight;\r\n  } else {\r\n    width = media.naturalWidth;\r\n    height = media.naturalHeight;\r\n  }\r\n\r\n  return scaleMediaElement({\r\n    media, \r\n    mediaSize: makeMediaSize(width, height), \r\n    boxSize: makeMediaSize(320, 240),\r\n    quality: .9\r\n  });\r\n}\r\n\r\nexport function createPosterFromVideo(video: HTMLVideoElement): ReturnType<typeof scaleMediaElement> {\r\n  return new Promise((resolve, reject) => {\r\n    video.onseeked = () => {\r\n      video.onseeked = () => {\r\n        createPosterFromMedia(video).then(resolve);\r\n\r\n        video.onseeked = undefined;\r\n      };\r\n\r\n      video.currentTime = 0;\r\n    };\r\n    \r\n    video.onerror = reject;\r\n    video.currentTime = Math.min(video.duration, 1);\r\n  });\r\n}\r\n\r\nexport async function createPosterForVideo(url: string) {\r\n  const video = await preloadVideo(url);\r\n\r\n  return Promise.race([\r\n    pause(2000) as Promise<undefined>,\r\n    createPosterFromVideo(video),\r\n  ]);\r\n}\r\n\r\nexport function onMediaLoad(media: HTMLMediaElement, readyState = media.HAVE_METADATA, useCanplayOnIos?: boolean) {\r\n  return new Promise<void>((resolve) => {\r\n    if(media.readyState >= readyState) {\r\n      resolve();\r\n      return;\r\n    }\r\n\r\n    media.addEventListener(IS_APPLE_MOBILE && !useCanplayOnIos ? 'loadeddata' : 'canplay', () => resolve(), {once: true});\r\n  });\r\n}\r\n\r\nexport async function getFilesFromEvent(e: ClipboardEvent | DragEvent, onlyTypes = false): Promise<any[]> {\r\n  const files: any[] = [];\r\n\r\n  const scanFiles = async(entry: any, item: DataTransferItem) => {\r\n    if(entry.isDirectory) {\r\n      const directoryReader = entry.createReader();\r\n      await new Promise<void>((resolve, reject) => {\r\n        directoryReader.readEntries(async(entries: any) => {\r\n          for(const entry of entries) {\r\n            await scanFiles(entry, item);\r\n          }\r\n\r\n          resolve();\r\n        });\r\n      });\r\n    } else if(entry) {\r\n      if(onlyTypes) {\r\n        files.push(entry.type);\r\n      } else {\r\n        const itemFile = item.getAsFile(); // * Safari can't handle entry.file with pasting\r\n        const file = entry instanceof File ? \r\n          entry : \r\n          (\r\n            entry instanceof DataTransferItem ? \r\n              entry.getAsFile() : \r\n              await new Promise((resolve, reject) => entry.file(resolve, (err: any) => resolve(itemFile)))\r\n          );\r\n\r\n        /* if(!onlyTypes) {\r\n          console.log('getFilesFromEvent: got file', item, file);\r\n        } */\r\n\r\n        if(!file) return;\r\n        files.push(file);\r\n      }\r\n    }\r\n  };\r\n\r\n  if(e instanceof DragEvent && e.dataTransfer.files && !e.dataTransfer.items) {\r\n    for(let i = 0; i < e.dataTransfer.files.length; i++) {\r\n      const file = e.dataTransfer.files[i];\r\n      files.push(onlyTypes ? file.type : file);\r\n    }\r\n  } else {\r\n    // @ts-ignore\r\n    const items = (e.dataTransfer || e.clipboardData || e.originalEvent.clipboardData).items;\r\n\r\n    const promises: Promise<any>[] = [];\r\n    for(let i = 0; i < items.length; ++i) {\r\n      const item: DataTransferItem = items[i];\r\n      if(item.kind === 'file') {\r\n        const entry = (onlyTypes ? item : item.webkitGetAsEntry()) || item.getAsFile();\r\n        promises.push(scanFiles(entry, item));\r\n      }\r\n    }\r\n    \r\n    await Promise.all(promises);\r\n  }\r\n\r\n  /* if(!onlyTypes) {\r\n    console.log('getFilesFromEvent: got files:', e, files);\r\n  } */\r\n  \r\n  return files;\r\n}\r\n\r\nexport function requestFile(accept?: string) {\r\n  const input = document.createElement('input');\r\n  input.type = 'file';\r\n  input.style.display = 'none';\r\n\r\n  if(accept) {\r\n    input.accept = accept;\r\n  }\r\n\r\n  document.body.append(input);\r\n\r\n  const promise = new Promise<File>((resolve, reject) => {\r\n    input.addEventListener('change', (e: any) => {\r\n      const file: File = e.target.files[0];\r\n      if(!file) {\r\n        reject('NO_FILE_SELECTED');\r\n        return;\r\n      }\r\n  \r\n      resolve(file);\r\n    }, {once: true});\r\n  }).finally(() => {\r\n    input.remove();\r\n  });\r\n\r\n  input.click();\r\n\r\n  return promise;\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\n// * will change .cleaned and new instance will be created\r\nexport const getMiddleware = () => {\r\n  let cleanupObj = {cleaned: false};\r\n  return {\r\n    clean: () => {\r\n      cleanupObj.cleaned = true;\r\n      cleanupObj = {cleaned: false};\r\n    },\r\n    get: (additionalCallback?: () => boolean) => {\r\n      const _cleanupObj = cleanupObj;\r\n      return () => {\r\n        return !_cleanupObj.cleaned && (!additionalCallback || additionalCallback());\r\n      };\r\n    }\r\n  };\r\n};\r\n","export default function fixBase64String(str: string, toUrl: boolean) {\r\n  if(toUrl) {\r\n    return str.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/\\=+$/, '');\r\n  } else {\r\n    return str.replace(/-/g, '+').replace(/_/g, '/');\r\n  }\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport { HelpCountry, HelpCountryCode } from \"../layer\";\r\nimport I18n from \"../lib/langPack\";\r\n\r\nlet sortedCountries: HelpCountry[];\r\ntype PrefixCountry = {country: HelpCountry, code: HelpCountryCode};\r\nconst prefixes: Map<string, PrefixCountry> = new Map();\r\nlet maxPrefixLength = 0;\r\nconst setPrefix = (country: HelpCountry, code: HelpCountryCode, prefix: string = '') => {\r\n  prefix = code.country_code + prefix;\r\n  /* if(prefixes.has(prefix)) {\r\n    console.error('asdasdasd', prefixes.get(prefix), country, code);\r\n  } */\r\n  maxPrefixLength = Math.max(maxPrefixLength, prefix.length);\r\n  prefixes.set(prefix, {country, code});\r\n};\r\n\r\nexport function formatPhoneNumber(originalStr: string): {\r\n  formatted: string,\r\n  country: HelpCountry,\r\n  code: HelpCountryCode,\r\n  leftPattern: string\r\n} {\r\n  originalStr = originalStr || '';\r\n  \r\n  if(!prefixes.size) {\r\n    I18n.countriesList.forEach(country => {\r\n      country.country_codes.forEach(code => {\r\n        if(code.prefixes) {\r\n          code.prefixes.forEach(prefix => {\r\n            setPrefix(country, code, prefix);\r\n          });\r\n        } else {\r\n          setPrefix(country, code);\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  // return {formatted: originalStr, country: undefined as any, leftPattern: ''};\r\n  let str = originalStr.replace(/\\D/g, '');\r\n  let phoneCode = str.slice(0, maxPrefixLength);\r\n  \r\n  ////console.log('str', str, phoneCode);\r\n  // if(!sortedCountries) {\r\n  //   sortedCountries = I18n.countriesList.slice().sort((a, b) => b.country_codes[0].country_code.length - a.country_codes[0].country_code.length);\r\n  // }\r\n  \r\n  // let country = sortedCountries.find((c) => {\r\n  //   return c.country_codes.find((c) => phoneCode.indexOf(c.replace(/\\D/g, '')) === 0);\r\n  // });\r\n\r\n  let prefixCountry: PrefixCountry;\r\n  for(let i = phoneCode.length - 1; i >= 0; --i) { // lookup for country by prefix\r\n    prefixCountry = prefixes.get(phoneCode.slice(0, i + 1));\r\n    if(prefixCountry) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  if(!prefixCountry) {\r\n    return {\r\n      formatted: str, \r\n      country: undefined, \r\n      code: undefined, \r\n      leftPattern: ''\r\n    };\r\n  }\r\n\r\n  // country = /* PhoneCodesMain[country.phoneCode] ||  */country;\r\n  const country = prefixCountry.country;\r\n  \r\n  const patterns = prefixCountry.code.patterns || [];\r\n  const searchForPattern = str.slice(prefixCountry.code.country_code.length); // splice country code\r\n  let pattern = '', mostMatchedPatternMatches = 0, mostMatchedPattern = '';\r\n  for(let i = patterns.length - 1; i >= 0; --i) {\r\n    pattern = patterns[i];\r\n\r\n    const _pattern = pattern.replace(/ /g, '');\r\n    let patternMatches = 0;\r\n    for(let k = 0, length = Math.min(searchForPattern.length, _pattern.length); k < length; ++k) {\r\n      if(searchForPattern[k] === _pattern[k] || _pattern[k] === 'X') {\r\n        ++patternMatches;\r\n      } else {\r\n        patternMatches = 0;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if(patternMatches > mostMatchedPatternMatches) {\r\n      mostMatchedPatternMatches = patternMatches;\r\n      mostMatchedPattern = pattern;\r\n    }\r\n  }\r\n\r\n  pattern = mostMatchedPattern || pattern;\r\n  pattern = pattern.replace(/\\d/g, 'X');\r\n\r\n  pattern = prefixCountry.code.country_code + ' ' + pattern;\r\n  // let pattern = country.pattern || country.phoneCode;\r\n  pattern.split('').forEach((symbol, idx) => {\r\n    if(symbol === ' ' && str[idx] !== ' ' && str.length > idx) {\r\n      str = str.slice(0, idx) + ' ' + str.slice(idx);\r\n    }\r\n  });\r\n  \r\n  /* if(country.pattern) {\r\n    str = str.slice(0, country.pattern.length);\r\n  } */\r\n\r\n  let leftPattern = pattern && pattern.length > str.length ? pattern.slice(str.length) : '';\r\n  if(leftPattern) {\r\n    /* const length = str.length;\r\n    leftPattern = leftPattern.split('').map((_, idx) => (length + idx).toString().slice(-1)).join(''); */\r\n    leftPattern = leftPattern.replace(/X/g, '‒');\r\n    // leftPattern = leftPattern.replace(/X/g, '0');\r\n  }\r\n  \r\n  return {formatted: str, country, code: prefixCountry.code, leftPattern};\r\n}\r\n","export default function safeReplaceObject(wasObject: any, newObject: any) {\r\n  if(!wasObject) {\r\n    return newObject;\r\n  }\r\n\r\n  for(var key in wasObject) {\r\n    if(!newObject.hasOwnProperty(key)) {\r\n      delete wasObject[key];\r\n    }\r\n  }\r\n\r\n  for(var key in newObject) {\r\n    //if (newObject.hasOwnProperty(key)) { // useless\r\n      wasObject[key] = newObject[key];\r\n    //}\r\n  }\r\n  \r\n  return wasObject;\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport { CancellablePromise } from \"../helpers/cancellablePromise\";\r\nimport SetTransition from \"./singleTransition\";\r\nimport { fastRaf } from \"../helpers/schedulers\";\r\nimport cancelEvent from \"../helpers/dom/cancelEvent\";\r\nimport { attachClickEvent } from \"../helpers/dom/clickEvent\";\r\nimport isInDOM from \"../helpers/dom/isInDOM\";\r\nimport safeAssign from \"../helpers/object/safeAssign\";\r\n\r\nconst TRANSITION_TIME = 200;\r\n\r\nexport default class ProgressivePreloader {\r\n  public preloader: HTMLDivElement;\r\n  public circle: SVGCircleElement;\r\n  private cancelSvg: SVGSVGElement;\r\n  private downloadSvg: HTMLElement;\r\n  \r\n  private tempId = 0;\r\n  public detached = true;\r\n\r\n  public promise: CancellablePromise<any> = null;\r\n\r\n  public isUpload = false;\r\n  private cancelable = true;\r\n  private streamable = false;\r\n  private tryAgainOnFail = true;\r\n  private attachMethod: 'append' | 'prepend' = 'append';\r\n\r\n  public loadFunc: (e?: Event) => {download: CancellablePromise<any>};\r\n\r\n  public totalLength: number;\r\n\r\n  constructor(options?: Partial<{\r\n    isUpload: ProgressivePreloader['isUpload'],\r\n    cancelable: ProgressivePreloader['cancelable'], \r\n    streamable: ProgressivePreloader['streamable'], \r\n    tryAgainOnFail: ProgressivePreloader['tryAgainOnFail'],\r\n    attachMethod: ProgressivePreloader['attachMethod']\r\n  }>) {\r\n    if(options) {\r\n      safeAssign(this, options);\r\n    }\r\n  }\r\n\r\n  public constructContainer(options: Partial<{\r\n    color: 'transparent',\r\n    bold: boolean\r\n  }> = {}) {\r\n    if(!this.preloader) {\r\n      this.preloader = document.createElement('div');\r\n      this.preloader.classList.add('preloader-container');\r\n\r\n      if(options.color) {\r\n        this.preloader.classList.add('preloader-' + options.color);\r\n      }\r\n\r\n      if(options.bold) {\r\n        this.preloader.classList.add('preloader-bold');\r\n      }\r\n  \r\n      if(this.streamable) {\r\n        this.preloader.classList.add('preloader-streamable');\r\n      }\r\n    }\r\n  }\r\n\r\n  public constructDownloadIcon() {\r\n    this.constructContainer();\r\n  }\r\n\r\n  public construct() {\r\n    this.construct = null;\r\n\r\n    this.constructContainer();\r\n    \r\n    this.preloader.innerHTML = `\r\n    <div class=\"you-spin-me-round\">\r\n    <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"preloader-circular\" viewBox=\"${this.streamable ? '25 25 50 50' : '27 27 54 54'}\">\r\n    <circle class=\"preloader-path-new\" cx=\"${this.streamable ? '50' : '54'}\" cy=\"${this.streamable ? '50' : '54'}\" r=\"${this.streamable ? 19 : 24}\" fill=\"none\" stroke-miterlimit=\"10\"/>\r\n    </svg>\r\n    </div>`;\r\n\r\n    if(this.streamable) {\r\n      this.totalLength = 118.61124420166016;\r\n    } else {\r\n      this.totalLength = 149.82473754882812;\r\n    }\r\n\r\n    if(this.cancelable) {\r\n      this.preloader.innerHTML += `\r\n      <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"preloader-close\" viewBox=\"0 0 24 24\">\r\n        <g fill=\"none\" fill-rule=\"evenodd\">\r\n          <polygon points=\"0 0 24 0 24 24 0 24\"/>\r\n          <path fill=\"#000\" fill-rule=\"nonzero\" d=\"M5.20970461,5.38710056 L5.29289322,5.29289322 C5.65337718,4.93240926 6.22060824,4.90467972 6.61289944,5.20970461 L6.70710678,5.29289322 L12,10.585 L17.2928932,5.29289322 C17.6834175,4.90236893 18.3165825,4.90236893 18.7071068,5.29289322 C19.0976311,5.68341751 19.0976311,6.31658249 18.7071068,6.70710678 L13.415,12 L18.7071068,17.2928932 C19.0675907,17.6533772 19.0953203,18.2206082 18.7902954,18.6128994 L18.7071068,18.7071068 C18.3466228,19.0675907 17.7793918,19.0953203 17.3871006,18.7902954 L17.2928932,18.7071068 L12,13.415 L6.70710678,18.7071068 C6.31658249,19.0976311 5.68341751,19.0976311 5.29289322,18.7071068 C4.90236893,18.3165825 4.90236893,17.6834175 5.29289322,17.2928932 L10.585,12 L5.29289322,6.70710678 C4.93240926,6.34662282 4.90467972,5.77939176 5.20970461,5.38710056 L5.29289322,5.29289322 L5.20970461,5.38710056 Z\"/>\r\n        </g>\r\n      </svg>\r\n      <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"preloader-download\" viewBox=\"0 0 24 24\">\r\n        <g fill=\"none\" fill-rule=\"evenodd\">\r\n          <polygon points=\"0 0 24 0 24 24 0 24\"/>\r\n          <path fill=\"#000\" fill-rule=\"nonzero\" d=\"M5,19 L19,19 C19.5522847,19 20,19.4477153 20,20 C20,20.5128358 19.6139598,20.9355072 19.1166211,20.9932723 L19,21 L5,21 C4.44771525,21 4,20.5522847 4,20 C4,19.4871642 4.38604019,19.0644928 4.88337887,19.0067277 L5,19 L19,19 L5,19 Z M11.8833789,3.00672773 L12,3 C12.5128358,3 12.9355072,3.38604019 12.9932723,3.88337887 L13,4 L13,13.585 L16.2928932,10.2928932 C16.6533772,9.93240926 17.2206082,9.90467972 17.6128994,10.2097046 L17.7071068,10.2928932 C18.0675907,10.6533772 18.0953203,11.2206082 17.7902954,11.6128994 L17.7071068,11.7071068 L12.7071068,16.7071068 C12.3466228,17.0675907 11.7793918,17.0953203 11.3871006,16.7902954 L11.2928932,16.7071068 L6.29289322,11.7071068 C5.90236893,11.3165825 5.90236893,10.6834175 6.29289322,10.2928932 C6.65337718,9.93240926 7.22060824,9.90467972 7.61289944,10.2097046 L7.70710678,10.2928932 L11,13.585 L11,4 C11,3.48716416 11.3860402,3.06449284 11.8833789,3.00672773 L12,3 L11.8833789,3.00672773 Z\"/>\r\n        </g>\r\n      </svg>`;\r\n\r\n      this.downloadSvg = this.preloader.lastElementChild as HTMLElement;\r\n      this.cancelSvg = this.downloadSvg.previousElementSibling as any;\r\n    } else {\r\n      this.preloader.classList.add('preloader-swing');\r\n    }\r\n    \r\n    this.circle = this.preloader.firstElementChild.firstElementChild.firstElementChild as SVGCircleElement;\r\n\r\n    if(this.cancelable) {\r\n      attachClickEvent(this.preloader, this.onClick);\r\n    }\r\n  }\r\n\r\n  public onClick = (e?: Event) => {\r\n    if(e) {\r\n      cancelEvent(e);\r\n    }\r\n\r\n    if(this.preloader.classList.contains('manual')) {\r\n      if(this.loadFunc) {\r\n        this.loadFunc(e);\r\n      }\r\n    } else {\r\n      if(this.promise && this.promise.cancel) {\r\n        this.promise.cancel();\r\n      }\r\n    }\r\n  };\r\n\r\n  public setDownloadFunction(func: ProgressivePreloader['loadFunc']) {\r\n    this.loadFunc = func;\r\n  }\r\n\r\n  public setManual() {\r\n    this.preloader.classList.add('manual');\r\n    this.setProgress(0);\r\n  }\r\n\r\n  public attachPromise(promise: CancellablePromise<any>) {\r\n    if(this.isUpload && this.promise) return;\r\n\r\n    this.promise = promise;\r\n\r\n    const tempId = --this.tempId;\r\n    const startTime = Date.now();\r\n\r\n    const onEnd = (err: Error) => {\r\n      promise.notify = promise.notifyAll = null;\r\n\r\n      if(tempId !== this.tempId) {\r\n        return;\r\n      }\r\n\r\n      const elapsedTime = Date.now() - startTime;\r\n\r\n      //console.log('[PP]: end', this.detached, performance.now());\r\n\r\n      if(!err && this.cancelable) {\r\n        this.setProgress(100);\r\n\r\n        const delay = TRANSITION_TIME * 0.75;\r\n\r\n        if(elapsedTime < delay) {\r\n          this.detach();\r\n        } else {\r\n          setTimeout(() => { // * wait for transition complete\r\n            if(tempId === this.tempId) {\r\n              this.detach();\r\n            }\r\n          }, delay);\r\n        }\r\n      } else {\r\n        if(this.tryAgainOnFail) {\r\n          this.attach(this.preloader.parentElement);\r\n          fastRaf(() => {\r\n            this.setManual();\r\n          });\r\n        } else {\r\n          this.detach();\r\n        }\r\n      }\r\n      \r\n      this.promise = promise = null;\r\n    };\r\n    \r\n    promise\r\n    .then(() => onEnd(null))\r\n    .catch((err) => onEnd(err));\r\n\r\n    if(promise.addNotifyListener) {\r\n      promise.addNotifyListener((details: {done: number, total: number}) => {\r\n        /* if(details.done >= details.total) {\r\n          onEnd();\r\n        } */\r\n\r\n        if(tempId !== this.tempId) return;\r\n\r\n        //console.log('preloader download', promise, details);\r\n        const percents = details.done / details.total * 100;\r\n        this.setProgress(percents);\r\n      });\r\n    }\r\n  }\r\n\r\n  public attach(elem: Element, reset = false, promise?: CancellablePromise<any>) {\r\n    if(this.construct) {\r\n      this.construct();\r\n    }\r\n\r\n    if(this.preloader.parentElement) {\r\n      this.preloader.classList.remove('manual');\r\n    }\r\n\r\n    this.detached = false;\r\n\r\n    if(promise/*  && false */) {\r\n      this.attachPromise(promise);\r\n    }\r\n\r\n    if(this.detached || this.preloader.parentElement !== elem) {\r\n      const useRafs = isInDOM(this.preloader) ? 1 : 2;\r\n      if(this.preloader.parentElement !== elem) {\r\n        elem[this.attachMethod](this.preloader);\r\n      }\r\n\r\n      SetTransition(this.preloader, 'is-visible', true, TRANSITION_TIME, undefined, useRafs);\r\n    }\r\n\r\n    if(this.cancelable && reset) {\r\n      this.setProgress(0);\r\n    }\r\n  }\r\n  \r\n  public detach() {\r\n    if(this.detached) {\r\n      return;\r\n    }\r\n    //return;\r\n\r\n    this.detached = true;\r\n\r\n    //return;\r\n    \r\n    if(this.preloader && this.preloader.parentElement) {\r\n      /* setTimeout(() =>  *///fastRaf(() => {\r\n        /* if(!this.detached) return;\r\n        this.detached = true; */\r\n\r\n        // fastRaf(() => {\r\n          //console.log('[PP]: detach after rAF', this.detached, performance.now());\r\n\r\n          // if(!this.detached || !this.preloader.parentElement) {\r\n          //   return;\r\n          // }\r\n\r\n          SetTransition(this.preloader, 'is-visible', false, TRANSITION_TIME, () => {\r\n            this.preloader.remove();\r\n          }, 1);\r\n        // });\r\n      //})/* , 5e3) */;\r\n    }\r\n  }\r\n  \r\n  public setProgress(percents: number) {\r\n    if(!this.totalLength && !isInDOM(this.circle)) {\r\n      return;\r\n    }\r\n    \r\n    if(percents === 0) {\r\n      this.circle.style.strokeDasharray = '';\r\n      return;\r\n    }\r\n    \r\n    try {\r\n      if(!this.totalLength) {\r\n        this.totalLength = this.circle.getTotalLength();\r\n      }\r\n\r\n      //console.log('setProgress', (percents / 100 * totalLength));\r\n      this.circle.style.strokeDasharray = '' + Math.max(5, percents / 100 * this.totalLength) + ', ' + this.totalLength;\r\n    } catch(err) {}\r\n  }\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport { MOUNT_CLASS_TO } from \"../../config/debug\";\r\nimport { renderImageFromUrlPromise } from \"../../helpers/dom/renderImageFromUrl\";\r\nimport replaceContent from \"../../helpers/dom/replaceContent\";\r\nimport setInnerHTML from \"../../helpers/dom/setInnerHTML\";\r\nimport sequentialDom from \"../../helpers/sequentialDom\";\r\nimport { UserProfilePhoto, ChatPhoto, InputFileLocation } from \"../../layer\";\r\nimport { DownloadOptions } from \"../mtproto/apiFileManager\";\r\nimport { NULL_PEER_ID, REPLIES_PEER_ID } from \"../mtproto/mtproto_config\";\r\nimport RichTextProcessor from \"../richtextprocessor\";\r\nimport rootScope from \"../rootScope\";\r\nimport appDownloadManager from \"./appDownloadManager\";\r\nimport appPeersManager from \"./appPeersManager\";\r\nimport appPhotosManager from \"./appPhotosManager\";\r\nimport appUsersManager from \"./appUsersManager\";\r\n\r\ntype PeerPhotoSize = 'photo_small' | 'photo_big';\r\n\r\nexport class AppAvatarsManager {\r\n  private savedAvatarURLs: {\r\n    [peerId: PeerId]: {\r\n      [size in PeerPhotoSize]?: string | Promise<string>\r\n    }\r\n  } = {};\r\n\r\n  public isAvatarCached(peerId: PeerId) {\r\n    return !!this.savedAvatarURLs[peerId];\r\n  }\r\n  \r\n  public removeFromAvatarsCache(peerId: PeerId) {\r\n    if(this.savedAvatarURLs[peerId]) {\r\n      delete this.savedAvatarURLs[peerId];\r\n    }\r\n  }\r\n\r\n  public loadAvatar(peerId: PeerId, photo: UserProfilePhoto.userProfilePhoto | ChatPhoto.chatPhoto, size: PeerPhotoSize) {\r\n    const inputPeer = appPeersManager.getInputPeerById(peerId);\r\n\r\n    let cached = false;\r\n    let getAvatarPromise: Promise<string>;\r\n    let saved = this.savedAvatarURLs[peerId];\r\n    if(!saved || !saved[size]) {\r\n      if(!saved) {\r\n        saved = this.savedAvatarURLs[peerId] = {};\r\n      }\r\n\r\n      //console.warn('will invoke downloadSmallFile:', peerId);\r\n      const peerPhotoFileLocation: InputFileLocation.inputPeerPhotoFileLocation = {\r\n        _: 'inputPeerPhotoFileLocation', \r\n        pFlags: {},\r\n        peer: inputPeer, \r\n        photo_id: photo.photo_id\r\n      };\r\n\r\n      const downloadOptions: DownloadOptions = {dcId: photo.dc_id, location: peerPhotoFileLocation};\r\n      if(size === 'photo_big') {\r\n        peerPhotoFileLocation.pFlags.big = true;\r\n        downloadOptions.limitPart = 512 * 1024;\r\n      }\r\n\r\n      /* let str: string;\r\n      const time = Date.now();\r\n      if(peerId === 0) {\r\n        str = `download avatar ${peerId}`;\r\n      } */\r\n\r\n      const promise = appDownloadManager.download(downloadOptions);\r\n      getAvatarPromise = saved[size] = promise.then(blob => {\r\n        return saved[size] = URL.createObjectURL(blob);\r\n\r\n        /* if(str) {\r\n          console.log(str, Date.now() / 1000, Date.now() - time);\r\n        } */\r\n      });\r\n    } else if(typeof(saved[size]) !== 'string') {\r\n      getAvatarPromise = saved[size] as Promise<any>;\r\n    } else {\r\n      getAvatarPromise = Promise.resolve(saved[size]);\r\n      cached = true;\r\n    }\r\n\r\n    return {cached, loadPromise: getAvatarPromise};\r\n  }\r\n\r\n  public putAvatar(\r\n    div: HTMLElement, \r\n    peerId: PeerId, \r\n    photo: UserProfilePhoto.userProfilePhoto | ChatPhoto.chatPhoto, \r\n    size: PeerPhotoSize, \r\n    img = new Image(), \r\n    onlyThumb = false\r\n  ) {\r\n    let {cached, loadPromise} = this.loadAvatar(peerId, photo, size);\r\n\r\n    img.classList.add('avatar-photo');\r\n\r\n    let renderThumbPromise: Promise<void>;\r\n    let callback: () => void;\r\n    let thumbImage: HTMLImageElement;\r\n    if(cached) {\r\n      // смотри в misc.ts: renderImageFromUrl\r\n      callback = () => {\r\n        replaceContent(div, img);\r\n        div.dataset.color = '';\r\n      };\r\n    } else {\r\n      const animate = rootScope.settings.animationsEnabled;\r\n      if(animate) {\r\n        img.classList.add('fade-in');\r\n      }\r\n\r\n      let isFullLoaded = false;\r\n      if(size === 'photo_big') { // let's load small photo first\r\n        const res = this.putAvatar(div, peerId, photo, 'photo_small');\r\n        renderThumbPromise = res.loadPromise;\r\n        thumbImage = res.thumbImage;\r\n      } else if(photo.stripped_thumb) {\r\n        thumbImage = new Image();\r\n        div.classList.add('avatar-relative');\r\n        thumbImage.classList.add('avatar-photo', 'avatar-photo-thumbnail');\r\n        const url = appPhotosManager.getPreviewURLFromBytes(photo.stripped_thumb);\r\n        renderThumbPromise = renderImageFromUrlPromise(thumbImage, url).then(() => {\r\n          if(isFullLoaded) {\r\n            return;\r\n          }\r\n\r\n          replaceContent(div, thumbImage);\r\n        });\r\n      }\r\n\r\n      callback = () => {\r\n        isFullLoaded = true;\r\n\r\n        if(thumbImage) {\r\n          div.append(img);\r\n        } else {\r\n          replaceContent(div, img);\r\n        }\r\n\r\n        setTimeout(() => {\r\n          if(div.childElementCount) {\r\n            sequentialDom.mutateElement(img, () => {\r\n              div.dataset.color = '';\r\n              \r\n              if(animate) {\r\n                img.classList.remove('fade-in');\r\n              }\r\n\r\n              if(thumbImage) {\r\n                thumbImage.remove();\r\n              }\r\n            });\r\n          }\r\n        }, animate ? 200 : 0);\r\n      };\r\n    }\r\n\r\n    const renderPromise = loadPromise\r\n    .then((url) => renderImageFromUrlPromise(img, url/* , false */))\r\n    .then(callback);\r\n\r\n    return {\r\n      cached, \r\n      loadPromise: renderThumbPromise || renderPromise,\r\n      thumbImage\r\n    };\r\n  }\r\n\r\n  public s(div: HTMLElement, innerHTML: Parameters<typeof setInnerHTML>[1], color: string, icon: string) {\r\n    setInnerHTML(div, innerHTML);\r\n    div.dataset.color = color;\r\n    div.classList.remove('tgico-saved', 'tgico-deletedaccount', 'tgico-reply_filled');\r\n    icon && div.classList.add(icon);\r\n  }\r\n\r\n  // peerId === peerId || title\r\n  public putPhoto(div: HTMLElement, peerId: PeerId, isDialog = false, title = '', onlyThumb = false, isBig?: boolean) {\r\n    const myId = rootScope.myId;\r\n    \r\n    //console.log('loadDialogPhoto location:', location, inputPeer);\r\n    if(peerId === myId && isDialog) {\r\n      this.s(div, '', '', 'tgico-saved');\r\n      return;\r\n    }\r\n    \r\n    if(peerId !== NULL_PEER_ID && peerId.isUser()) {\r\n      const user = appUsersManager.getUser(peerId);\r\n      if(user && user.pFlags && user.pFlags.deleted) {\r\n        this.s(div, '', appPeersManager.getPeerColorById(peerId), 'tgico-deletedaccount');\r\n        return;\r\n      }\r\n    }\r\n    \r\n    const photo = appPeersManager.getPeerPhoto(peerId);\r\n    const avatarAvailable = !!photo;\r\n    const avatarRendered = !!div.firstElementChild && !(div.firstElementChild as HTMLElement).classList.contains('emoji');\r\n    if(!avatarAvailable || !avatarRendered || !this.savedAvatarURLs[peerId]) {\r\n      let color = '';\r\n      if(peerId && (peerId !== myId || !isDialog)) {\r\n        color = appPeersManager.getPeerColorById(peerId);\r\n      }\r\n\r\n      if(peerId === REPLIES_PEER_ID) {\r\n        this.s(div, '', color, 'tgico-reply_filled');\r\n        return;\r\n      }\r\n\r\n      const abbr = title ? RichTextProcessor.getAbbreviation(title) : appPeersManager.getPeerInitials(peerId);\r\n      this.s(div, abbr, color, '');\r\n      //return Promise.resolve(true);\r\n    }\r\n\r\n    if(avatarAvailable/*  && false */) {\r\n      const size: PeerPhotoSize = isBig ? 'photo_big' : 'photo_small';\r\n      return this.putAvatar(div, peerId, photo, size, undefined, onlyThumb);\r\n    }\r\n  }\r\n}\r\n\r\nconst appAvatarsManager = new AppAvatarsManager();\r\nMOUNT_CLASS_TO && (MOUNT_CLASS_TO.appAvatarsManager = appAvatarsManager);\r\nexport default appAvatarsManager;\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nenum GROUP_CALL_STATE {\r\n  UNMUTED,\r\n  MUTED,\r\n  MUTED_BY_ADMIN,\r\n  CONNECTING,\r\n  CLOSED\r\n}\r\n\r\nexport default GROUP_CALL_STATE;\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport {Awaited} from '../types';\r\n\r\nexport default function callbackify<T extends Awaited<any>, R>(\r\n  smth: T, \r\n  callback: (result: Awaited<T>) => R\r\n): PromiseLike<R> | R {\r\n  if(smth instanceof Promise) {\r\n    return smth.then(callback);\r\n  } else {\r\n    return callback(smth as any);\r\n  }\r\n}\r\n","export default function limitSymbols(str: string, length: number, limitFrom = length + 10) {\r\n  str = str.trim();\r\n  if(str.length > limitFrom) {\r\n    str = str.slice(0, length)/* .replace(/\\s*$/, '') */ + '...';\r\n  }\r\n\r\n  return str;\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n * \r\n * Originally from:\r\n * https://github.com/zhukov/webogram\r\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\r\n * https://github.com/zhukov/webogram/blob/master/LICENSE\r\n */\r\n\r\nimport rootScope from \"../rootScope\";\r\nimport appPeersManager from \"./appPeersManager\";\r\nimport appMessagesManager from \"./appMessagesManager\";\r\nimport apiUpdatesManager from \"./apiUpdatesManager\";\r\nimport RichTextProcessor from \"../richtextprocessor\";\r\nimport serverTimeManager from \"../mtproto/serverTimeManager\";\r\nimport { MessageEntity, DraftMessage, MessagesSaveDraft } from \"../../layer\";\r\nimport apiManager from \"../mtproto/mtprotoworker\";\r\nimport { tsNow } from \"../../helpers/date\";\r\nimport { MOUNT_CLASS_TO } from \"../../config/debug\";\r\nimport stateStorage from \"../stateStorage\";\r\nimport appMessagesIdsManager from \"./appMessagesIdsManager\";\r\nimport assumeType from \"../../helpers/assumeType\";\r\nimport isObject from \"../../helpers/object/isObject\";\r\nimport deepEqual from \"../../helpers/object/deepEqual\";\r\nimport documentFragmentToHTML from \"../../helpers/dom/documentFragmentToHTML\";\r\n\r\nexport type MyDraftMessage = DraftMessage.draftMessage;\r\n\r\nexport class AppDraftsManager {\r\n  private drafts: {[peerIdAndThreadId: string]: MyDraftMessage} = {};\r\n  private getAllDraftPromise: Promise<void> = null;\r\n\r\n  constructor() {\r\n    stateStorage.get('drafts').then(drafts => {\r\n      this.drafts = drafts || {};\r\n    });\r\n\r\n    rootScope.addMultipleEventsListeners({\r\n      updateDraftMessage: (update) => {\r\n        const peerID = appPeersManager.getPeerId(update.peer);\r\n        this.saveDraft(peerID, update.threadId, update.draft, {notify: true});\r\n      }\r\n    });\r\n  }\r\n\r\n  private getKey(peerId: PeerId, threadId?: number) {\r\n    return '' + peerId + (threadId ? '_' + threadId : '');\r\n  }\r\n\r\n  public getDraft(peerId: PeerId, threadId?: number) {\r\n    return this.drafts[this.getKey(peerId, threadId)];\r\n  }\r\n\r\n  public addMissedDialogs() {\r\n    return this.getAllDrafts().then(() => {\r\n      for(const key in this.drafts) {\r\n        if(key.indexOf('_') !== -1) { // exclude threads\r\n          continue;\r\n        }\r\n\r\n        const peerId = key.toPeerId();\r\n        const dialog = appMessagesManager.getDialogOnly(peerId);\r\n        if(!dialog) {\r\n          appMessagesManager.reloadConversation(peerId);\r\n          /* const dialog = appMessagesManager.generateDialog(peerId);\r\n          dialog.draft = this.drafts[key];\r\n          appMessagesManager.saveConversation(dialog);\r\n          appMessagesManager.newDialogsToHandle[peerId] = dialog;\r\n          appMessagesManager.scheduleHandleNewDialogs(); */\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  public getAllDrafts() {\r\n    return this.getAllDraftPromise || (\r\n      this.getAllDraftPromise = apiManager.invokeApi('messages.getAllDrafts')\r\n      .then((updates) => {\r\n        const p = apiUpdatesManager.updatesState.syncLoading || Promise.resolve();\r\n        p.then(() => {\r\n          apiUpdatesManager.processUpdateMessage(updates);\r\n        });\r\n      })\r\n    );\r\n  }\r\n\r\n  public saveDraft(peerId: PeerId, threadId: number, apiDraft: DraftMessage, options: Partial<{\r\n    notify: boolean,\r\n    force: boolean\r\n  }> = {}) {\r\n    const draft = this.processApiDraft(apiDraft);\r\n\r\n    const key = this.getKey(peerId, threadId);\r\n    if(draft) {\r\n      this.drafts[key] = draft;\r\n    } else {\r\n      delete this.drafts[key];\r\n    }\r\n\r\n    stateStorage.set({\r\n      drafts: this.drafts\r\n    });\r\n\r\n    if(options.notify) {\r\n      // console.warn(dT(), 'save draft', peerId, apiDraft, options)\r\n      rootScope.dispatchEvent('draft_updated', {\r\n        peerId,\r\n        threadId,\r\n        draft,\r\n        force: options.force\r\n      });\r\n    }\r\n\r\n    return draft;\r\n  }\r\n\r\n  public draftsAreEqual(draft1: DraftMessage, draft2: DraftMessage) {\r\n    if(typeof(draft1) !== typeof(draft2)) {\r\n      return false;\r\n    }\r\n\r\n    if(!isObject(draft1)) {\r\n      return true;\r\n    }\r\n\r\n    if(draft1._ !== draft2._) {\r\n      return false;\r\n    }\r\n  \r\n    if(draft1._ === 'draftMessage' && draft2._ === draft1._) {\r\n      if(draft1.reply_to_msg_id !== draft2.reply_to_msg_id) {\r\n        return false;\r\n      }\r\n  \r\n      if(!deepEqual(draft1.entities, draft2.entities)) {\r\n        return false;\r\n      }\r\n  \r\n      if(draft1.message !== draft2.message) {\r\n        return false;\r\n      }\r\n  \r\n      if(draft1.pFlags.no_webpage !== draft2.pFlags.no_webpage) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  public isEmptyDraft(draft: DraftMessage) {\r\n    if(!draft || draft._ === 'draftMessageEmpty') {\r\n      return true;\r\n    }\r\n    \r\n    if(draft.reply_to_msg_id > 0) {\r\n      return false;\r\n    }\r\n    \r\n    if(!draft.message.length) {\r\n      return true;\r\n    }\r\n    \r\n    return false;\r\n  }\r\n\r\n  public processApiDraft(draft: DraftMessage): MyDraftMessage {\r\n    if(!draft || draft._ !== 'draftMessage') {\r\n      return undefined;\r\n    }\r\n\r\n    const myEntities = RichTextProcessor.parseEntities(draft.message);\r\n    const apiEntities = draft.entities || [];\r\n    const totalEntities = RichTextProcessor.mergeEntities(apiEntities.slice(), myEntities); // ! only in this order, otherwise bold and emoji formatting won't work\r\n\r\n    draft.rMessage = documentFragmentToHTML(RichTextProcessor.wrapDraftText(draft.message, {entities: totalEntities}));\r\n    //draft.rReply = appMessagesManager.getRichReplyText(draft);\r\n    if(draft.reply_to_msg_id) {\r\n      draft.reply_to_msg_id = appMessagesIdsManager.generateMessageId(draft.reply_to_msg_id);\r\n    }\r\n\r\n    return draft;\r\n  }\r\n\r\n  public async syncDraft(peerId: PeerId, threadId: number, localDraft?: DraftMessage, saveOnServer = true, force = false) {\r\n    // console.warn(dT(), 'sync draft', peerID)\r\n    const serverDraft = this.getDraft(peerId, threadId);\r\n    if(this.draftsAreEqual(serverDraft, localDraft)) {\r\n      // console.warn(dT(), 'equal drafts', localDraft, serverDraft)\r\n      return true;\r\n    }\r\n\r\n    // console.warn(dT(), 'changed draft', localDraft, serverDraft)\r\n    let params: MessagesSaveDraft = {\r\n      peer: appPeersManager.getInputPeerById(peerId),\r\n      message: ''\r\n    };\r\n\r\n    let draftObj: DraftMessage;\r\n    if(this.isEmptyDraft(localDraft)) {\r\n      draftObj = {_: 'draftMessageEmpty'};\r\n    } else {\r\n      assumeType<DraftMessage.draftMessage>(localDraft);\r\n      let message = localDraft.message;\r\n      let entities: MessageEntity[] = localDraft.entities;\r\n\r\n      if(localDraft.reply_to_msg_id) {\r\n        params.reply_to_msg_id = appMessagesIdsManager.getServerMessageId(localDraft.reply_to_msg_id);\r\n      }\r\n\r\n      if(entities?.length) {\r\n        params.entities = appMessagesManager.getInputEntities(entities);\r\n      }\r\n\r\n      if(localDraft.pFlags.no_webpage) {\r\n        params.no_webpage = localDraft.pFlags.no_webpage;\r\n      }\r\n\r\n      params.message = message;\r\n    }\r\n\r\n    const saveLocalDraft = draftObj || localDraft;\r\n    saveLocalDraft.date = tsNow(true) + serverTimeManager.serverTimeOffset;\r\n\r\n    this.saveDraft(peerId, threadId, saveLocalDraft, {notify: true, force});\r\n\r\n    if(saveOnServer && !threadId) {\r\n      return apiManager.invokeApi('messages.saveDraft', params);\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  public clearAllDrafts() {\r\n    return apiManager.invokeApi('messages.clearAllDrafts').then(bool => {\r\n      if(!bool) {\r\n        return;\r\n      }\r\n\r\n      for(const combined in this.drafts) {\r\n        const [peerId, threadId] = combined.split('_');\r\n        rootScope.dispatchEvent('draft_updated', {\r\n          peerId: peerId.toPeerId(),\r\n          threadId: threadId ? +threadId : undefined,\r\n          draft: undefined\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  public clearDraft(peerId: PeerId, threadId: number) {\r\n    const emptyDraft: DraftMessage.draftMessageEmpty = {\r\n      _: 'draftMessageEmpty'\r\n    };\r\n\r\n    if(threadId) {\r\n      this.syncDraft(peerId, threadId, emptyDraft as any, false, true);\r\n    } else {\r\n      this.saveDraft(peerId, threadId, emptyDraft, {notify: true, force: true});  \r\n    }\r\n  }\r\n\r\n  public setDraft(peerId: PeerId, threadId: number, message: string, entities?: MessageEntity[]) {\r\n    const draft: DraftMessage.draftMessage = {\r\n      _: 'draftMessage',\r\n      date: Date.now() / 1000 | 0,\r\n      message,\r\n      pFlags: {},\r\n      entities\r\n    };\r\n\r\n    if(threadId) {\r\n      this.syncDraft(peerId, threadId, draft, false, true);\r\n    } else {\r\n      this.saveDraft(peerId, threadId, draft, {notify: true, force: true});  \r\n    }\r\n  }\r\n}\r\n\r\nconst appDraftsManager = new AppDraftsManager();\r\nMOUNT_CLASS_TO.appDraftsManager = appDraftsManager;\r\nexport default appDraftsManager;\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n * \r\n * Originally from:\r\n * https://github.com/evgeny-nadymov/telegram-react\r\n * Copyright (C) 2018 Evgeny Nadymov\r\n * https://github.com/evgeny-nadymov/telegram-react/blob/master/LICENSE\r\n */\r\n\r\nimport indexOfAndSplice from '../../helpers/array/indexOfAndSplice';\r\nimport safeAssign from '../../helpers/object/safeAssign';\r\nimport { GroupCallParticipantVideoSourceGroup } from '../../layer';\r\nimport { fixMediaLineType, SDPBuilder, WebRTCLineType, WEBRTC_MEDIA_PORT } from './sdpBuilder';\r\nimport { AudioCodec, GroupCallConnectionTransport, Ssrc, UpdateGroupCallConnectionData, VideoCodec } from './types';\r\n\r\nexport class ConferenceEntry {\r\n  public source: number;\r\n  public sourceGroups: GroupCallParticipantVideoSourceGroup[];\r\n  public transceiver: RTCRtpTransceiver;\r\n  public originalDirection: RTCRtpTransceiverDirection;\r\n  public direction: RTCRtpTransceiverDirection;\r\n  public port: string;\r\n  public endpoint: string;\r\n  public peerId: PeerId;\r\n  \r\n  public sendEntry: ConferenceEntry;\r\n  public recvEntry: ConferenceEntry;\r\n\r\n  constructor(public mid: string, public type: WebRTCLineType) {\r\n    this.port = WEBRTC_MEDIA_PORT;\r\n  }\r\n\r\n  public setDirection(direction: RTCRtpTransceiverDirection) {\r\n    if(!this.originalDirection) {\r\n      this.originalDirection = direction;\r\n    }\r\n\r\n    return this.direction = direction;\r\n  }\r\n\r\n  public setPort(port: string) {\r\n    return this.port = port;\r\n  }\r\n\r\n  public setEndpoint(endpoint: string) {\r\n    return this.endpoint = endpoint;\r\n  }\r\n\r\n  public setPeerId(peerId: PeerId) {\r\n    return this.peerId = peerId;\r\n  }\r\n\r\n  public createTransceiver(connection: RTCPeerConnection, init?: RTCRtpTransceiverInit) {\r\n    if(init?.direction) {\r\n      this.setDirection(init.direction);\r\n    }\r\n\r\n    return this.transceiver = connection.addTransceiver(fixMediaLineType(this.type), init);\r\n  }\r\n\r\n  public setSource(source: number | GroupCallParticipantVideoSourceGroup[]) {\r\n    let sourceGroups: GroupCallParticipantVideoSourceGroup[];\r\n    if(Array.isArray(source)) {\r\n      if(!source[0]) return;\r\n      sourceGroups = source;\r\n      source = sourceGroups[0].sources[0];\r\n    }\r\n\r\n    this.sourceGroups = sourceGroups;\r\n    return this.source = source;\r\n  }\r\n\r\n  public shouldBeSkipped(isAnswer?: boolean) {\r\n    return isAnswer && this.direction === 'inactive';\r\n  }\r\n}\r\n\r\nexport function generateSsrc(type: WebRTCLineType, source: number | GroupCallParticipantVideoSourceGroup[], endpoint?: string): Ssrc {\r\n  let sourceGroups: GroupCallParticipantVideoSourceGroup[];\r\n  if(Array.isArray(source)) {\r\n    if(!source[0]) return;\r\n    sourceGroups = source;\r\n    source = sourceGroups[0].sources[0];\r\n  }\r\n  \r\n  return {\r\n    endpoint,\r\n    type,\r\n    source,\r\n    sourceGroups,\r\n  };\r\n}\r\n\r\nexport default class LocalConferenceDescription implements UpdateGroupCallConnectionData {\r\n  public readonly sessionId: string;\r\n  // public ssrcs: Ssrc[];\r\n  public readonly transport: GroupCallConnectionTransport;\r\n  public readonly audio?: AudioCodec;\r\n  public readonly video: VideoCodec;\r\n  public readonly screencast?: VideoCodec;\r\n  \r\n  private maxSeenId: number;\r\n  public readonly entries: ConferenceEntry[];\r\n  private entriesByMid: Map<ConferenceEntry['mid'], ConferenceEntry>;\r\n  private entriesBySource: Map<ConferenceEntry['source'], ConferenceEntry>;\r\n  private entriesByPeerId: Map<ConferenceEntry['peerId'], Set<ConferenceEntry>>;\r\n  \r\n  constructor(public connection: RTCPeerConnection) {\r\n    this.sessionId = '' + Date.now();\r\n    // this.ssrcs = [];\r\n    this.maxSeenId = -1;\r\n    this.entries = [];\r\n    this.entriesByMid = new Map();\r\n    this.entriesBySource = new Map();\r\n    this.entriesByPeerId = new Map();\r\n  }\r\n\r\n  public setData(data: UpdateGroupCallConnectionData) {\r\n    return safeAssign(this, data);\r\n  }\r\n\r\n  public createEntry(type: WebRTCLineType) {\r\n    const mid = '' + ++this.maxSeenId;\r\n    const entry = new ConferenceEntry(mid, type);\r\n    this.entries.push(entry);\r\n    this.entriesByMid.set(mid, entry);\r\n    return entry;\r\n  }\r\n\r\n  public deleteEntry(entry: ConferenceEntry) {\r\n    indexOfAndSplice(this.entries, entry);\r\n    this.entriesByMid.delete(entry.mid);\r\n    this.entriesBySource.delete(entry.source);\r\n\r\n    const set = this.entriesByPeerId.get(entry.peerId);\r\n    if(set) {\r\n      set.delete(entry);\r\n      if(!set.size) {\r\n        this.entriesByPeerId.delete(entry.peerId);\r\n      }\r\n    }\r\n  }\r\n\r\n  public setEntrySource(entry: ConferenceEntry, source: Parameters<ConferenceEntry['setSource']>[0]) {\r\n    entry.setSource(source);\r\n    this.entriesBySource.set(entry.source, entry);\r\n  }\r\n\r\n  public setEntryPeerId(entry: ConferenceEntry, peerId: ConferenceEntry['peerId']) {\r\n    entry.setPeerId(peerId);\r\n    let set = this.entriesByPeerId.get(peerId);\r\n    if(!set) {\r\n      this.entriesByPeerId.set(peerId, set = new Set());\r\n    }\r\n\r\n    set.add(entry);\r\n  }\r\n  \r\n  public findEntry(verify: Parameters<LocalConferenceDescription['entries']['find']>[0]) {\r\n    return this.entries.find(verify);\r\n  }\r\n\r\n  public findFreeSendRecvEntry(type: WebRTCLineType, isSending: boolean) {\r\n    let entry = this.entries.find(entry => {\r\n      return entry.direction === 'sendrecv' && entry.type === type && !(isSending ? entry.sendEntry : entry.recvEntry);\r\n    });\r\n\r\n    if(!entry) {\r\n      entry = this.createEntry(type);\r\n      entry.setDirection('sendrecv');\r\n    }\r\n\r\n    return entry;\r\n  }\r\n  \r\n  public getEntryByMid(mid: ConferenceEntry['mid']) {\r\n    return this.entriesByMid.get(mid);\r\n  }\r\n\r\n  public getEntryBySource(source: ConferenceEntry['source']) {\r\n    return this.entriesBySource.get(source);\r\n  }\r\n\r\n  public getEntriesByPeerId(peerId: ConferenceEntry['peerId']) {\r\n    return this.entriesByPeerId.get(peerId);\r\n  }\r\n\r\n  public generateSdp(options: Omit<Parameters<SDPBuilder['addConference']>[0], 'conference'>) {\r\n    return SDPBuilder.fromConference({\r\n      conference: this,\r\n      ...options\r\n    });\r\n  }\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n * \r\n * Originally from:\r\n * https://github.com/zhukov/webogram\r\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\r\n * https://github.com/zhukov/webogram/blob/master/LICENSE\r\n */\r\n\r\nimport { processSearchText, ProcessSearchTextOptions } from '../helpers/cleanSearchText';\r\nimport flatten from '../helpers/array/flatten';\r\n\r\nexport default class SearchIndex<SearchWhat> {\r\n  private fullTexts: Map<SearchWhat, string> = new Map();\r\n\r\n  // minChars can be 0 because it requires at least one word (one symbol) to be found\r\n  constructor(private options?: ProcessSearchTextOptions, private minChars = 0) {\r\n  }\r\n\r\n  public indexObject(id: SearchWhat, searchText: string) {\r\n    /* if(searchIndex.fullTexts.hasOwnProperty(id)) {\r\n      return false;\r\n    } */\r\n\r\n    if(this.options && searchText.trim()) {\r\n      searchText = processSearchText(searchText, this.options);\r\n    }\r\n\r\n    if(!searchText) {\r\n      this.fullTexts.delete(id);\r\n      return false;\r\n    }\r\n\r\n    this.fullTexts.set(id, searchText);\r\n    \r\n    /* const shortIndexes = searchIndex.shortIndexes;\r\n    searchText.split(' ').forEach((searchWord) => {\r\n      let len = Math.min(searchWord.length, 3),\r\n        wordPart, i;\r\n      for(i = 1; i <= len; i++) {\r\n        wordPart = searchWord.substr(0, i);\r\n        if(shortIndexes[wordPart] === undefined) {\r\n          shortIndexes[wordPart] = [id];\r\n        } else {\r\n          shortIndexes[wordPart].push(id);\r\n        }\r\n      }\r\n    }); */\r\n  }\r\n\r\n  private _search(query: string) {\r\n    const newFoundObjs: Array<{fullText: string, fullTextLength: number, what: SearchWhat, foundChars: number}> = [];\r\n    const fullTexts = this.fullTexts;\r\n    const queryWords = query.split(' ');\r\n    const queryWordsLength = queryWords.length;\r\n    fullTexts.forEach((fullText, what) => {\r\n      let found = true;\r\n      let foundChars = 0;\r\n      for(let i = 0; i < queryWordsLength; ++i) { // * verify that all words are found\r\n        const word = queryWords[i];\r\n        const idx = fullText.indexOf(word);\r\n        if(idx === -1 || (idx !== 0 && fullText[idx - 1] !== ' '/*  && !badCharsRe.test(fullText[idx - 1]) */)) { // * search only from word beginning\r\n          found = false;\r\n          break;\r\n        }\r\n\r\n        foundChars += word.length;\r\n      }\r\n\r\n      if(found) {\r\n        foundChars += queryWordsLength - 1;\r\n        const fullTextLength = fullText.length;\r\n        if(this.minChars <= foundChars || fullTextLength <= foundChars) {\r\n          newFoundObjs.push({fullText, fullTextLength, what, foundChars});\r\n        }\r\n      }\r\n    });\r\n\r\n    return newFoundObjs;\r\n  }\r\n\r\n  public search(query: string) {\r\n    if(this.options) {\r\n      query = processSearchText(query, this.options);\r\n    }\r\n\r\n    const queries = query.split('\\x01');\r\n    const newFoundObjs = flatten(queries.map(query => this._search(query)));\r\n\r\n    newFoundObjs.sort((a, b) => a.fullTextLength - b.fullTextLength || b.foundChars - a.foundChars);\r\n\r\n    //newFoundObjs.sort((a, b) => a.fullText.localeCompare(b.fullText));\r\n    const newFoundObjs2: Set<SearchWhat> = new Set(newFoundObjs.map(o => o.what));\r\n\r\n    return newFoundObjs2;\r\n  }\r\n}\r\n","export default function flatten<T>(arr: T[][]): T[] {\r\n  return arr.reduce((acc, val) => (acc.push(...val), acc), []);\r\n}\r\n","\r\nlet context: CanvasRenderingContext2D;\r\n/**\r\n * Get the text width\r\n * @param {string} text\r\n * @param {string} font\r\n */\r\nexport default function getTextWidth(text: string, font: string) {\r\n  //const perf = performance.now();\r\n  if(!context) {\r\n    const canvas = document.createElement('canvas');\r\n    context = canvas.getContext('2d');\r\n    context.font = font;\r\n  }\r\n\r\n  //context.font = font;\r\n  const metrics = context.measureText(text);\r\n  //console.log('getTextWidth perf:', performance.now() - perf);\r\n  return metrics.width;\r\n  //return Math.round(metrics.width);\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport getTextWidth from \"../helpers/canvas/getTextWidth\";\r\nimport mediaSizes, { MediaSize } from \"../helpers/mediaSizes\";\r\nimport clamp from \"../helpers/number/clamp\";\r\nimport { fastRaf } from \"../helpers/schedulers\";\r\n\r\n// Thanks to https://stackoverflow.com/a/49349813\r\n\r\n/**\r\n * Attibute modifier to create middle ellipsis\r\n * When the attribute value is left blank the ellipsis will be in the middle\r\n * When positive the attribute value will be used as a percentage\r\n * When negative the attribute value will be used as character index counted from the end\r\n * @example\r\n *   <div data-middle-ellipsis>A Javascript solution to middle ellipsis</div>\r\n *   <div data-middle-ellipsis=\"20\">A Javascript solution to middle ellipsis</div>\r\n *   <div data-middle-ellipsis=\"-3\">A Javascript solution to middle ellipsis</div>\r\n */\r\nconst ellipsis = '…';\r\nconst map: Map<HTMLElement, {\r\n  text: string,\r\n  textLength: number,\r\n  from: number,\r\n  multiplier: number,\r\n  font: string,\r\n  textWidth: number,\r\n  elementWidth: number\r\n}> = new Map();\r\n\r\nconst testQueue: Set<HTMLElement> = new Set();\r\nexport const fontFamily = 'Roboto, -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Oxygen-Sans, Ubuntu, Cantarell, \"Helvetica Neue\", sans-serif';\r\nconst fontSize = '16px';\r\nlet pendingTest = false;\r\n\r\nfunction setTestQueue() {\r\n  if(pendingTest) {\r\n    return;\r\n  }\r\n\r\n  pendingTest = true;\r\n  fastRaf(() => {\r\n    pendingTest = false;\r\n    testQueueElements();\r\n  });\r\n}\r\n\r\nfunction testQueueElements() {\r\n  testQueue.forEach(testElement);\r\n  testQueue.clear();\r\n}\r\n\r\nwindow.addEventListener('resize', () => {\r\n  for(const [key] of map) {\r\n    testQueue.add(key);\r\n  }\r\n  \r\n  setTestQueue();\r\n}, {capture: true, passive: true});\r\n\r\nfunction getElementWidth(element: HTMLElement) {\r\n  const type = element.dataset.sizeType;\r\n  if(type) {\r\n    const mediaSize = mediaSizes.active;\r\n    // @ts-ignore\r\n    const size: MediaSize = mediaSize[type];\r\n    return size.width;\r\n  } \r\n  \r\n  return element.getBoundingClientRect().width;\r\n}\r\n\r\nfunction testElement(element: HTMLElement) {\r\n  //const perf = performance.now();\r\n  // do not recalculate variables a second time\r\n  let mapped = map.get(element);\r\n  const firstTime = !mapped;\r\n\r\n  let {text, textLength, from, multiplier, font, textWidth, elementWidth} = mapped || {};\r\n  //console.log('[MEE] testElement got mapped', mapped);\r\n\r\n  if(firstTime) {\r\n    text = element.textContent;\r\n    textLength = text.length;\r\n    from = /* parseFloat(element.getAttribute(attributeName)) ||  */50;\r\n    multiplier = from > 0 && from / 100;\r\n\r\n    //const perf = performance.now();\r\n    font = `${element.dataset.fontWeight || 400} ${fontSize} ${fontFamily}`;\r\n    /* const computedStyle = window.getComputedStyle(elm, null);\r\n    font = `${computedStyle.getPropertyValue('font-weight')} ${computedStyle.getPropertyValue('font-size')} ${computedStyle.getPropertyValue('font-family')}`; */\r\n    //console.log('testMiddleEllipsis get computed style:', performance.now() - perf, font);\r\n\r\n    textWidth = getTextWidth(text, font);\r\n    //const perf = performance.now();\r\n    elementWidth = getElementWidth(element);\r\n    //console.log('testMiddleEllipsis get offsetWidth:', performance.now() - perf, font);\r\n    mapped = {text, textLength, from, multiplier, font, textWidth, elementWidth};\r\n    map.set(element, mapped);\r\n\r\n    //console.log('[MEE] testElement map set', element);\r\n  }\r\n  \r\n  const newElementWidth = getElementWidth(element);\r\n  const widthChanged = firstTime || elementWidth !== newElementWidth;\r\n  !firstTime && widthChanged && (mapped.elementWidth = elementWidth = newElementWidth);\r\n  \r\n  if(widthChanged) {\r\n    if(textWidth > elementWidth) {\r\n      element.setAttribute('title', text);\r\n      let smallerText = text;\r\n      let smallerWidth = elementWidth;\r\n      while(smallerText.length > 3) {\r\n        let smallerTextLength = smallerText.length;\r\n        const half = multiplier &&\r\n          clamp(multiplier * smallerTextLength << 0, 1, smallerTextLength - 2) ||\r\n          Math.max(smallerTextLength + from - 1, 1);\r\n        const half1 = smallerText.substr(0, half).replace(/\\s*$/,'');\r\n        const half2 = smallerText.substr(half + 1).replace(/^\\s*/,'');\r\n        smallerText = half1 + half2;\r\n        smallerWidth = getTextWidth(smallerText + ellipsis, font);\r\n        if(smallerWidth < elementWidth) {\r\n          element.textContent = half1 + ellipsis + half2;\r\n          break;\r\n        }\r\n      }\r\n\r\n      // * set new width after cutting text\r\n      mapped.elementWidth = getElementWidth(element);\r\n      //mapped.textWidth = smallerWidth;\r\n    } else {\r\n      element.removeAttribute('title');\r\n    }\r\n  }\r\n\r\n  //console.log('testMiddleEllipsis for element:', elm, performance.now() - perf);\r\n}\r\n\r\nexport class MiddleEllipsisElement extends HTMLElement {\r\n  connectedCallback() {\r\n    //console.log('[MEE]: connectedCallback before', map.has(this), testQueue.has(this), map.size, this.textContent, map);\r\n\r\n    map.set(this, null);\r\n    if(this.dataset.sizeType) {\r\n      testElement(this);\r\n    } else {\r\n      testQueue.add(this);\r\n      setTestQueue();\r\n    }\r\n    //testElement(this);\r\n\r\n    //console.log('[MEE]: connectedCallback after', map.has(this), map.size, testQueue.has(this), testQueue.size);\r\n  }\r\n\r\n  disconnectedCallback() {\r\n    const deleted = map.delete(this);\r\n    testQueue.delete(this);\r\n    //console.log('[MEE]: disconnectedCallback', deleted, map.has(this), map.size, this.textContent, map);\r\n  }\r\n}\r\n\r\ncustomElements.define(\"middle-ellipsis-element\", MiddleEllipsisElement);\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n * \r\n * Originally from:\r\n * https://github.com/evgeny-nadymov/telegram-react\r\n * Copyright (C) 2018 Evgeny Nadymov\r\n * https://github.com/evgeny-nadymov/telegram-react/blob/master/LICENSE\r\n */\r\n\r\nimport { MOUNT_CLASS_TO } from \"../../config/debug\";\r\nimport AudioAssetPlayer from \"../../helpers/audioAssetPlayer\";\r\nimport safeReplaceObject from \"../../helpers/object/safeReplaceObject\";\r\nimport { nextRandomUint } from \"../../helpers/random\";\r\nimport tsNow from \"../../helpers/tsNow\";\r\nimport { GroupCall, GroupCallParticipant, GroupCallParticipantVideo, GroupCallParticipantVideoSourceGroup, InputGroupCall, Peer, PhoneJoinGroupCall, PhoneJoinGroupCallPresentation, Update, Updates } from \"../../layer\";\r\nimport GroupCallInstance from \"../calls/groupCallInstance\";\r\nimport GROUP_CALL_STATE from \"../calls/groupCallState\";\r\nimport createMainStreamManager from \"../calls/helpers/createMainStreamManager\";\r\nimport { generateSsrc } from \"../calls/localConferenceDescription\";\r\nimport { WebRTCLineType } from \"../calls/sdpBuilder\";\r\nimport StreamManager from \"../calls/streamManager\";\r\nimport { Ssrc } from \"../calls/types\";\r\nimport { logger } from \"../logger\";\r\nimport apiManager from \"../mtproto/mtprotoworker\";\r\nimport { NULL_PEER_ID } from \"../mtproto/mtproto_config\";\r\nimport rootScope from \"../rootScope\";\r\nimport apiUpdatesManager from \"./apiUpdatesManager\";\r\nimport appChatsManager from \"./appChatsManager\";\r\nimport appPeersManager from \"./appPeersManager\";\r\nimport appUsersManager from \"./appUsersManager\";\r\n\r\nexport type GroupCallId = GroupCall['id'];\r\nexport type MyGroupCall = GroupCall | InputGroupCall;\r\n\r\nexport type GroupCallConnectionType = 'main' | 'presentation';\r\n\r\nexport type JoinGroupCallJsonPayload = {\r\n  fingerprints: {\r\n    fingerprint: string;\r\n    setup: string;\r\n    hash: string;\r\n  }[];\r\n  pwd: string;\r\n  ssrc: number;\r\n  'ssrc-groups': GroupCallParticipantVideoSourceGroup.groupCallParticipantVideoSourceGroup[];\r\n  ufrag: string;\r\n};\r\n\r\nconst GET_PARTICIPANTS_LIMIT = 100;\r\n\r\nlet IS_MUTED = true;\r\n\r\nexport type GroupCallOutputSource = 'main' | 'presentation' | number;\r\n\r\nexport type GroupCallAudioAssetName = \"group_call_connect.mp3\" | \"group_call_end.mp3\" | \"group_call_start.mp3\" | \"voip_onallowtalk.mp3\";\r\n\r\nexport class AppGroupCallsManager {\r\n  private log: ReturnType<typeof logger>;\r\n  \r\n  private groupCalls: Map<GroupCallId, MyGroupCall>;\r\n  private participants: Map<GroupCallId, Map<PeerId, GroupCallParticipant>>;\r\n  private nextOffsets: Map<GroupCallId, string>;\r\n  \r\n  // private audioAsset: AudioAsset;\r\n  \r\n  private currentGroupCall: GroupCallInstance;\r\n  private connectionAudio: HTMLAudioElement;\r\n  private doNotDispatchParticipantUpdate: PeerId;\r\n  private audioAsset: AudioAssetPlayer<GroupCallAudioAssetName>;\r\n\r\n  constructor() {\r\n    this.log = logger('GROUP-CALLS');\r\n    \r\n    this.groupCalls = new Map();\r\n    this.participants = new Map();\r\n    this.nextOffsets = new Map();\r\n    \r\n    rootScope.addMultipleEventsListeners({\r\n      updateGroupCall: (update) => {\r\n        this.saveGroupCall(update.call, update.chat_id);\r\n      },\r\n      \r\n      updateGroupCallParticipants: (update) => {\r\n        this.saveGroupCall(update.call);\r\n        \r\n        // this.getGroupCallFull(update.call.id, true); // ! WARNING TEMP\r\n\r\n        const groupCallId = update.call.id;\r\n        this.saveApiParticipants(groupCallId, update.participants);\r\n      }\r\n    });\r\n\r\n    rootScope.addEventListener('group_call_update', (groupCall) => {\r\n      if(groupCall._ === 'groupCallDiscarded') {\r\n        const {currentGroupCall} = this;\r\n        if(currentGroupCall?.id === groupCall.id) {\r\n          currentGroupCall.hangUp(false, false, true);\r\n        }\r\n\r\n        this.participants.delete(groupCall.id);\r\n      }\r\n    });\r\n\r\n    this.audioAsset = new AudioAssetPlayer<GroupCallAudioAssetName>([\r\n      'group_call_connect.mp3',\r\n      'group_call_end.mp3',\r\n      'group_call_start.mp3',\r\n      'voip_onallowtalk.mp3'\r\n    ]);\r\n  }\r\n\r\n  get groupCall() {\r\n    return this.currentGroupCall;\r\n  }\r\n\r\n  public getCachedParticipants(groupCallId: GroupCallId) {\r\n    let participants = this.participants.get(groupCallId);\r\n    if(!participants) {\r\n      this.participants.set(groupCallId, participants = new Map());\r\n    }\r\n\r\n    return participants;\r\n  }\r\n\r\n  private prepareToSavingNextOffset(groupCallId: GroupCallId) {\r\n    const nextOffsetsMap = this.nextOffsets;\r\n\r\n    const setNextOffset = (newNextOffset: string) => {\r\n      if(nextOffsetsMap.get(groupCallId) === nextOffset) {\r\n        nextOffsetsMap.set(groupCallId, newNextOffset);\r\n      }\r\n    };\r\n\r\n    const nextOffset = nextOffsetsMap.get(groupCallId);\r\n    return {\r\n      nextOffset,\r\n      setNextOffset\r\n    };\r\n  }\r\n\r\n  public saveApiParticipant(groupCallId: GroupCallId, participant: GroupCallParticipant, skipCounterUpdating?: boolean) {\r\n    const {currentGroupCall} = this;\r\n    const participants = this.getCachedParticipants(groupCallId);\r\n\r\n    const peerId = appPeersManager.getPeerId(participant.peer);\r\n\r\n    const oldParticipant = participants.get(peerId);\r\n    const hasLeft = participant.pFlags.left;\r\n    if(!oldParticipant && hasLeft) {\r\n      return;\r\n    }\r\n\r\n    // * fix missing flag\r\n    if(!participant.pFlags.muted && !participant.pFlags.can_self_unmute) {\r\n      participant.pFlags.can_self_unmute = true;\r\n    }\r\n\r\n    const isCurrentGroupCall = currentGroupCall?.id === groupCallId;\r\n\r\n    if(oldParticipant) {\r\n      safeReplaceObject(oldParticipant, participant);\r\n      participant = oldParticipant;\r\n    } else {\r\n      participants.set(peerId, participant);\r\n    }\r\n\r\n    if(isCurrentGroupCall) {\r\n      currentGroupCall.onParticipantUpdate(participant, this.doNotDispatchParticipantUpdate);\r\n    }\r\n\r\n    // if(!skipCounterUpdating) {\r\n      const groupCall = this.getGroupCall(groupCallId);\r\n      if(groupCall?._ === 'groupCall') {\r\n        let modified = false;\r\n        if(hasLeft) {\r\n          --groupCall.participants_count;\r\n          modified = true;\r\n        } else if(participant.pFlags.just_joined && !oldParticipant && !participant.pFlags.self) {\r\n          ++groupCall.participants_count;\r\n          modified = true;\r\n        }\r\n  \r\n        if(modified) {\r\n          rootScope.dispatchEvent('group_call_update', groupCall);\r\n        }\r\n      }\r\n    // }\r\n    \r\n    if(hasLeft) {\r\n      participants.delete(peerId);\r\n    }\r\n\r\n    if(oldParticipant && this.doNotDispatchParticipantUpdate !== peerId) {\r\n      rootScope.dispatchEvent('group_call_participant', {\r\n        groupCallId,\r\n        participant\r\n      });\r\n    }\r\n  }\r\n\r\n  public saveApiParticipants(groupCallId: GroupCallId, apiParticipants: GroupCallParticipant[], skipCounterUpdating?: boolean) {\r\n    if((apiParticipants as any).saved) return;\r\n    (apiParticipants as any).saved = true;\r\n    apiParticipants.forEach(p => this.saveApiParticipant(groupCallId, p, skipCounterUpdating));\r\n  }\r\n\r\n  public async editParticipant(groupCallId: GroupCallId, participant: GroupCallParticipant, options: Partial<{\r\n    muted: boolean,\r\n    volume: number,\r\n    raiseHand: boolean,\r\n    videoStopped: boolean,\r\n    videoPaused: boolean,\r\n    presentationPaused: boolean\r\n  }>) {\r\n    if(!Object.keys(options).length) {\r\n      return;\r\n    }\r\n\r\n    let processUpdate = true;\r\n    if(participant) {\r\n      const {currentGroupCall} = this;\r\n      const isCurrentCall = currentGroupCall?.id === groupCallId;\r\n      const isUpdatingMeInCurrentCall = isCurrentCall && participant.pFlags.self;\r\n\r\n      if(isUpdatingMeInCurrentCall) {\r\n        if(options.muted !== undefined && !currentGroupCall.isSharingAudio) {\r\n          delete options.muted;\r\n\r\n          if(!Object.keys(options).length) {\r\n            return;\r\n          }\r\n        }\r\n      }\r\n\r\n      // if(isCurrentCall) {\r\n        const muted = options.muted;\r\n        if(muted !== undefined) {\r\n          /* const isAdmin = appChatsManager.hasRights(currentGroupCall.chatId, 'manage_call');\r\n          if(isAdmin) {\r\n            if(muted) {\r\n              participant.pFlags.muted = true;\r\n              delete participant.pFlags.can_self_unmute;\r\n            } else {\r\n              participant.pFlags.can_self_unmute = true;\r\n            }\r\n          } else  */if(participant.pFlags.self) {\r\n            if(muted) {\r\n              participant.pFlags.muted = true;\r\n            } else if(participant.pFlags.can_self_unmute) {\r\n              delete participant.pFlags.muted;\r\n            }\r\n          }/*  else {\r\n            if(muted) {\r\n              participant.pFlags.muted_by_you = true;\r\n            } else {\r\n              delete participant.pFlags.muted_by_you;\r\n            }\r\n          } */\r\n        }\r\n      // }\r\n\r\n      /* const a: [keyof GroupCallParticipant['pFlags'], keyof typeof options][] = [\r\n        ['muted', 'muted']\r\n      ];\r\n\r\n      a.forEach(([key, optionKey]) => {\r\n        const value = options[optionKey];\r\n        if(value === undefined) {\r\n          return;\r\n        }\r\n\r\n        if(value) {\r\n          participant.pFlags[key] = true;\r\n        } else {\r\n          delete participant.pFlags[key];\r\n        }\r\n      }); */\r\n\r\n      if(options.raiseHand !== undefined) {\r\n        if(options.raiseHand) participant.raise_hand_rating = '1';\r\n        else delete participant.raise_hand_rating;\r\n      }\r\n\r\n      if(isUpdatingMeInCurrentCall) {\r\n        if(options.videoStopped !== undefined) {\r\n          if(options.videoStopped) delete participant.video;\r\n          else participant.video = this.generateSelfVideo(currentGroupCall.connections.main.sources.video);\r\n        }\r\n\r\n        if(!participant.pFlags.muted && participant.pFlags.can_self_unmute) {\r\n          currentGroupCall.setMuted(false);\r\n        }\r\n\r\n        currentGroupCall.dispatchEvent('state', currentGroupCall.state);\r\n      }\r\n\r\n      rootScope.dispatchEvent('group_call_participant', {groupCallId, participant});\r\n\r\n      /* if(participant.pFlags.self) {\r\n        processUpdate = false;\r\n      } */\r\n    }\r\n\r\n    const peerId = participant.pFlags.self ? NULL_PEER_ID : appPeersManager.getPeerId(participant.peer);\r\n    const updates = await apiManager.invokeApiSingle('phone.editGroupCallParticipant', {\r\n      call: appGroupCallsManager.getGroupCallInput(groupCallId),\r\n      participant: peerId === NULL_PEER_ID ? appPeersManager.getInputPeerSelf() : appPeersManager.getInputPeerById(peerId),\r\n      muted: options.muted,\r\n      volume: options.volume,\r\n      raise_hand: options.raiseHand,\r\n      video_paused: options.videoPaused,\r\n      video_stopped: options.videoStopped,\r\n      presentation_paused: options.presentationPaused\r\n    });\r\n    \r\n    // do not replace with peerId because it can be null\r\n    if(!processUpdate) this.doNotDispatchParticipantUpdate = appPeersManager.getPeerId(participant.peer);\r\n    apiUpdatesManager.processUpdateMessage(updates);\r\n    if(!processUpdate) this.doNotDispatchParticipantUpdate = undefined;\r\n  }\r\n  \r\n  public getGroupCall(id: GroupCallId) {\r\n    return this.groupCalls.get(id);\r\n  }\r\n\r\n  public async getGroupCallFull(id: GroupCallId, override?: boolean): Promise<GroupCall> {\r\n    const call = this.getGroupCall(id);\r\n    if(call && call._ !== 'inputGroupCall' && !override) {\r\n      return call;\r\n    }\r\n\r\n    const limit = this.getCachedParticipants(id).size ? 0 : GET_PARTICIPANTS_LIMIT;\r\n    return apiManager.invokeApiSingleProcess({\r\n      method: 'phone.getGroupCall',\r\n      params: {\r\n        call: this.getGroupCallInput(id),\r\n        limit\r\n      },\r\n      processResult: (groupCall) => {\r\n        // ? maybe I should save group call after participants so I can avoid passing the 'skipCounterUpdating' flag ?\r\n        appUsersManager.saveApiUsers(groupCall.users);\r\n        appChatsManager.saveApiChats(groupCall.chats);\r\n        this.saveApiParticipants(id, groupCall.participants, true);\r\n        const call = this.saveGroupCall(groupCall.call) as GroupCall;\r\n\r\n        if(limit && this.nextOffsets.get(id) === undefined) {\r\n          this.nextOffsets.set(id, groupCall.participants_next_offset);\r\n        }\r\n\r\n        return call;\r\n      }\r\n    });\r\n  }\r\n  \r\n  public saveGroupCall(call: MyGroupCall, chatId?: ChatId) {\r\n    const oldCall = this.groupCalls.get(call.id);\r\n    const shouldUpdate = call._ !== 'inputGroupCall' && (!oldCall || oldCall._ !== 'groupCallDiscarded');\r\n    if(oldCall) {\r\n      if(shouldUpdate) {\r\n        safeReplaceObject(oldCall, call);\r\n      }\r\n      \r\n      call = oldCall;\r\n    } else {\r\n      this.groupCalls.set(call.id, call);\r\n    }\r\n\r\n    if(shouldUpdate) {\r\n      rootScope.dispatchEvent('group_call_update', call as any);\r\n    }\r\n\r\n    return call;\r\n  }\r\n  \r\n  public startConnectingSound() {\r\n    this.stopConnectingSound();\r\n    this.audioAsset.playSoundWithTimeout('group_call_connect.mp3', true, 2500);\r\n  }\r\n  \r\n  public stopConnectingSound() {\r\n    this.audioAsset.stopSound();\r\n    this.audioAsset.cancelDelayedPlay();\r\n  }\r\n\r\n  public setCurrentGroupCall(groupCall: GroupCallInstance) {\r\n    this.currentGroupCall = groupCall;\r\n\r\n    if(groupCall) {\r\n      rootScope.dispatchEvent('group_call_instance', groupCall);\r\n    }\r\n    /* TdLibController.clientUpdate({\r\n      '@type': 'clientUpdateGroupCall',\r\n      call\r\n    }); */\r\n  }\r\n\r\n  public async createGroupCall(chatId: ChatId, scheduleDate?: number, title?: string) {\r\n    const updates = await apiManager.invokeApi('phone.createGroupCall', {\r\n      peer: appPeersManager.getInputPeerById(chatId.toPeerId(true)),\r\n      random_id: nextRandomUint(32),\r\n      schedule_date: scheduleDate,\r\n      title\r\n    });\r\n\r\n    apiUpdatesManager.processUpdateMessage(updates);\r\n\r\n    const update = (updates as Updates.updates).updates.find(update => update._ === 'updateGroupCall') as Update.updateGroupCall;\r\n    return update.call;\r\n  }\r\n  \r\n  public async joinGroupCall(chatId: ChatId, groupCallId: GroupCallId, muted = IS_MUTED, rejoin?: boolean, joinVideo?: boolean) {\r\n    this.audioAsset.createAudio();\r\n\r\n    this.log(`joinGroupCall chatId=${chatId} id=${groupCallId} muted=${muted} rejoin=${rejoin}`);\r\n    \r\n    let streamManager: StreamManager;\r\n    if(rejoin) {\r\n      streamManager = this.currentGroupCall.connections.main.streamManager;\r\n    } else {\r\n      streamManager = await createMainStreamManager(muted, joinVideo);\r\n    }\r\n\r\n    return this.joinGroupCallInternal(chatId, groupCallId, streamManager, muted, rejoin, joinVideo);\r\n  }\r\n\r\n  public async joinGroupCallInternal(chatId: ChatId, groupCallId: GroupCallId, streamManager: StreamManager, muted: boolean, rejoin = false, joinVideo?: boolean) {\r\n    const log = this.log.bindPrefix('joinGroupCallInternal');\r\n    log('start', groupCallId);\r\n\r\n    const type: GroupCallConnectionType = 'main';\r\n\r\n    let {currentGroupCall} = this;\r\n    if(currentGroupCall && rejoin) {\r\n      // currentGroupCall.connections.main.connection = connection;\r\n      currentGroupCall.handleUpdateGroupCallParticipants = false;\r\n      currentGroupCall.updatingSdp = false;\r\n      log('update currentGroupCall', groupCallId, currentGroupCall);\r\n    } else {\r\n      currentGroupCall = new GroupCallInstance({\r\n        chatId,\r\n        id: groupCallId\r\n      });\r\n\r\n      currentGroupCall.fixSafariAudio();\r\n\r\n      currentGroupCall.addEventListener('state', (state) => {\r\n        if(this.currentGroupCall === currentGroupCall && state === GROUP_CALL_STATE.CLOSED) {\r\n          this.setCurrentGroupCall(null);\r\n          this.stopConnectingSound();\r\n          this.audioAsset.playSound('group_call_end.mp3');\r\n          rootScope.dispatchEvent('chat_update', currentGroupCall.chatId);\r\n        }\r\n      });\r\n\r\n      currentGroupCall.groupCall = await this.getGroupCallFull(groupCallId);\r\n\r\n      const connectionInstance = currentGroupCall.createConnectionInstance({\r\n        streamManager,\r\n        type,\r\n        options: {\r\n          type,\r\n          isMuted: muted,\r\n          joinVideo,\r\n          rejoin\r\n        }\r\n      });\r\n\r\n      const connection = connectionInstance.createPeerConnection();\r\n      connection.addEventListener('negotiationneeded', () => {\r\n        connectionInstance.negotiate();\r\n      });\r\n\r\n      connection.addEventListener('track', (event) => {\r\n        log('ontrack', event);\r\n        currentGroupCall.onTrack(event);\r\n      });\r\n  \r\n      connection.addEventListener('iceconnectionstatechange', () => {\r\n        currentGroupCall.dispatchEvent('state', currentGroupCall.state);\r\n        \r\n        const {iceConnectionState} = connection;\r\n        if(iceConnectionState === 'disconnected' || iceConnectionState === 'checking' || iceConnectionState === 'new') {\r\n          this.startConnectingSound();\r\n        } else {\r\n          this.stopConnectingSound();\r\n        }\r\n        \r\n        switch(iceConnectionState) {\r\n          case 'checking': {\r\n            break;\r\n          }\r\n          \r\n          case 'closed': {\r\n            currentGroupCall.hangUp();\r\n            break;\r\n          }\r\n          \r\n          case 'completed': {\r\n            break;\r\n          }\r\n          \r\n          case 'connected': {\r\n            if(!currentGroupCall.joined) {\r\n              currentGroupCall.joined = true;\r\n              this.audioAsset.playSound('group_call_start.mp3');\r\n  \r\n              this.getGroupCallParticipants(groupCallId).then(({participants}) => {\r\n                this.saveApiParticipants(groupCallId, [...participants.values()]);\r\n              });\r\n            }\r\n            \r\n            break;\r\n          }\r\n          \r\n          case 'disconnected': {\r\n            break;\r\n          }\r\n          \r\n          case 'failed': {\r\n            //TODO: replace with ICE restart\r\n            currentGroupCall.hangUp();\r\n            // connection.restartIce();\r\n            break;\r\n          }\r\n          \r\n          case 'new': {\r\n            break;\r\n          }\r\n        }\r\n      });\r\n\r\n      connectionInstance.createDescription();\r\n      connectionInstance.createDataChannel();\r\n\r\n      connectionInstance.appendStreamToConference();\r\n\r\n      this.setCurrentGroupCall(currentGroupCall);\r\n      log('set currentGroupCall', groupCallId, currentGroupCall);\r\n\r\n      this.startConnectingSound();\r\n\r\n      return connectionInstance.negotiate();\r\n    }\r\n  }\r\n  \r\n  public getGroupCallInput(id: GroupCallId): InputGroupCall {\r\n    const groupCall = this.getGroupCall(id);\r\n    return {\r\n      _: 'inputGroupCall',\r\n      id: groupCall.id,\r\n      access_hash: groupCall.access_hash\r\n    };\r\n  }\r\n\r\n  public generateSelfVideo(source: Ssrc, audioSource?: number): GroupCallParticipantVideo {\r\n    return source && {\r\n      _: 'groupCallParticipantVideo',\r\n      pFlags: {},\r\n      endpoint: '',\r\n      source_groups: source.sourceGroups,\r\n      audio_source: audioSource\r\n    };\r\n  }\r\n  \r\n  public generateSelfParticipant(): GroupCallParticipant {\r\n    const mainSources = this.currentGroupCall.connections.main.sources;\r\n    const presentationSources = this.currentGroupCall.connections.presentation?.sources;\r\n    return {\r\n      _: 'groupCallParticipant',\r\n      pFlags: {\r\n        can_self_unmute: true,\r\n        self: true\r\n      },\r\n      source: mainSources.audio.source,\r\n      video: this.generateSelfVideo(mainSources.video),\r\n      presentation: presentationSources && this.generateSelfVideo(presentationSources.video, presentationSources.audio?.source),\r\n      date: tsNow(true),\r\n      peer: appPeersManager.getOutputPeer(rootScope.myId)\r\n    };\r\n  }\r\n\r\n  public makeSsrcsFromParticipant = (participant: GroupCallParticipant) => {\r\n    return [\r\n      this.makeSsrcFromParticipant(participant, 'audio', participant.source),\r\n      participant.video?.audio_source && this.makeSsrcFromParticipant(participant, 'audio', participant.video.audio_source),\r\n      participant.video && this.makeSsrcFromParticipant(participant, 'video', participant.video.source_groups, participant.video.endpoint),\r\n      participant.presentation?.audio_source && this.makeSsrcFromParticipant(participant, 'audio', participant.presentation.audio_source),\r\n      participant.presentation && this.makeSsrcFromParticipant(participant, 'video', participant.presentation.source_groups, participant.presentation.endpoint)\r\n    ].filter(Boolean);\r\n  };\r\n\r\n  public makeSsrcFromParticipant(participant: GroupCallParticipant, type: WebRTCLineType, source?: number | GroupCallParticipantVideoSourceGroup[], endpoint?: string): Ssrc {\r\n    return generateSsrc(type, source, endpoint);\r\n  }\r\n\r\n  public async getGroupCallParticipants(id: GroupCallId) {\r\n    const {nextOffset, setNextOffset} = this.prepareToSavingNextOffset(id);\r\n\r\n    if(nextOffset !== '') {\r\n      await apiManager.invokeApiSingleProcess({\r\n        method: 'phone.getGroupParticipants', \r\n        params: {\r\n          call: this.getGroupCallInput(id),\r\n          ids: [],\r\n          sources: [],\r\n          offset: nextOffset || '',\r\n          limit: GET_PARTICIPANTS_LIMIT\r\n        },\r\n        processResult: (groupCallParticipants) => {\r\n          const newNextOffset = groupCallParticipants.count === groupCallParticipants.participants.length ? '' : groupCallParticipants.next_offset;\r\n  \r\n          appChatsManager.saveApiChats(groupCallParticipants.chats);\r\n          appUsersManager.saveApiUsers(groupCallParticipants.users);\r\n          this.saveApiParticipants(id, groupCallParticipants.participants);\r\n    \r\n          setNextOffset(newNextOffset);\r\n        }\r\n      });\r\n    }\r\n\r\n    return {\r\n      participants: this.getCachedParticipants(id),\r\n      isEnd: this.nextOffsets.get(id) === ''\r\n    };\r\n  }\r\n\r\n  public async hangUp(groupCallId: GroupCallId, discard = false, rejoin = false) {\r\n    this.log(`hangUp start id=${groupCallId} discard=${discard} rejoin=${rejoin}`);\r\n    const {currentGroupCall} = this;\r\n    if(currentGroupCall?.id !== groupCallId) return;\r\n\r\n    currentGroupCall.hangUp(discard, rejoin);\r\n  }\r\n\r\n  public toggleMuted(muted?: boolean) {\r\n    return this.changeUserMuted(NULL_PEER_ID, muted);\r\n  }\r\n  \r\n  public changeUserMuted(peerId: PeerId, muted?: boolean) {\r\n    const {currentGroupCall} = this;\r\n    if(!currentGroupCall) return;\r\n\r\n    const participant = currentGroupCall.getParticipantByPeerId(peerId);\r\n    if(NULL_PEER_ID === peerId && participant.pFlags.can_self_unmute) {\r\n      muted = muted === undefined ? !participant.pFlags.muted : muted;\r\n    }\r\n\r\n    return this.editParticipant(currentGroupCall.id, participant, {muted});\r\n  }\r\n}\r\n\r\nconst appGroupCallsManager = new AppGroupCallsManager();\r\nMOUNT_CLASS_TO && (MOUNT_CLASS_TO.appGroupCallsManager = appGroupCallsManager);\r\nexport default appGroupCallsManager;\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport { GROUP_CALL_AMPLITUDE_ANALYSE_INTERVAL_MS } from \"../constants\";\r\nimport StreamManager from \"../streamManager\";\r\nimport getAudioConstraints from \"./getAudioConstraints\";\r\nimport getStream from \"./getStream\";\r\nimport getVideoConstraints from \"./getVideoConstraints\";\r\n\r\nexport default async function createMainStreamManager(muted?: boolean, joinVideo?: boolean) {\r\n  const constraints: MediaStreamConstraints = {\r\n    audio: getAudioConstraints(),\r\n    video: joinVideo && getVideoConstraints()\r\n  };\r\n\r\n  const streamManager = new StreamManager(GROUP_CALL_AMPLITUDE_ANALYSE_INTERVAL_MS);\r\n  \r\n  try {\r\n    const stream = await getStream(constraints, muted);\r\n    streamManager.addStream(stream, 'input');\r\n  } catch(err) {\r\n    console.error('joinGroupCall getStream error', err, constraints);\r\n    streamManager.inputStream = new MediaStream();\r\n  }\r\n\r\n  return streamManager;\r\n}\r\n","export default function insertInDescendSortedArray<T extends {[smth in K]?: number}, K extends keyof T>(array: Array<T>, element: T, property: K, pos?: number) {\r\n  const sortProperty: number = element[property];\r\n\r\n  if(pos === undefined) {\r\n    pos = array.indexOf(element);\r\n    if(pos !== -1) {\r\n      const prev = array[pos - 1];\r\n      const next = array[pos + 1];\r\n      if((!prev || prev[property] >= sortProperty) && (!next || next[property] <= sortProperty)) {\r\n        // console.warn('same pos', pos, sortProperty, prev, next);\r\n        return pos;\r\n      }\r\n      \r\n      array.splice(pos, 1);\r\n    }\r\n  }\r\n\r\n  const len = array.length;\r\n  if(!len || sortProperty <= array[len - 1][property]) {\r\n    return array.push(element) - 1;\r\n  } else if(sortProperty >= array[0][property]) {\r\n    array.unshift(element);\r\n    return 0;\r\n  } else {\r\n    for(let i = 0; i < len; i++) {\r\n      if(sortProperty > array[i][property]) {\r\n        array.splice(i, 0, element);\r\n        return i;\r\n      }\r\n    }\r\n  }\r\n\r\n  console.error('wtf', array, element);\r\n  return array.indexOf(element);\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport { MOUNT_CLASS_TO } from \"../../config/debug\";\r\nimport copy from \"../../helpers/object/copy\";\r\nimport { InputMedia, Message, MessageEntity, MessageMedia, Poll, PollResults } from \"../../layer\";\r\nimport { logger, LogTypes } from \"../logger\";\r\nimport apiManager from \"../mtproto/mtprotoworker\";\r\nimport { RichTextProcessor } from \"../richtextprocessor\";\r\nimport rootScope from \"../rootScope\";\r\nimport apiUpdatesManager from \"./apiUpdatesManager\";\r\nimport appMessagesIdsManager from \"./appMessagesIdsManager\";\r\nimport appMessagesManager from './appMessagesManager';\r\nimport appPeersManager from './appPeersManager';\r\nimport appUsersManager from \"./appUsersManager\";\r\n\r\nexport class AppPollsManager {\r\n  public polls: {[id: string]: Poll} = {};\r\n  public results: {[id: string]: PollResults} = {};\r\n  public pollToMessages: {[id: string]: Set<string>} = {};\r\n\r\n  private log = logger('POLLS', LogTypes.Error);\r\n\r\n  constructor() {\r\n    rootScope.addMultipleEventsListeners({\r\n      updateMessagePoll: (update) => {\r\n        this.log('updateMessagePoll:', update);\r\n\r\n        let poll: Poll = update.poll || this.polls[update.poll_id];\r\n        if(!poll) {\r\n          return;\r\n        }\r\n\r\n        let results = update.results;\r\n        const ret = this.savePoll(poll, results as any);\r\n        poll = ret.poll;\r\n        results = ret.results;\r\n        \r\n        rootScope.dispatchEvent('poll_update', {poll, results: results as any});\r\n      }\r\n    });\r\n  }\r\n\r\n  public savePoll(poll: Poll, results: PollResults, message?: Message.message) {\r\n    if(message) {\r\n      this.updatePollToMessage(message, true);\r\n    }\r\n\r\n    const id = poll.id;\r\n    if(this.polls[id]) {\r\n      poll = Object.assign(this.polls[id], poll);\r\n      results = this.saveResults(poll, results);\r\n    } else {\r\n      this.polls[id] = poll;\r\n\r\n      poll.chosenIndexes = [];\r\n      results = this.saveResults(poll, results);\r\n    }\r\n\r\n    return {poll, results};\r\n  }\r\n\r\n  public saveResults(poll: Poll, results: PollResults) {\r\n    if(this.results[poll.id]) {\r\n      results = Object.assign(this.results[poll.id], results);\r\n    } else {\r\n      this.results[poll.id] = results;\r\n    }\r\n\r\n    if(!results.pFlags.min) { // ! https://core.telegram.org/constructor/pollResults - min\r\n      poll.chosenIndexes.length = 0;\r\n      if(results?.results?.length) {\r\n        results.results.forEach((answer, idx) => {\r\n          if(answer.pFlags?.chosen) {\r\n            poll.chosenIndexes.push(idx);\r\n          }\r\n        });\r\n      }\r\n    }\r\n\r\n    return results;\r\n  }\r\n\r\n  public getPoll(pollId: string): {poll: Poll, results: PollResults} {\r\n    return {\r\n      poll: this.polls[pollId], \r\n      results: this.results[pollId]\r\n    };\r\n  }\r\n\r\n  public getInputMediaPoll(poll: Poll, correctAnswers?: Uint8Array[], solution?: string, solutionEntities?: MessageEntity[]): InputMedia.inputMediaPoll {\r\n    if(solution) {\r\n      if(!solutionEntities) {\r\n        solutionEntities = [];\r\n      }\r\n\r\n      solution = RichTextProcessor.parseMarkdown(solution, solutionEntities);\r\n    } else {\r\n      solution = undefined; // can be string here\r\n    }\r\n\r\n    return {\r\n      _: 'inputMediaPoll',\r\n      poll,\r\n      correct_answers: correctAnswers,\r\n      solution,\r\n      solution_entities: solution ? solutionEntities : undefined\r\n    };\r\n  }\r\n\r\n  public updatePollToMessage(message: Message.message, add: boolean) {\r\n    const {id} = (message.media as MessageMedia.messageMediaPoll).poll;\r\n    let set = this.pollToMessages[id];\r\n    \r\n    if(!add && !set) {\r\n      return;\r\n    }\r\n\r\n    if(!set) {\r\n      set = this.pollToMessages[id] = new Set();\r\n    }\r\n\r\n    const key = message.peerId + '_' + message.mid;\r\n    if(add) set.add(key);\r\n    else set.delete(key);\r\n\r\n    if(!add && !set.size) {\r\n      delete this.polls[id];\r\n      delete this.results[id];\r\n      delete this.pollToMessages[id];\r\n    }\r\n  }\r\n\r\n  public sendVote(message: any, optionIds: number[]): Promise<void> {\r\n    const poll: Poll = message.media.poll;\r\n\r\n    const options: Uint8Array[] = optionIds.map(index => {\r\n      return poll.answers[index].option;\r\n    });\r\n    \r\n    const messageId = message.mid;\r\n    const peerId = message.peerId;\r\n    const inputPeer = appPeersManager.getInputPeerById(peerId);\r\n\r\n    if(message.pFlags.is_outgoing) {\r\n      return appMessagesManager.invokeAfterMessageIsSent(messageId, 'sendVote', (message) => {\r\n        this.log('invoke sendVote callback');\r\n        return this.sendVote(message, optionIds);\r\n      });\r\n    }\r\n\r\n    return apiManager.invokeApi('messages.sendVote', {\r\n      peer: inputPeer,\r\n      msg_id: appMessagesIdsManager.getServerMessageId(message.mid),\r\n      options\r\n    }).then(updates => {\r\n      this.log('sendVote updates:', updates);\r\n      apiUpdatesManager.processUpdateMessage(updates);\r\n    });\r\n  }\r\n\r\n  public getResults(message: any) {\r\n    const inputPeer = appPeersManager.getInputPeerById(message.peerId);\r\n\r\n    return apiManager.invokeApi('messages.getPollResults', {\r\n      peer: inputPeer,\r\n      msg_id: appMessagesIdsManager.getServerMessageId(message.mid)\r\n    }).then(updates => {\r\n      apiUpdatesManager.processUpdateMessage(updates);\r\n      this.log('getResults updates:', updates);\r\n    });\r\n  }\r\n\r\n  public getVotes(message: any, option?: Uint8Array, offset?: string, limit = 20) {\r\n    return apiManager.invokeApi('messages.getPollVotes', {\r\n      peer: appPeersManager.getInputPeerById(message.peerId),\r\n      id: appMessagesIdsManager.getServerMessageId(message.mid),\r\n      option,\r\n      offset,\r\n      limit\r\n    }).then((votesList) => {\r\n      this.log('getPollVotes messages:', votesList);\r\n\r\n      appUsersManager.saveApiUsers(votesList.users);\r\n\r\n      return votesList;\r\n    });\r\n  }\r\n\r\n  public stopPoll(message: any) {\r\n    const poll: Poll = message.media.poll;\r\n    \r\n    if(poll.pFlags.closed) return Promise.resolve();\r\n\r\n    const newPoll = copy(poll);\r\n    newPoll.pFlags.closed = true;\r\n    return appMessagesManager.editMessage(message, undefined, {\r\n      newMedia: this.getInputMediaPoll(newPoll)\r\n    }).then(() => {\r\n      //console.log('stopped poll');\r\n    }, err => {\r\n      this.log.error('stopPoll error:', err);\r\n    });\r\n  }\r\n}\r\n\r\nconst appPollsManager = new AppPollsManager();\r\nMOUNT_CLASS_TO.appPollsManager = appPollsManager;\r\nexport default appPollsManager;\r\n","import simulateEvent from \"../../../helpers/dom/dispatchEvent\";\r\n\r\nexport default function stopTrack(track: MediaStreamTrack) {\r\n  track.stop();\r\n  simulateEvent(track, 'ended');\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n * \r\n * Originally from:\r\n * https://github.com/evgeny-nadymov/telegram-react\r\n * Copyright (C) 2018 Evgeny Nadymov\r\n * https://github.com/evgeny-nadymov/telegram-react/blob/master/LICENSE\r\n */\r\n\r\nimport { logger } from '../logger';\r\nimport rootScope from '../rootScope';\r\nimport { GROUP_CALL_AMPLITUDE_ANALYSE_COUNT_MAX } from './constants';\r\nimport stopTrack from './helpers/stopTrack';\r\nimport LocalConferenceDescription from './localConferenceDescription';\r\nimport { fixMediaLineType, WebRTCLineType } from './sdpBuilder';\r\nimport { getAmplitude, toTelegramSource } from './utils';\r\n\r\nexport type StreamItemBase = {\r\n  type: 'input' | 'output',\r\n  track: MediaStreamTrack,\r\n  source: string,\r\n  stream: MediaStream\r\n};\r\n\r\nexport type StreamItem = StreamAudioItem | StreamVideoItem;\r\n\r\nexport type StreamAudioItem = StreamItemBase & {kind: 'audio', streamAnalyser: AudioStreamAnalyser};\r\nexport type StreamVideoItem = StreamItemBase & {kind: 'video'};\r\n\r\nexport type StreamAmplitude = {\r\n  type: \"input\" | \"output\";\r\n  source: string;\r\n  stream: MediaStream;\r\n  track: MediaStreamTrack;\r\n  value: number;\r\n};\r\n\r\nclass AudioStreamAnalyser {\r\n  public analyser: AnalyserNode;\r\n  public gain: GainNode;\r\n  public streamSource: MediaStreamAudioSourceNode;\r\n\r\n  constructor(context: AudioContext, stream: MediaStream) {\r\n    const streamSource = this.streamSource = context.createMediaStreamSource(stream);\r\n    const analyser = this.analyser = context.createAnalyser();\r\n    const gain = this.gain = context.createGain();\r\n    // const streamDestination = context.createMediaStreamDestination();\r\n    \r\n    analyser.minDecibels = -100;\r\n    analyser.maxDecibels = -30;\r\n    analyser.smoothingTimeConstant = 0.05;\r\n    analyser.fftSize = 1024;\r\n    \r\n    // connect Web Audio API\r\n    streamSource.connect(analyser);\r\n    // analyser.connect(context.destination);\r\n  }\r\n}\r\n\r\nexport default class StreamManager {\r\n  private context: AudioContext;\r\n  public outputStream: MediaStream;\r\n  public inputStream: MediaStream;\r\n\r\n  private timer: number;\r\n  private counter: number;\r\n\r\n  private items: StreamItem[];\r\n\r\n  private log: ReturnType<typeof logger>;\r\n\r\n  public direction: RTCRtpTransceiver['direction'];\r\n  public canCreateConferenceEntry: boolean;\r\n  public locked: boolean;\r\n  public types: WebRTCLineType[];\r\n  \r\n  constructor(private interval?: number) {\r\n    this.context = new (window.AudioContext || (window as any).webkitAudioContext)();\r\n    this.items = [];\r\n    this.outputStream = new MediaStream();\r\n    this.inputStream = new MediaStream();\r\n    this.counter = 0;\r\n    this.log = logger('SM');\r\n    this.direction = 'sendonly';\r\n    this.canCreateConferenceEntry = true;\r\n    // this.lol = true;\r\n    this.types = ['audio', 'video'];\r\n  }\r\n\r\n  public addStream(stream: MediaStream, type: StreamItem['type']) {\r\n    stream.getTracks().forEach(track => {\r\n      this.addTrack(stream, track, type);\r\n    });\r\n  }\r\n\r\n  public addTrack(stream: MediaStream, track: MediaStreamTrack, type: StreamItem['type']) {\r\n    this.log('addTrack', type, track, stream);\r\n\r\n    const {context, items, inputStream, outputStream} = this;\r\n    const kind: StreamItem['kind'] = track.kind as any;\r\n    const source = StreamManager.getSource(stream, type);\r\n    \r\n    // this.removeTrack(track);\r\n    switch(type) {\r\n      case 'input': {\r\n        if(!inputStream) {\r\n          this.inputStream = stream;\r\n        } else {\r\n          inputStream.addTrack(track);\r\n        }\r\n\r\n        break;\r\n      }\r\n\r\n      case 'output': {\r\n        for(let i = 0; i < items.length; ++i) {\r\n          const {track: t, type, source: itemSource} = items[i];\r\n          if(itemSource === source && type === 'input') {\r\n            items.splice(i, 1);\r\n            outputStream.removeTrack(t);\r\n            break;\r\n          }\r\n        }\r\n        \r\n        if(kind !== 'video') {\r\n          outputStream.addTrack(track);\r\n        }\r\n        \r\n        break;\r\n      }\r\n    }\r\n\r\n    this.finalizeAddingTrack({\r\n      type,\r\n      source,\r\n      stream,\r\n      track,\r\n      kind,\r\n      streamAnalyser: kind === 'audio' ? new AudioStreamAnalyser(context, stream) : undefined\r\n    });\r\n\r\n    if(kind === 'audio' && this.interval) {\r\n      this.changeTimer();\r\n    }\r\n  }\r\n\r\n  private finalizeAddingTrack(item: StreamItem) {\r\n    const {track} = item;\r\n    track.addEventListener('ended', () => {\r\n      this.removeTrack(track);\r\n    }, {once: true});\r\n\r\n    this.items.push(item);\r\n  }\r\n\r\n  public hasInputTrackKind(kind: StreamItem['kind']) {\r\n    return this.items.find(item => item.type === 'input' && item.kind === kind);\r\n  }\r\n\r\n  public static getSource(stream: MediaStream, type: StreamItem['type']) {\r\n    return type === 'input' ? (stream.source || stream.id) : '' + toTelegramSource(+stream.id.substring(6));\r\n  }\r\n  \r\n  public removeTrack(track: MediaStreamTrack) {\r\n    this.log('removeTrack', track);\r\n\r\n    const {items} = this;\r\n    \r\n    let handled = false;\r\n    for(let i = 0, length = items.length; !handled && i < length; ++i) {\r\n      const {track: t, type} = items[i];\r\n      switch(type) {\r\n        case 'output': {\r\n          if(t === track) {\r\n            items.splice(i, 1);\r\n            this.outputStream.removeTrack(track);\r\n            handled = true;\r\n          }\r\n\r\n          break;\r\n        }\r\n\r\n        case 'input': {\r\n          if(t === track) {\r\n            items.splice(i, 1);\r\n            this.inputStream.removeTrack(track);\r\n            handled = true;\r\n          }\r\n\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    \r\n    if(track.kind === 'audio' && this.interval) {\r\n      this.changeTimer();\r\n    }\r\n  }\r\n  \r\n  public replaceInputAudio(stream: MediaStream, oldTrack: MediaStreamTrack) {\r\n    this.removeTrack(oldTrack);\r\n    this.addStream(stream, 'input');\r\n  }\r\n  \r\n  private changeTimer() {\r\n    if(this.timer !== undefined) {\r\n      clearInterval(this.timer);\r\n    }\r\n    \r\n    if(this.items.length) {\r\n      this.timer = window.setInterval(this.analyse, this.interval);\r\n    }\r\n  }\r\n  \r\n  public getAmplitude = (item: StreamAudioItem): StreamAmplitude => {\r\n    const {streamAnalyser, stream, track, source, type} = item;\r\n    const analyser = streamAnalyser.analyser;\r\n    if(!analyser) return;\r\n    \r\n    const array = new Uint8Array(analyser.frequencyBinCount);\r\n    analyser.getByteFrequencyData(array);\r\n    const value = getAmplitude(array);\r\n    \r\n    return {\r\n      type,\r\n      source,\r\n      stream,\r\n      track,\r\n      value\r\n    };\r\n  };\r\n  \r\n  public analyse = () => {\r\n    const all = this.counter % 3 === 0;\r\n    const filteredItems = all ? this.items : this.items.filter(x => x.type === 'input');\r\n    const audioItems = filteredItems.filter(x => x.kind === 'audio') as StreamAudioItem[];\r\n    const amplitudes = audioItems.slice(0, GROUP_CALL_AMPLITUDE_ANALYSE_COUNT_MAX).map(this.getAmplitude);\r\n    if(++this.counter >= 1000) {\r\n      this.counter = 0;\r\n    }\r\n    \r\n    rootScope.dispatchEvent('group_call_amplitude', {\r\n      amplitudes,\r\n      type: all ? 'all' : 'input'\r\n    });\r\n  };\r\n\r\n  /* public appendToConnection(connection: RTCPeerConnection) {\r\n    if(this.inputStream) {\r\n      this.inputStream.getTracks().forEach(track => {\r\n        connection.log('addTrack', track);\r\n        connection.addTrack(track, this.inputStream);\r\n\r\n        if(track.kind === 'video') {\r\n          track.enabled = true;\r\n        }\r\n      });\r\n    }\r\n  } */\r\n\r\n  public appendToConference(conference: LocalConferenceDescription) {\r\n    if(this.locked) {\r\n      return;\r\n    }\r\n    \r\n    const {inputStream, direction, canCreateConferenceEntry} = this;\r\n    const transceiverInit: RTCRtpTransceiverInit = {direction, streams: [inputStream]};\r\n    const types = this.types.map(type => {\r\n      return [\r\n        type, \r\n        /* type === 'video' || type === 'screencast' ? \r\n          {sendEncodings: [{maxBitrate: 2500000}], ...transceiverInit} :  */\r\n          transceiverInit\r\n      ] as const;\r\n    });\r\n\r\n    const tracks = inputStream.getTracks();\r\n    // const transceivers = conference.connection.getTransceivers();\r\n    for(const [type, transceiverInit] of types) {\r\n      let entry = conference.findEntry(entry => entry.direction === direction && entry.type === type);\r\n      if(!entry) {\r\n        if(!canCreateConferenceEntry) {\r\n          continue;\r\n        }\r\n\r\n        entry = conference.createEntry(type);\r\n      }\r\n      /* const entry = conference.findFreeSendRecvEntry(type, true);\r\n      if(!entry.transceiver) {\r\n        entry.transceiver = transceivers.find(transceiver => transceiver.mid === entry.mid);\r\n      } */\r\n\r\n      let {transceiver} = entry;\r\n      if(!transceiver) {\r\n        transceiver = entry.createTransceiver(conference.connection, transceiverInit);\r\n\r\n        /* if(this.isScreenSharingManager) {\r\n          transceiver.sender.setParameters({\r\n            ...transceiver.sender.getParameters(),\r\n            degradationPreference: 'maintain-resolution'\r\n          });\r\n        } */\r\n      }\r\n\r\n      if(entry.direction !== transceiver.direction) {\r\n        transceiver.direction = entry.direction;\r\n      }\r\n\r\n      const mediaTrackType = fixMediaLineType(type);\r\n      const trackIdx = tracks.findIndex(track => track.kind === mediaTrackType);\r\n      const track = trackIdx !== -1 ? tracks.splice(trackIdx, 1)[0] : undefined;\r\n      const sender = transceiver.sender;\r\n      if(sender.track === track) {\r\n        continue;\r\n      }\r\n\r\n      // try { // ! don't use await here. it will wait for adding track and fake one won't be visible in startNegotiation.\r\n        /* await  */sender.replaceTrack(track).catch(err => {\r\n          this.log.error(err);\r\n        });\r\n      // } catch(err) {\r\n\r\n      // }\r\n    }\r\n  }\r\n\r\n  public stop() {\r\n    try {\r\n      const tracks = this.inputStream.getTracks().concat(this.outputStream.getTracks());\r\n      tracks.forEach(track => {\r\n        stopTrack(track);\r\n      });\r\n    } catch(e) {\r\n      this.log.error(e);\r\n    }\r\n  }\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n * \r\n * Originally from:\r\n * https://github.com/evgeny-nadymov/telegram-react\r\n * Copyright (C) 2018 Evgeny Nadymov\r\n * https://github.com/evgeny-nadymov/telegram-react/blob/master/LICENSE\r\n */\r\n\r\n/// NOTE: telegram returns sign source, while webrtc uses unsign source internally\r\n/// unsign => sign\r\nexport function toTelegramSource(source: number) {\r\n\treturn source << 0;\r\n}\r\n\r\n/// NOTE: telegram returns sign source, while webrtc uses unsign source internally\r\n/// sign => unsign\r\nexport function fromTelegramSource(source: number) {\r\n\treturn source >>> 0;\r\n}\r\n\r\nexport function getAmplitude(array: Uint8Array, scale = 3) {\r\n\tif(!array) return 0;\r\n\r\n\tconst {length} = array;\r\n\tlet total = 0;\r\n\tfor(let i = 0; i < length; ++i) {\r\n\t\ttotal += array[i] * array[i];\r\n\t}\r\n\tconst rms = Math.sqrt(total / length) / 255;\r\n\r\n\treturn Math.min(1, rms * scale);\r\n}\r\n","export default function getObjectKeysAndSort(object: {[key: string]: any}, sort: 'asc' | 'desc' = 'asc') {\r\n  if(!object) return [];\r\n  const ids = object instanceof Map ? [...object.keys()] : Object.keys(object).map(i => +i);\r\n  if(sort === 'asc') return ids.sort((a, b) => a - b);\r\n  else return ids.sort((a, b) => b - a);\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport { MOUNT_CLASS_TO } from \"../config/debug\";\r\nimport compareValue from \"./compareValue\";\r\n\r\n/**\r\n * Descend sorted storage\r\n */\r\n\r\ntype ItemType = number | string;\r\n\r\nexport enum SliceEnd {\r\n  None = 0,\r\n  Top = 1,\r\n  Bottom = 2,\r\n  Both = SliceEnd.Top | SliceEnd.Bottom\r\n};\r\n\r\nexport interface Slice<T extends ItemType> extends Array<T> {\r\n  //slicedArray: SlicedArray;\r\n  end: SliceEnd;\r\n\r\n  isEnd: (side: SliceEnd) => boolean;\r\n  setEnd: (side: SliceEnd) => void;\r\n  unsetEnd: (side: SliceEnd) => void;\r\n\r\n  slice: (from?: number, to?: number) => Slice<T>;\r\n  splice: (start: number, deleteCount: number, ...items: ItemType[]) => Slice<T>;\r\n}\r\n\r\nexport interface SliceConstructor<T extends ItemType> {\r\n  // new(...items: T[]): Slice<T>;\r\n  new(length: number): Slice<T>;\r\n}\r\n\r\nexport default class SlicedArray<T extends ItemType> {\r\n  private slices: Slice<T>[]/*  = [[7,6,5],[4,3,2],[1,0,-1]] */;\r\n  private sliceConstructor: SliceConstructor<T>;\r\n  \r\n  constructor() {\r\n    // @ts-ignore\r\n    this.sliceConstructor = SlicedArray.getSliceConstructor(this);\r\n\r\n    const first = this.constructSlice();\r\n    //first.setEnd(SliceEnd.Bottom);\r\n    this.slices = [first];\r\n  }\r\n\r\n  private static getSliceConstructor(slicedArray: SlicedArray<ItemType>) {\r\n    return class Slice<T> extends Array<ItemType> implements Slice<T> {\r\n      //slicedArray: SlicedArray;\r\n      end: SliceEnd = SliceEnd.None;\r\n  \r\n      /* constructor(...items: ItemType[]) {\r\n        super(...items);\r\n        //this.slicedArray = slicedArray;\r\n      } */\r\n  \r\n      isEnd(side: SliceEnd): boolean {\r\n        if((this.end & side) === side) {\r\n          return true;\r\n        }/*  else if(!this.slicedArray) {\r\n          return false;\r\n        } */\r\n  \r\n        let isEnd = false;\r\n        if(side === SliceEnd.Top) {\r\n          const slice = slicedArray.last;\r\n          isEnd = slice.end & side ? this.includes(slice[slice.length - 1])/*  || !slice.length */ : false;\r\n        } else if(side === SliceEnd.Bottom) {\r\n          const slice = slicedArray.first;\r\n          isEnd = slice.end & side ? this.includes(slice[0])/*  || !slice.length */ : false;\r\n        } else if(side === SliceEnd.Both) {\r\n          return this.isEnd(SliceEnd.Top) && this.isEnd(SliceEnd.Bottom);\r\n        }\r\n\r\n        if(isEnd) {\r\n          this.setEnd(side);\r\n        }\r\n  \r\n        return isEnd;\r\n      }\r\n  \r\n      setEnd(side: SliceEnd) {\r\n        this.end |= side;\r\n      }\r\n\r\n      unsetEnd(side: SliceEnd) {\r\n        this.end &= ~side;\r\n      }\r\n\r\n      splice(start: number, deleteCount: number, ...items: ItemType[]) {\r\n        const ret = super.splice(start, deleteCount, ...items);\r\n\r\n        if(!this.length) {\r\n          const slices = slicedArray.slices as ItemType[][];\r\n          const idx = slices.indexOf(this);\r\n          if(idx !== -1) {\r\n            if(slices.length === 1) { // left empty slice without ends\r\n              this.unsetEnd(SliceEnd.Both);\r\n            } else { // delete this slice\r\n              slices.splice(idx, 1);\r\n            }\r\n          }\r\n        }\r\n\r\n        return ret;\r\n      }\r\n    }\r\n  }\r\n\r\n  public constructSlice(...items: T[]) {\r\n    //const slice = new Slice(this, ...items);\r\n    // can't pass items directly to constructor because first argument is length\r\n    const slice = new this.sliceConstructor(items.length);\r\n    for(let i = 0, length = items.length; i < length; ++i) {\r\n      slice[i] = items[i];\r\n    }\r\n    return slice;\r\n    \r\n    // ! code below will slow execution in 15 times\r\n    /* const self = this;\r\n    const p: Slice = new Proxy(slice, {\r\n      get: function(target, name: any) {\r\n        if(name === 'constructor') {\r\n          const p = new Proxy(Slice, {\r\n            construct: (target, args) => {\r\n              return self.constructSlice(...args);\r\n            }\r\n          });\r\n\r\n          return p;\r\n        }\r\n\r\n        return target[name];\r\n      }\r\n    });\r\n\r\n    return p; */\r\n\r\n    /*\r\n    var p = slicedArray.constructSlice();\r\n    p.length = 100000;\r\n    p.fill(255);\r\n\r\n    var a = new Array(100000);\r\n    a.fill(255);\r\n\r\n    var b = 0;\r\n    var perf = performance.now();\r\n    for(var i = 0; i < p.length; ++i) {\r\n        b += p[i];\r\n    }\r\n\r\n    console.log('perf 1', performance.now() - perf);\r\n\r\n    b = 0;\r\n    perf = performance.now();\r\n    for(var i = 0; i < a.length; ++i) {\r\n        b += a[i];\r\n    }\r\n\r\n    console.log('perf 2', performance.now() - perf);\r\n    */\r\n  }\r\n\r\n  public insertSlice(slice: T[], flatten = true) {\r\n    if(!slice.length) {\r\n      return;\r\n    }\r\n\r\n    const first = this.slices[0];\r\n    if(!first.length) {\r\n      first.push(...slice);\r\n      return first;\r\n    }\r\n\r\n    const lowerBound = slice[slice.length - 1];\r\n    const upperBound = slice[0];\r\n\r\n    let foundSlice: Slice<T>, lowerIndex = -1, upperIndex = -1, foundSliceIndex = 0;\r\n    for(; foundSliceIndex < this.slices.length; ++foundSliceIndex) {\r\n      foundSlice = this.slices[foundSliceIndex];\r\n      lowerIndex = foundSlice.indexOf(lowerBound);\r\n      upperIndex = foundSlice.indexOf(upperBound);\r\n      \r\n      if(upperIndex !== -1 && -1 !== lowerIndex) {\r\n        break;\r\n      } else if(upperIndex !== -1 || -1 !== lowerIndex) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    if(upperIndex !== -1 && -1 !== lowerIndex) {\r\n\r\n    } else if(upperIndex !== -1) {  // ([1, 2, 3] | [1, 2, 3, 4, 5]) -> [1, 2, 3, 4, 5]\r\n      const sliced = slice.slice(foundSlice.length - upperIndex);\r\n      foundSlice.push(...sliced);\r\n    } else if(lowerIndex !== -1) {  // ([1, 2, 3] | [-1, 0, 1]) -> [-1, 0, 1, 2, 3]\r\n      const sliced = slice.slice(0, slice.length - lowerIndex - 1);\r\n      foundSlice.unshift(...sliced);\r\n    } else {\r\n      let insertIndex = 0;\r\n      for(const length = this.slices.length; insertIndex < length; ++insertIndex) { // * maybe should iterate from the end, could be faster ?\r\n        const s = this.slices[insertIndex];\r\n        if(compareValue(slice[0], s[0]) === 1) {\r\n          break;\r\n        }\r\n      }\r\n\r\n      this.slices.splice(insertIndex, 0, this.constructSlice(...slice));\r\n      foundSliceIndex = insertIndex;\r\n    }\r\n\r\n    if(flatten) {\r\n      return this.flatten(foundSliceIndex);\r\n    }\r\n  }\r\n\r\n  private flatten(foundSliceIndex: number) {\r\n    if(this.slices.length >= 2) {\r\n      for(let i = 0, length = this.slices.length; i < (length - 1); ++i) {\r\n        const prevSlice = this.slices[i];\r\n        const nextSlice = this.slices[i + 1];\r\n  \r\n        const upperIndex = prevSlice.indexOf(nextSlice[0]);\r\n        if(upperIndex !== -1) {\r\n          prevSlice.setEnd(nextSlice.end);\r\n          this.slices.splice(i + 1, 1);\r\n\r\n          if(i < foundSliceIndex) {\r\n            --foundSliceIndex;\r\n          }\r\n\r\n          --length; // respect array bounds\r\n          --i;      // repeat from the same place\r\n  \r\n          this.insertSlice(nextSlice, false);\r\n        }\r\n      }\r\n    }\r\n\r\n    return this.slices[foundSliceIndex];\r\n  }\r\n\r\n  // * \r\n  \r\n  get first() {\r\n    return this.slices[0];\r\n  }\r\n  \r\n  get last() {\r\n    return this.slices[this.slices.length - 1];\r\n  }\r\n\r\n  get slice() {\r\n    return this.first;\r\n  }\r\n\r\n  get length() {\r\n    return this.slice.length;\r\n  }\r\n\r\n  public findSlice(item: T) {\r\n    for(let i = 0, length = this.slices.length; i < length; ++i) {\r\n      const slice = this.slices[i];\r\n      const index = slice.indexOf(item);\r\n      if(index !== -1) {\r\n        return {slice, index};\r\n      }\r\n    }\r\n    \r\n    return undefined;\r\n  }\r\n\r\n  public findSliceOffset(maxId: T) {\r\n    let slice: Slice<T>;\r\n    for(let i = 0; i < this.slices.length; ++i) {\r\n      let offset = 0;\r\n      slice = this.slices[i];\r\n      if(slice.length < 2) {\r\n        continue;\r\n      }\r\n      \r\n      for(; offset < slice.length; ++offset) {\r\n        if(compareValue(maxId, slice[offset]) >= 0) {\r\n          /* if(!offset) { // because can't find 3 in [[5,4], [2,1]]\r\n            return undefined;\r\n          } */\r\n\r\n          return {\r\n            slice, \r\n            offset: maxId === slice[offset] ? offset : offset - 1\r\n          };\r\n        }\r\n      }\r\n    }\r\n\r\n    if(slice && slice.isEnd(SliceEnd.Top)) {\r\n      return {\r\n        slice,\r\n        offset: slice.length\r\n      };\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  // * https://core.telegram.org/api/offsets\r\n  public sliceMe(offsetId: T, add_offset: number, limit: number) {\r\n    let slice = this.slice;\r\n    let offset = 0;\r\n    let sliceOffset = 0;\r\n\r\n    if(offsetId) {\r\n      const pos = this.findSliceOffset(offsetId);\r\n      if(!pos) {\r\n        return undefined;\r\n      }\r\n\r\n      slice = pos.slice;\r\n      offset = sliceOffset = pos.offset;\r\n\r\n      if(slice.includes(offsetId)) {\r\n        sliceOffset += 1;\r\n      }\r\n\r\n      /* if(slice.includes(offsetId) && add_offset < 0) {\r\n        add_offset += 1;\r\n      } */\r\n    }\r\n\r\n    let sliceStart = Math.max(sliceOffset + add_offset, 0);\r\n    let sliceEnd = sliceOffset + add_offset + limit;\r\n    //const fixHalfBackLimit = add_offset && !(limit / add_offset % 2) && (sliceEnd % 2) ? 1 : 0;\r\n    //sliceEnd += fixHalfBackLimit;\r\n\r\n    const sliced = slice.slice(sliceStart, sliceEnd) as Slice<T>;\r\n\r\n    const topWasMeantToLoad = add_offset < 0 ? limit + add_offset : limit;\r\n    const bottomWasMeantToLoad = Math.abs(add_offset);\r\n\r\n    // can use 'slice' here to check because if it's end, then 'sliced' is out of 'slice'\r\n    // useful when there is only 1 message in chat on its reopening\r\n    const topFulfilled = (slice.length - sliceOffset) >= topWasMeantToLoad || (slice.isEnd(SliceEnd.Top) ? (sliced.setEnd(SliceEnd.Top), true) : false);\r\n    const bottomFulfilled = (sliceOffset - bottomWasMeantToLoad) >= 0 || (slice.isEnd(SliceEnd.Bottom) ? (sliced.setEnd(SliceEnd.Bottom), true) : false);\r\n\r\n    //console.log('sliceMe', topFulfilled, bottomFulfilled);\r\n\r\n    return {\r\n      slice: sliced, \r\n      offsetIdOffset: offset,\r\n      fulfilled: SliceEnd.None | (topFulfilled && bottomFulfilled ? SliceEnd.Both : ((topFulfilled ? SliceEnd.Top : SliceEnd.None) | (bottomFulfilled ? SliceEnd.Bottom : SliceEnd.None)))\r\n    };\r\n  }\r\n\r\n  public unshift(...items: T[]) {\r\n    let slice = this.first;\r\n    if(!slice.length) {\r\n      slice.setEnd(SliceEnd.Bottom);\r\n    } else if(!slice.isEnd(SliceEnd.Bottom)) {\r\n      slice = this.constructSlice();\r\n      slice.setEnd(SliceEnd.Bottom);\r\n      this.slices.unshift(slice);\r\n    }\r\n\r\n    slice.unshift(...items);\r\n  }\r\n\r\n  public push(...items: T[]) {\r\n    let slice = this.last;\r\n    if(!slice.length) {\r\n      slice.setEnd(SliceEnd.Top);\r\n    } else if(!slice.isEnd(SliceEnd.Top)) {\r\n      slice = this.constructSlice();\r\n      slice.setEnd(SliceEnd.Top);\r\n      this.slices.push(slice);\r\n    }\r\n\r\n    slice.push(...items);\r\n  }\r\n\r\n  public delete(item: T) {\r\n    const found = this.findSlice(item);\r\n    if(found) {\r\n      found.slice.splice(found.index, 1);\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n}\r\n\r\nMOUNT_CLASS_TO && (MOUNT_CLASS_TO.SlicedArray = SlicedArray);\r\n","import compareLong from \"./long/compareLong\";\r\n\r\nexport default function compareValue(val1: string | number, val2: typeof val1) {\r\n  if((val1 as number).toExponential) {\r\n    const diff = (val1 as number) - (val2 as number);\r\n    return diff < 0 ? -1 : (diff > 0 ? 1 : 0);\r\n  }\r\n\r\n  return compareLong(val1 as string, val2 as string);\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nexport default function compareLong(str1: string, str2: string) {\r\n  const str1Length = str1.length;\r\n  if(str1Length !== str2.length) {\r\n    const diff = str1Length - str2.length;\r\n    return diff < 0 ? -1 : (diff > 0 ? 1 : 0);\r\n  }\r\n\r\n  const maxPartLength = 15;\r\n  for(let i = 0; i < str1Length; i += maxPartLength) {\r\n    const v1 = +str1.slice(i, i + maxPartLength);\r\n    const v2 = +str2.slice(i, i + maxPartLength);\r\n    const diff = v1 - v2;\r\n    if(diff) {\r\n      return diff;\r\n    }\r\n  }\r\n\r\n  return 0;\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport deferredPromise, { CancellablePromise } from \"./cancellablePromise\";\r\nimport { getHeavyAnimationPromise } from \"../hooks/useHeavyAnimationCheck\";\r\nimport { fastRaf } from \"./schedulers\";\r\nimport { ArgumentTypes } from \"../types\";\r\n\r\ntype HeavyQueue<T extends HeavyQueue<any>> = {\r\n  items: ArgumentTypes<T['process']>[], \r\n  process: (...args: any[]) => ReturnType<T['process']>,\r\n  context: any,\r\n  promise?: CancellablePromise<ReturnType<T['process']>[]>\r\n};\r\nconst heavyQueue: HeavyQueue<any>[] = [];\r\nlet processingQueue = false;\r\n\r\nexport default function addHeavyTask<T extends HeavyQueue<T>>(queue: T, method: 'push' | 'unshift' = 'push') {\r\n  if(!queue.items.length) {\r\n    return Promise.resolve([]) as typeof promise;\r\n  }\r\n  \r\n  const promise = queue.promise = deferredPromise();\r\n  heavyQueue[method](queue);\r\n  processHeavyQueue();\r\n\r\n  return promise;\r\n}\r\n\r\nfunction processHeavyQueue() {\r\n  if(!processingQueue) {\r\n    const queue = heavyQueue.shift();\r\n    timedChunk(queue).finally(() => {\r\n      processingQueue = false;\r\n      if(heavyQueue.length) {\r\n        processHeavyQueue();\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction timedChunk<T extends HeavyQueue<T>>(queue: HeavyQueue<T>) {\r\n  if(!queue.items.length) {\r\n    queue.promise.resolve([] as any);\r\n    return Promise.resolve([]);\r\n  }\r\n\r\n  const todo = queue.items.slice();\r\n  const results: ReturnType<T['process']>[] = [];\r\n\r\n  return new Promise<typeof results>((resolve, reject) => {\r\n    const f = async() => {\r\n      const start = performance.now();\r\n\r\n      do {\r\n        await getHeavyAnimationPromise();\r\n        const possiblePromise = queue.process.apply(queue.context, todo.shift());\r\n        let realResult: typeof results[0];\r\n        // @ts-ignore\r\n        if(possiblePromise instanceof Promise) {\r\n          try {\r\n            realResult = await possiblePromise;\r\n          } catch(err) {\r\n            reject(err);\r\n            return;\r\n          }\r\n        } else {\r\n          realResult = possiblePromise;\r\n        }\r\n\r\n        results.push(realResult);\r\n      } while(todo.length > 0 && (performance.now() - start) < 6);\r\n\r\n      if(todo.length > 0) {\r\n        fastRaf(f);\r\n        //setTimeout(f, 25);\r\n      } else {\r\n        resolve(results);\r\n      }\r\n    };\r\n\r\n    fastRaf(f);\r\n    //setTimeout(f, 25);\r\n  }).then(queue.promise.resolve, queue.promise.reject);\r\n}","const IS_CANVAS_FILTER_SUPPORTED = 'filter' in (document.createElement('canvas').getContext('2d') || {});\r\n\r\nexport default IS_CANVAS_FILTER_SUPPORTED;","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport type fastBlur from '../vendor/fastBlur';\r\nimport addHeavyTask from './heavyQueue';\r\nimport IS_CANVAS_FILTER_SUPPORTED from '../environment/canvasFilterSupport';\r\n\r\nconst RADIUS = 2;\r\nconst ITERATIONS = 2;\r\n\r\nlet requireBlurPromise: Promise<any>;\r\nlet fastBlurFunc: typeof fastBlur;\r\nif(!IS_CANVAS_FILTER_SUPPORTED) {\r\n  requireBlurPromise = import('../vendor/fastBlur').then(m => {\r\n    fastBlurFunc = m.default;\r\n  });\r\n} else {\r\n  requireBlurPromise = Promise.resolve();\r\n}\r\n\r\nfunction processBlurNext(\r\n  img: HTMLImageElement, \r\n  radius: number, \r\n  iterations: number, \r\n  canvas: HTMLCanvasElement = document.createElement('canvas')\r\n) {\r\n  canvas.width = img.width;\r\n  canvas.height = img.height;\r\n\r\n  const ctx = canvas.getContext('2d', {alpha: false});\r\n  if(IS_CANVAS_FILTER_SUPPORTED) {\r\n    ctx.filter = `blur(${radius}px)`;\r\n    ctx.drawImage(img, -radius * 2, -radius * 2, canvas.width + radius * 4, canvas.height + radius * 4);\r\n  } else {\r\n    ctx.drawImage(img, 0, 0);\r\n    fastBlurFunc(ctx, 0, 0, canvas.width, canvas.height, radius, iterations);\r\n  }\r\n\r\n  return canvas;\r\n}\r\n\r\ntype CacheValue = {canvas: HTMLCanvasElement, promise: Promise<void>};\r\nconst cache: Map<string, CacheValue> = new Map();\r\nconst CACHE_SIZE = 150;\r\n\r\nexport default function blur(dataUri: string, radius: number = RADIUS, iterations: number = ITERATIONS) {\r\n  if(!dataUri) {\r\n    throw 'no dataUri for blur: ' + dataUri;\r\n  }\r\n\r\n  if(cache.size > CACHE_SIZE) {\r\n    cache.clear();\r\n  }\r\n\r\n  const canvas = document.createElement('canvas');\r\n  canvas.className = 'canvas-thumbnail';\r\n  \r\n  let cached = cache.get(dataUri);\r\n  if(!cached) {\r\n    const promise: CacheValue['promise'] = new Promise((resolve) => {\r\n      //return resolve(dataUri);\r\n      requireBlurPromise.then(() => {\r\n        const img = new Image();\r\n        img.onload = () => {\r\n          // if(IS_CANVAS_FILTER_SUPPORTED) {\r\n            // resolve(processBlurNext(img, radius, iterations));\r\n          // } else {\r\n            const promise = addHeavyTask({\r\n              items: [[img, radius, iterations, canvas]],\r\n              context: null,\r\n              process: processBlurNext\r\n            }, 'unshift');\r\n            \r\n            promise.then(() => {\r\n              resolve();\r\n            });\r\n          // }\r\n        };\r\n        img.src = dataUri;\r\n      });\r\n    });\r\n  \r\n    cache.set(dataUri, cached = {\r\n      canvas,\r\n      promise\r\n    });\r\n  } else {\r\n    canvas.width = cached.canvas.width;\r\n    canvas.height = cached.canvas.height;\r\n    cached.promise.then(() => {\r\n      canvas.getContext('2d').drawImage(cached.canvas, 0, 0, canvas.width, canvas.height);\r\n    });\r\n  }\r\n\r\n  return {\r\n    ...cached,\r\n    canvas\r\n  };\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n * \r\n * Originally from:\r\n * https://github.com/zhukov/webogram\r\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\r\n * https://github.com/zhukov/webogram/blob/master/LICENSE\r\n */\r\n\r\n// From https://raw.githubusercontent.com/FGRibreau/latenize/master/latinize_map.js\r\nconst LatinizeMap: {[k: string]: string} = {'Á': 'A','Ă': 'A','Ắ': 'A','Ặ': 'A','Ằ': 'A','Ẳ': 'A','Ẵ': 'A','Ǎ': 'A','Â': 'A','Ấ': 'A','Ậ': 'A','Ầ': 'A','Ẩ': 'A','Ẫ': 'A','Ä': 'A','Ǟ': 'A','Ȧ': 'A','Ǡ': 'A','Ạ': 'A','Ȁ': 'A','À': 'A','Ả': 'A','Ȃ': 'A','Ā': 'A','Ą': 'A','Å': 'A','Ǻ': 'A','Ḁ': 'A','Ⱥ': 'A','Ã': 'A','Ꜳ': 'AA','Æ': 'AE','Ǽ': 'AE','Ǣ': 'AE','Ꜵ': 'AO','Ꜷ': 'AU','Ꜹ': 'AV','Ꜻ': 'AV','Ꜽ': 'AY','Ḃ': 'B','Ḅ': 'B','Ɓ': 'B','Ḇ': 'B','Ƀ': 'B','Ƃ': 'B','Ć': 'C','Č': 'C','Ç': 'C','Ḉ': 'C','Ĉ': 'C','Ċ': 'C','Ƈ': 'C','Ȼ': 'C','Ď': 'D','Ḑ': 'D','Ḓ': 'D','Ḋ': 'D','Ḍ': 'D','Ɗ': 'D','Ḏ': 'D','ǲ': 'D','ǅ': 'D','Đ': 'D','Ƌ': 'D','Ǳ': 'DZ','Ǆ': 'DZ','É': 'E','Ĕ': 'E','Ě': 'E','Ȩ': 'E','Ḝ': 'E','Ê': 'E','Ế': 'E','Ệ': 'E','Ề': 'E','Ể': 'E','Ễ': 'E','Ḙ': 'E','Ë': 'E','Ė': 'E','Ẹ': 'E','Ȅ': 'E','È': 'E','Ẻ': 'E','Ȇ': 'E','Ē': 'E','Ḗ': 'E','Ḕ': 'E','Ę': 'E','Ɇ': 'E','Ẽ': 'E','Ḛ': 'E','Ꝫ': 'ET','Ḟ': 'F','Ƒ': 'F','Ǵ': 'G','Ğ': 'G','Ǧ': 'G','Ģ': 'G','Ĝ': 'G','Ġ': 'G','Ɠ': 'G','Ḡ': 'G','Ǥ': 'G','Ḫ': 'H','Ȟ': 'H','Ḩ': 'H','Ĥ': 'H','Ⱨ': 'H','Ḧ': 'H','Ḣ': 'H','Ḥ': 'H','Ħ': 'H','Í': 'I','Ĭ': 'I','Ǐ': 'I','Î': 'I','Ï': 'I','Ḯ': 'I','İ': 'I','Ị': 'I','Ȉ': 'I','Ì': 'I','Ỉ': 'I','Ȋ': 'I','Ī': 'I','Į': 'I','Ɨ': 'I','Ĩ': 'I','Ḭ': 'I','Ꝺ': 'D','Ꝼ': 'F','Ᵹ': 'G','Ꞃ': 'R','Ꞅ': 'S','Ꞇ': 'T','Ꝭ': 'IS','Ĵ': 'J','Ɉ': 'J','Ḱ': 'K','Ǩ': 'K','Ķ': 'K','Ⱪ': 'K','Ꝃ': 'K','Ḳ': 'K','Ƙ': 'K','Ḵ': 'K','Ꝁ': 'K','Ꝅ': 'K','Ĺ': 'L','Ƚ': 'L','Ľ': 'L','Ļ': 'L','Ḽ': 'L','Ḷ': 'L','Ḹ': 'L','Ⱡ': 'L','Ꝉ': 'L','Ḻ': 'L','Ŀ': 'L','Ɫ': 'L','ǈ': 'L','Ł': 'L','Ǉ': 'LJ','Ḿ': 'M','Ṁ': 'M','Ṃ': 'M','Ɱ': 'M','Ń': 'N','Ň': 'N','Ņ': 'N','Ṋ': 'N','Ṅ': 'N','Ṇ': 'N','Ǹ': 'N','Ɲ': 'N','Ṉ': 'N','Ƞ': 'N','ǋ': 'N','Ñ': 'N','Ǌ': 'NJ','Ó': 'O','Ŏ': 'O','Ǒ': 'O','Ô': 'O','Ố': 'O','Ộ': 'O','Ồ': 'O','Ổ': 'O','Ỗ': 'O','Ö': 'O','Ȫ': 'O','Ȯ': 'O','Ȱ': 'O','Ọ': 'O','Ő': 'O','Ȍ': 'O','Ò': 'O','Ỏ': 'O','Ơ': 'O','Ớ': 'O','Ợ': 'O','Ờ': 'O','Ở': 'O','Ỡ': 'O','Ȏ': 'O','Ꝋ': 'O','Ꝍ': 'O','Ō': 'O','Ṓ': 'O','Ṑ': 'O','Ɵ': 'O','Ǫ': 'O','Ǭ': 'O','Ø': 'O','Ǿ': 'O','Õ': 'O','Ṍ': 'O','Ṏ': 'O','Ȭ': 'O','Ƣ': 'OI','Ꝏ': 'OO','Ɛ': 'E','Ɔ': 'O','Ȣ': 'OU','Ṕ': 'P','Ṗ': 'P','Ꝓ': 'P','Ƥ': 'P','Ꝕ': 'P','Ᵽ': 'P','Ꝑ': 'P','Ꝙ': 'Q','Ꝗ': 'Q','Ŕ': 'R','Ř': 'R','Ŗ': 'R','Ṙ': 'R','Ṛ': 'R','Ṝ': 'R','Ȑ': 'R','Ȓ': 'R','Ṟ': 'R','Ɍ': 'R','Ɽ': 'R','Ꜿ': 'C','Ǝ': 'E','Ś': 'S','Ṥ': 'S','Š': 'S','Ṧ': 'S','Ş': 'S','Ŝ': 'S','Ș': 'S','Ṡ': 'S','Ṣ': 'S','Ṩ': 'S','ẞ': 'SS','Ť': 'T','Ţ': 'T','Ṱ': 'T','Ț': 'T','Ⱦ': 'T','Ṫ': 'T','Ṭ': 'T','Ƭ': 'T','Ṯ': 'T','Ʈ': 'T','Ŧ': 'T','Ɐ': 'A','Ꞁ': 'L','Ɯ': 'M','Ʌ': 'V','Ꜩ': 'TZ','Ú': 'U','Ŭ': 'U','Ǔ': 'U','Û': 'U','Ṷ': 'U','Ü': 'U','Ǘ': 'U','Ǚ': 'U','Ǜ': 'U','Ǖ': 'U','Ṳ': 'U','Ụ': 'U','Ű': 'U','Ȕ': 'U','Ù': 'U','Ủ': 'U','Ư': 'U','Ứ': 'U','Ự': 'U','Ừ': 'U','Ử': 'U','Ữ': 'U','Ȗ': 'U','Ū': 'U','Ṻ': 'U','Ų': 'U','Ů': 'U','Ũ': 'U','Ṹ': 'U','Ṵ': 'U','Ꝟ': 'V','Ṿ': 'V','Ʋ': 'V','Ṽ': 'V','Ꝡ': 'VY','Ẃ': 'W','Ŵ': 'W','Ẅ': 'W','Ẇ': 'W','Ẉ': 'W','Ẁ': 'W','Ⱳ': 'W','Ẍ': 'X','Ẋ': 'X','Ý': 'Y','Ŷ': 'Y','Ÿ': 'Y','Ẏ': 'Y','Ỵ': 'Y','Ỳ': 'Y','Ƴ': 'Y','Ỷ': 'Y','Ỿ': 'Y','Ȳ': 'Y','Ɏ': 'Y','Ỹ': 'Y','Ź': 'Z','Ž': 'Z','Ẑ': 'Z','Ⱬ': 'Z','Ż': 'Z','Ẓ': 'Z','Ȥ': 'Z','Ẕ': 'Z','Ƶ': 'Z','Ĳ': 'IJ','Œ': 'OE','ᴀ': 'A','ᴁ': 'AE','ʙ': 'B','ᴃ': 'B','ᴄ': 'C','ᴅ': 'D','ᴇ': 'E','ꜰ': 'F','ɢ': 'G','ʛ': 'G','ʜ': 'H','ɪ': 'I','ʁ': 'R','ᴊ': 'J','ᴋ': 'K','ʟ': 'L','ᴌ': 'L','ᴍ': 'M','ɴ': 'N','ᴏ': 'O','ɶ': 'OE','ᴐ': 'O','ᴕ': 'OU','ᴘ': 'P','ʀ': 'R','ᴎ': 'N','ᴙ': 'R','ꜱ': 'S','ᴛ': 'T','ⱻ': 'E','ᴚ': 'R','ᴜ': 'U','ᴠ': 'V','ᴡ': 'W','ʏ': 'Y','ᴢ': 'Z','á': 'a','ă': 'a','ắ': 'a','ặ': 'a','ằ': 'a','ẳ': 'a','ẵ': 'a','ǎ': 'a','â': 'a','ấ': 'a','ậ': 'a','ầ': 'a','ẩ': 'a','ẫ': 'a','ä': 'a','ǟ': 'a','ȧ': 'a','ǡ': 'a','ạ': 'a','ȁ': 'a','à': 'a','ả': 'a','ȃ': 'a','ā': 'a','ą': 'a','ᶏ': 'a','ẚ': 'a','å': 'a','ǻ': 'a','ḁ': 'a','ⱥ': 'a','ã': 'a','ꜳ': 'aa','æ': 'ae','ǽ': 'ae','ǣ': 'ae','ꜵ': 'ao','ꜷ': 'au','ꜹ': 'av','ꜻ': 'av','ꜽ': 'ay','ḃ': 'b','ḅ': 'b','ɓ': 'b','ḇ': 'b','ᵬ': 'b','ᶀ': 'b','ƀ': 'b','ƃ': 'b','ɵ': 'o','ć': 'c','č': 'c','ç': 'c','ḉ': 'c','ĉ': 'c','ɕ': 'c','ċ': 'c','ƈ': 'c','ȼ': 'c','ď': 'd','ḑ': 'd','ḓ': 'd','ȡ': 'd','ḋ': 'd','ḍ': 'd','ɗ': 'd','ᶑ': 'd','ḏ': 'd','ᵭ': 'd','ᶁ': 'd','đ': 'd','ɖ': 'd','ƌ': 'd','ı': 'i','ȷ': 'j','ɟ': 'j','ʄ': 'j','ǳ': 'dz','ǆ': 'dz','é': 'e','ĕ': 'e','ě': 'e','ȩ': 'e','ḝ': 'e','ê': 'e','ế': 'e','ệ': 'e','ề': 'e','ể': 'e','ễ': 'e','ḙ': 'e','ë': 'e','ė': 'e','ẹ': 'e','ȅ': 'e','è': 'e','ẻ': 'e','ȇ': 'e','ē': 'e','ḗ': 'e','ḕ': 'e','ⱸ': 'e','ę': 'e','ᶒ': 'e','ɇ': 'e','ẽ': 'e','ḛ': 'e','ꝫ': 'et','ḟ': 'f','ƒ': 'f','ᵮ': 'f','ᶂ': 'f','ǵ': 'g','ğ': 'g','ǧ': 'g','ģ': 'g','ĝ': 'g','ġ': 'g','ɠ': 'g','ḡ': 'g','ᶃ': 'g','ǥ': 'g','ḫ': 'h','ȟ': 'h','ḩ': 'h','ĥ': 'h','ⱨ': 'h','ḧ': 'h','ḣ': 'h','ḥ': 'h','ɦ': 'h','ẖ': 'h','ħ': 'h','ƕ': 'hv','í': 'i','ĭ': 'i','ǐ': 'i','î': 'i','ï': 'i','ḯ': 'i','ị': 'i','ȉ': 'i','ì': 'i','ỉ': 'i','ȋ': 'i','ī': 'i','į': 'i','ᶖ': 'i','ɨ': 'i','ĩ': 'i','ḭ': 'i','ꝺ': 'd','ꝼ': 'f','ᵹ': 'g','ꞃ': 'r','ꞅ': 's','ꞇ': 't','ꝭ': 'is','ǰ': 'j','ĵ': 'j','ʝ': 'j','ɉ': 'j','ḱ': 'k','ǩ': 'k','ķ': 'k','ⱪ': 'k','ꝃ': 'k','ḳ': 'k','ƙ': 'k','ḵ': 'k','ᶄ': 'k','ꝁ': 'k','ꝅ': 'k','ĺ': 'l','ƚ': 'l','ɬ': 'l','ľ': 'l','ļ': 'l','ḽ': 'l','ȴ': 'l','ḷ': 'l','ḹ': 'l','ⱡ': 'l','ꝉ': 'l','ḻ': 'l','ŀ': 'l','ɫ': 'l','ᶅ': 'l','ɭ': 'l','ł': 'l','ǉ': 'lj','ſ': 's','ẜ': 's','ẛ': 's','ẝ': 's','ḿ': 'm','ṁ': 'm','ṃ': 'm','ɱ': 'm','ᵯ': 'm','ᶆ': 'm','ń': 'n','ň': 'n','ņ': 'n','ṋ': 'n','ȵ': 'n','ṅ': 'n','ṇ': 'n','ǹ': 'n','ɲ': 'n','ṉ': 'n','ƞ': 'n','ᵰ': 'n','ᶇ': 'n','ɳ': 'n','ñ': 'n','ǌ': 'nj','ó': 'o','ŏ': 'o','ǒ': 'o','ô': 'o','ố': 'o','ộ': 'o','ồ': 'o','ổ': 'o','ỗ': 'o','ö': 'o','ȫ': 'o','ȯ': 'o','ȱ': 'o','ọ': 'o','ő': 'o','ȍ': 'o','ò': 'o','ỏ': 'o','ơ': 'o','ớ': 'o','ợ': 'o','ờ': 'o','ở': 'o','ỡ': 'o','ȏ': 'o','ꝋ': 'o','ꝍ': 'o','ⱺ': 'o','ō': 'o','ṓ': 'o','ṑ': 'o','ǫ': 'o','ǭ': 'o','ø': 'o','ǿ': 'o','õ': 'o','ṍ': 'o','ṏ': 'o','ȭ': 'o','ƣ': 'oi','ꝏ': 'oo','ɛ': 'e','ᶓ': 'e','ɔ': 'o','ᶗ': 'o','ȣ': 'ou','ṕ': 'p','ṗ': 'p','ꝓ': 'p','ƥ': 'p','ᵱ': 'p','ᶈ': 'p','ꝕ': 'p','ᵽ': 'p','ꝑ': 'p','ꝙ': 'q','ʠ': 'q','ɋ': 'q','ꝗ': 'q','ŕ': 'r','ř': 'r','ŗ': 'r','ṙ': 'r','ṛ': 'r','ṝ': 'r','ȑ': 'r','ɾ': 'r','ᵳ': 'r','ȓ': 'r','ṟ': 'r','ɼ': 'r','ᵲ': 'r','ᶉ': 'r','ɍ': 'r','ɽ': 'r','ↄ': 'c','ꜿ': 'c','ɘ': 'e','ɿ': 'r','ś': 's','ṥ': 's','š': 's','ṧ': 's','ş': 's','ŝ': 's','ș': 's','ṡ': 's','ṣ': 's','ṩ': 's','ʂ': 's','ᵴ': 's','ᶊ': 's','ȿ': 's','ɡ': 'g','ß': 'ss','ᴑ': 'o','ᴓ': 'o','ᴝ': 'u','ť': 't','ţ': 't','ṱ': 't','ț': 't','ȶ': 't','ẗ': 't','ⱦ': 't','ṫ': 't','ṭ': 't','ƭ': 't','ṯ': 't','ᵵ': 't','ƫ': 't','ʈ': 't','ŧ': 't','ᵺ': 'th','ɐ': 'a','ᴂ': 'ae','ǝ': 'e','ᵷ': 'g','ɥ': 'h','ʮ': 'h','ʯ': 'h','ᴉ': 'i','ʞ': 'k','ꞁ': 'l','ɯ': 'm','ɰ': 'm','ᴔ': 'oe','ɹ': 'r','ɻ': 'r','ɺ': 'r','ⱹ': 'r','ʇ': 't','ʌ': 'v','ʍ': 'w','ʎ': 'y','ꜩ': 'tz','ú': 'u','ŭ': 'u','ǔ': 'u','û': 'u','ṷ': 'u','ü': 'u','ǘ': 'u','ǚ': 'u','ǜ': 'u','ǖ': 'u','ṳ': 'u','ụ': 'u','ű': 'u','ȕ': 'u','ù': 'u','ủ': 'u','ư': 'u','ứ': 'u','ự': 'u','ừ': 'u','ử': 'u','ữ': 'u','ȗ': 'u','ū': 'u','ṻ': 'u','ų': 'u','ᶙ': 'u','ů': 'u','ũ': 'u','ṹ': 'u','ṵ': 'u','ᵫ': 'ue','ꝸ': 'um','ⱴ': 'v','ꝟ': 'v','ṿ': 'v','ʋ': 'v','ᶌ': 'v','ⱱ': 'v','ṽ': 'v','ꝡ': 'vy','ẃ': 'w','ŵ': 'w','ẅ': 'w','ẇ': 'w','ẉ': 'w','ẁ': 'w','ⱳ': 'w','ẘ': 'w','ẍ': 'x','ẋ': 'x','ᶍ': 'x','ý': 'y','ŷ': 'y','ÿ': 'y','ẏ': 'y','ỵ': 'y','ỳ': 'y','ƴ': 'y','ỷ': 'y','ỿ': 'y','ȳ': 'y','ẙ': 'y','ɏ': 'y','ỹ': 'y','ź': 'z','ž': 'z','ẑ': 'z','ʑ': 'z','ⱬ': 'z','ż': 'z','ẓ': 'z','ȥ': 'z','ẕ': 'z','ᵶ': 'z','ᶎ': 'z','ʐ': 'z','ƶ': 'z','ɀ': 'z','ﬀ': 'ff','ﬃ': 'ffi','ﬄ': 'ffl','ﬁ': 'fi','ﬂ': 'fl','ĳ': 'ij','œ': 'oe','ﬆ': 'st','ₐ': 'a','ₑ': 'e','ᵢ': 'i','ⱼ': 'j','ₒ': 'o','ᵣ': 'r','ᵤ': 'u','ᵥ': 'v','ₓ': 'x','Ё': 'YO', 'Й': 'I', 'Ц': 'TS', 'У': 'U', 'К': 'K', 'Е': 'E', 'Н': 'N', 'Г': 'G', 'Ш': 'SH', 'Щ': 'SCH', 'З': 'Z', 'Х': 'H', 'Ъ': '', 'ё': 'yo', 'й': 'i', 'ц': 'ts', 'у': 'u', 'к': 'k', 'е': 'e', 'н': 'n', 'г': 'g', 'ш': 'sh', 'щ': 'sch', 'з': 'z', 'х': 'h', 'ъ': '', 'Ф': 'F', 'Ы': 'I', 'В': 'V', 'А': 'A', 'П': 'P', 'Р': 'R', 'О': 'O', 'Л': 'L', 'Д': 'D', 'Ж': 'ZH', 'Э': 'E', 'ф': 'f', 'ы': 'i', 'в': 'v', 'а': 'a', 'п': 'p', 'р': 'r', 'о': 'o', 'л': 'l', 'д': 'd', 'ж': 'zh', 'э': 'e', 'Я': 'Ya', 'Ч': 'CH', 'С': 'S', 'М': 'M', 'И': 'I', 'Т': 'T', 'Ь': '', 'Б': 'B', 'Ю': 'YU', 'я': 'ya', 'ч': 'ch', 'с': 's', 'м': 'm', 'и': 'i', 'т': 't', 'ь': '', 'б': 'b', 'ю': 'yu'};\r\n\r\nexport default LatinizeMap;\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n * \r\n * Originally from:\r\n * https://github.com/zhukov/webogram\r\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\r\n * https://github.com/zhukov/webogram/blob/master/LICENSE\r\n */\r\n\r\nimport LatinizeMap from \"../config/latinizeMap\";\r\n\r\nexport const badCharsRe = /[`~!@#$%^&*()\\-_=+\\[\\]\\\\|{}'\";:\\/?.>,<]+/g;\r\nconst trimRe = /^\\s+|\\s$/g;\r\n\r\nconst C2L: {[k: string]: string} = {\r\n  й: 'q',\r\n  ц: 'w',\r\n  у: 'e',\r\n  к: 'r',\r\n  е: 't',\r\n  н: 'y',\r\n  г: 'u',\r\n  ш: 'i',\r\n  щ: 'o',\r\n  з: 'p',\r\n  х: '[',\r\n  ъ: ']',\r\n  ф: 'a',\r\n  ы: 's',\r\n  в: 'd',\r\n  а: 'f',\r\n  п: 'g',\r\n  р: 'h',\r\n  о: 'j',\r\n  л: 'k',\r\n  д: 'l',\r\n  ж: ';',\r\n  э: '\\'',\r\n  я: 'z',\r\n  ч: 'x',\r\n  с: 'c',\r\n  м: 'v',\r\n  и: 'b',\r\n  т: 'n',\r\n  ь: 'm',\r\n  б: ',',\r\n  ю: '.',\r\n  '.': '/'\r\n};\r\n\r\nexport function clearBadCharsAndTrim(text: string) {\r\n  return text.replace(badCharsRe, '').replace(trimRe, '');\r\n}\r\n\r\nexport function fixCyrillic(text: string) {\r\n  return text.toLowerCase().replace(/[\\wа-я]/g, (ch) => {\r\n    const latinizeCh = C2L[ch];\r\n    return latinizeCh ?? ch;\r\n  });\r\n}\r\n\r\nexport function latinizeString(text: string) {\r\n  return text.replace(/[^A-Za-z0-9]/g, (ch) => {\r\n    const latinizeCh = LatinizeMap[ch];\r\n    return latinizeCh ?? ch;\r\n  });\r\n}\r\n\r\nexport default function cleanSearchText(text: string, latinize = true) {\r\n  return processSearchText(text, {\r\n    clearBadChars: true,\r\n    latinize,\r\n    ignoreCase: true\r\n  });\r\n}\r\n\r\nexport type ProcessSearchTextOptions = Partial<{\r\n  clearBadChars: boolean,\r\n  latinize: boolean,\r\n  ignoreCase: boolean,\r\n  includeTag: boolean\r\n}>;\r\n\r\nexport function processSearchText(text: string, options: ProcessSearchTextOptions = {}) {\r\n  const hasTag = options.includeTag && text.charAt(0) === '%';\r\n  const originalText = text;\r\n  if(options.clearBadChars) text = clearBadCharsAndTrim(text);\r\n  if(options.latinize) text = latinizeString(text);\r\n  if(options.ignoreCase) text = text.toLowerCase();\r\n  if(hasTag) text = '%' + text;\r\n  if(options.latinize) text += '\\x01' + fixCyrillic(originalText);\r\n  return text;\r\n}\r\n","export default function numberThousandSplitter(x: number, joiner = ' ') {\r\n  const parts = x.toString().split(\".\");\r\n  parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, joiner);\r\n  return parts.join(\".\");\r\n}\r\n","export default function filterUnique<T extends Array<any>>(arr: T): T {\r\n  return [...new Set(arr)] as T;\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n * \r\n * Originally from:\r\n * https://github.com/zhukov/webogram\r\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\r\n * https://github.com/zhukov/webogram/blob/master/LICENSE\r\n */\r\n\r\nimport appPhotosManager from \"./appPhotosManager\";\r\nimport appDocsManager from \"./appDocsManager\";\r\nimport { RichTextProcessor } from \"../richtextprocessor\";\r\nimport { ReferenceContext } from \"../mtproto/referenceDatabase\";\r\nimport rootScope from \"../rootScope\";\r\nimport { WebPage } from \"../../layer\";\r\nimport { MOUNT_CLASS_TO } from \"../../config/debug\";\r\nimport safeReplaceObject from \"../../helpers/object/safeReplaceObject\";\r\nimport limitSymbols from \"../../helpers/string/limitSymbols\";\r\n\r\nconst photoTypeSet = new Set(['photo', 'video', 'gif', 'document']);\r\n\r\ntype WebPageMessageKey = `${PeerId}_${number}`;\r\n\r\nexport class AppWebPagesManager {\r\n  private webpages: {\r\n    [webPageId: string]: WebPage\r\n  } = {};\r\n  private pendingWebPages: {\r\n    [webPageId: string]: Set<WebPageMessageKey>\r\n  } = {};\r\n  \r\n  constructor() {\r\n    rootScope.addMultipleEventsListeners({\r\n      updateWebPage: (update) => {\r\n        this.saveWebPage(update.webpage);\r\n      }\r\n    });\r\n  }\r\n  \r\n  public saveWebPage(apiWebPage: WebPage, messageKey?: WebPageMessageKey, mediaContext?: ReferenceContext) {\r\n    if(apiWebPage._ === 'webPageNotModified') return;\r\n    const {id} = apiWebPage;\r\n\r\n    const oldWebPage = this.webpages[id];\r\n    const isUpdated = oldWebPage && \r\n      oldWebPage._ === apiWebPage._ && \r\n      (oldWebPage as WebPage.webPage).hash === (oldWebPage as WebPage.webPage).hash;\r\n\r\n    if(apiWebPage._ === 'webPage') {\r\n      if(apiWebPage.photo?._ === 'photo') {\r\n        apiWebPage.photo = appPhotosManager.savePhoto(apiWebPage.photo, mediaContext);\r\n      } else {\r\n        delete apiWebPage.photo;\r\n      }\r\n  \r\n      if(apiWebPage.document?._ === 'document') {\r\n        apiWebPage.document = appDocsManager.saveDoc(apiWebPage.document, mediaContext);\r\n      } else {\r\n        if(apiWebPage.type === 'document') {\r\n          delete apiWebPage.type;\r\n        }\r\n  \r\n        delete apiWebPage.document;\r\n      }\r\n\r\n      const siteName = apiWebPage.site_name;\r\n      let shortTitle = apiWebPage.title || apiWebPage.author || siteName || '';\r\n      if(siteName && shortTitle === siteName) {\r\n        delete apiWebPage.site_name;\r\n      }\r\n\r\n      // delete apiWebPage.description\r\n\r\n      if(!photoTypeSet.has(apiWebPage.type) &&\r\n        !apiWebPage.description &&\r\n        apiWebPage.photo) {\r\n        apiWebPage.type = 'photo';\r\n      }\r\n    }\r\n    \r\n    let pendingSet = this.pendingWebPages[id];\r\n    if(messageKey) {\r\n      if(!pendingSet) pendingSet = this.pendingWebPages[id] = new Set();\r\n      pendingSet.add(messageKey);\r\n    }\r\n    \r\n    if(oldWebPage === undefined) {\r\n      this.webpages[id] = apiWebPage;\r\n    } else {\r\n      safeReplaceObject(oldWebPage, apiWebPage);\r\n    }\r\n    \r\n    if(!messageKey && pendingSet !== undefined && isUpdated) {\r\n      const msgs: {peerId: PeerId, mid: number, isScheduled: boolean}[] = [];\r\n      pendingSet.forEach((value) => {\r\n        const [peerId, mid, isScheduled] = value.split('_');\r\n        msgs.push({\r\n          peerId: peerId.toPeerId(), \r\n          mid: +mid, \r\n          isScheduled: !!isScheduled\r\n        });\r\n      });\r\n\r\n      rootScope.dispatchEvent('webpage_updated', {\r\n        id,\r\n        msgs\r\n      });\r\n    }\r\n\r\n    return apiWebPage;\r\n  }\r\n\r\n  public wrapTitle(webPage: WebPage.webPage) {\r\n    let shortTitle = webPage.title || webPage.author || webPage.site_name || '';\r\n    shortTitle = limitSymbols(shortTitle, 80, 100);\r\n    return RichTextProcessor.wrapRichText(shortTitle, {noLinks: true, noLinebreaks: true});\r\n  }\r\n\r\n  public wrapDescription(webPage: WebPage.webPage) {\r\n    const shortDescriptionText = limitSymbols(webPage.description || '', 150, 180);\r\n    // const siteName = webPage.site_name;\r\n    // let contextHashtag = '';\r\n    // if(siteName === 'GitHub') {\r\n    //   const matches = apiWebPage.url.match(/(https?:\\/\\/github\\.com\\/[^\\/]+\\/[^\\/]+)/);\r\n    //   if(matches) {\r\n    //     contextHashtag = matches[0] + '/issues/{1}';\r\n    //   }\r\n    // }\r\n    return RichTextProcessor.wrapRichText(shortDescriptionText/* , {\r\n      contextSite: siteName || 'external',\r\n      contextHashtag: contextHashtag\r\n    } */);\r\n  }\r\n\r\n  public getMessageKeyForPendingWebPage(peerId: PeerId, mid: number, isScheduled?: boolean): WebPageMessageKey {\r\n    return peerId + '_' + mid + (isScheduled ? '_s' : '') as any;\r\n  }\r\n\r\n  public deleteWebPageFromPending(webPage: WebPage, messageKey: WebPageMessageKey) {\r\n    const id = (webPage as WebPage.webPage).id;\r\n    if(!id) return;\r\n\r\n    const set = this.pendingWebPages[id];\r\n    if(set && set.has(messageKey)) {\r\n      set.delete(messageKey);\r\n\r\n      if(!set.size) {\r\n        delete this.pendingWebPages[id];\r\n      }\r\n    }\r\n  }\r\n\r\n  public getWebPage(id: WebPage.webPage['id']) {\r\n    return this.webpages[id];\r\n  }\r\n}\r\n\r\nconst appWebPagesManager = new AppWebPagesManager();\r\nMOUNT_CLASS_TO && (MOUNT_CLASS_TO.appWebPagesManager = appWebPagesManager);\r\nexport default appWebPagesManager;\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nexport default function htmlToDocumentFragment(html: string | DocumentFragment) {\r\n  if(html instanceof DocumentFragment) return html;\r\n  const template = document.createElement('template');\r\n  html = html.trim(); // Never return a text node of whitespace as the result\r\n  template.innerHTML = html;\r\n  return template.content;\r\n}\r\n","export default async function getStream(constraints: MediaStreamConstraints, muted: boolean) {\r\n  // console.log('getStream', constraints);\r\n  \r\n\tconst stream = await navigator.mediaDevices.getUserMedia(constraints);\r\n\tstream.getTracks().forEach(x => {\r\n\t\t/* x.onmute = x => {\r\n\t\t\tconsole.log('track.onmute', x);\r\n\t\t};\r\n\t\tx.onunmute = x => {\r\n\t\t\tconsole.log('track.onunmute', x);\r\n\t\t}; */\r\n\r\n\t\tx.enabled = !muted;\r\n\t});\r\n\r\n\t// console.log('getStream result', stream);\r\n\treturn stream;\r\n}\r\n\r\n(window as any).getStream = getStream;\r\n","export default function getVideoConstraints(): MediaTrackConstraints {\r\n  return {\r\n    width: {min: 1280, max: 1920/* , ideal: 1920 */},\r\n    height: {min: 720, max: 1080/* , ideal: 1080 */},\r\n    frameRate: {min: 24, max: 30}\r\n  };\r\n}\r\n","export const GROUP_CALL_AMPLITUDE_ANALYSE_COUNT_MAX = 50;\r\nexport const GROUP_CALL_AMPLITUDE_ANALYSE_INTERVAL_MS = 100;\r\nexport const GROUP_CALL_PARTICIPANTS_LOAD_LIMIT = 100;\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n * \r\n * Originally from:\r\n * https://github.com/evgeny-nadymov/telegram-react\r\n * Copyright (C) 2018 Evgeny Nadymov\r\n * https://github.com/evgeny-nadymov/telegram-react/blob/master/LICENSE\r\n */\r\n\r\nimport { IS_FIREFOX } from '../../environment/userAgent';\r\nimport LocalConferenceDescription, { ConferenceEntry } from './localConferenceDescription';\r\nimport StringFromLineBuilder from './stringFromLineBuilder';\r\nimport { GroupCallConnectionTransport, PayloadType, UpdateGroupCallConnectionData } from './types';\r\nimport { fromTelegramSource } from './utils';\r\n\r\n// screencast is for Peer-to-Peer only\r\nexport type WebRTCLineTypeTrue = 'video' | 'audio' | 'application';\r\nexport type WebRTCLineType = WebRTCLineTypeTrue | 'screencast';\r\n\r\nexport const WEBRTC_MEDIA_PORT = '9';\r\n\r\nexport function fixMediaLineType(mediaType: WebRTCLineType) {\r\n  return mediaType === 'screencast' ? 'video' : mediaType;\r\n}\r\n\r\nexport function performCandidate(c: GroupCallConnectionTransport['candidates'][0]) {\r\n  const arr: string[] = [];\r\n  arr.push('a=candidate:');\r\n  arr.push(`${c.foundation} ${c.component} ${c.protocol.toUpperCase()} ${c.priority} ${c.ip} ${c.port} typ ${c.type}`);\r\n  if(c['rel-addr'] !== undefined) {\r\n    arr.push(` raddr ${c['rel-addr']} rport ${c['rel-port']}`);\r\n  }\r\n  arr.push(` generation ${c.generation}`);\r\n  return arr.join('');\r\n}\r\n\r\nexport function getConnectionTypeForMediaType(mediaType: WebRTCLineType) {\r\n  // return mediaType === 'application' ? 'DTLS/SCTP' : 'RTP/SAVPF';\r\n  return mediaType === 'application' ? 'DTLS/SCTP' : 'UDP/TLS/RTP/SAVPF';\r\n}\r\n\r\nexport function generateMediaFirstLine(mediaType: WebRTCLineType, port = WEBRTC_MEDIA_PORT, payloadIds: (string | number)[]) {\r\n  const connectionType = getConnectionTypeForMediaType(mediaType);\r\n  return `m=${fixMediaLineType(mediaType)} ${port} ${connectionType} ${payloadIds.join(' ')}`;\r\n}\r\n\r\ntype ConferenceData = UpdateGroupCallConnectionData | LocalConferenceDescription;\r\n\r\n// https://tools.ietf.org/id/draft-ietf-rtcweb-sdp-08.html\r\n// https://datatracker.ietf.org/doc/html/draft-roach-mmusic-unified-plan-00\r\nexport class SDPBuilder extends StringFromLineBuilder {\r\n  public addCandidate(c: GroupCallConnectionTransport['candidates'][0]) {\r\n    return this.add(performCandidate(c));\r\n  }\r\n\r\n  /* public addDataChannel(mid: string, transport: GroupCallConnectionTransport, isAnswer?: boolean) {\r\n    this.add(\r\n      'm=application 9 UDP/DTLS/SCTP webrtc-datachannel',\r\n      'c=IN IP4 0.0.0.0',\r\n      'a=ice-options:trickle',\r\n      `a=mid:${mid}`\r\n    );\r\n\r\n    // if(!isAnswer) {\r\n      this.add('a=sendrecv');\r\n    // }\r\n\r\n    this.addTransport(transport, isAnswer);\r\n\r\n    return this.add(\r\n      'a=sctp-port:5000',\r\n      'a=max-message-size:262144'\r\n    );\r\n  } */\r\n  \r\n  public addHeader(sId: string, bundleMids: string[]) {\r\n    const bundle = bundleMids.join(' ');\r\n    return this.add(\r\n      'v=0',                          // version\r\n      `o=- ${sId} 2 IN IP4 0.0.0.0`,  // sessionId, 2=sessionVersion\r\n      's=-',                          // name of the session\r\n      't=0 0',                        // time when session is valid\r\n      'a=extmap-allow-mixed',\r\n      `a=group:BUNDLE ${bundle}`,\r\n      'a=ice-options:trickle',\r\n      // 'a=ice-lite',                   // ice-lite: is a minimal version of the ICE specification, intended for servers running on a public IP address.\r\n      'a=msid-semantic:WMS *'\r\n    );\r\n  }\r\n  \r\n  public addTransport(transport: GroupCallConnectionTransport, skipCandidates?: boolean) {\r\n    this.add(\r\n      `a=ice-ufrag:${transport.ufrag}`,\r\n      `a=ice-pwd:${transport.pwd}`,\r\n      'a=ice-options:trickle'           // ! test\r\n    );\r\n\r\n    for(const fingerprint of transport.fingerprints) {\r\n      this.add(\r\n        `a=fingerprint:${fingerprint.hash} ${fingerprint.fingerprint}`,\r\n        `a=setup:${fingerprint.setup}`\r\n      );\r\n    }\r\n\r\n    if(!skipCandidates && transport.candidates) {\r\n      for(const candidate of transport.candidates) {\r\n        this.addCandidate(candidate);\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  public addSsrc(entry: ConferenceEntry) {\r\n    let streamName = 'stream';\r\n    let {type, sourceGroups} = entry;\r\n\r\n    // let source = ssrc.source ?? ssrc.sourceGroups[0].sources[0];\r\n    // source = fromTelegramSource(source);\r\n    const source = fromTelegramSource(entry.source);\r\n\r\n    streamName += source;\r\n    type += source as any;\r\n\r\n    // streamName += mid;\r\n    // type += mid as any;\r\n\r\n    // streamName = type = entry.transceiver.receiver.track.id as any;\r\n\r\n    const addMsid = () => {\r\n      this.add(`a=msid:${streamName} ${type}`);\r\n    };\r\n\r\n    const addSource = (ssrc: number) => {\r\n      this.add(\r\n        `a=ssrc:${ssrc} cname:${streamName}`,\r\n        `a=ssrc:${ssrc} msid:${streamName} ${type}`,\r\n        `a=ssrc:${ssrc} mslabel:${streamName}`,\r\n        `a=ssrc:${ssrc} label:${type}`\r\n      );\r\n    };\r\n\r\n    addMsid();\r\n    if(sourceGroups?.length) {\r\n      sourceGroups.forEach(ssrcGroup => {\r\n        if(ssrcGroup.sources.length) {\r\n          const sources = ssrcGroup.sources.map(fromTelegramSource);\r\n          this.add(`a=ssrc-group:${ssrcGroup.semantics} ${sources.join(' ')}`);\r\n          sources.forEach(addSource);\r\n        }\r\n      });\r\n    } else {\r\n      addSource(source);\r\n    }\r\n  \r\n    return this;\r\n  }\r\n\r\n  public addSsrcEntry(entry: ConferenceEntry, data: ConferenceData, isAnswer?: boolean) {\r\n    const add = (...x: string[]) => this.add(...x);\r\n    \r\n    const {type, mid, direction, port} = entry;\r\n    const transport = data.transport;\r\n\r\n    /* if(type === 'application') {\r\n      return this.addDataChannel(mid, transport, isAnswer);\r\n    } */\r\n\r\n    const isApplication = type === 'application';\r\n    const codec = isApplication ? undefined : data[type];\r\n\r\n    const isInactive = direction === 'inactive';\r\n    if(entry.shouldBeSkipped(isAnswer)) {\r\n      return add(\r\n        `m=${fixMediaLineType(type)} 0 ${getConnectionTypeForMediaType(type)} 0`,\r\n        `c=IN IP4 0.0.0.0`,\r\n        `a=inactive`,\r\n        `a=mid:${mid}`\r\n      );\r\n    }\r\n    \r\n    const payloadTypes = !isApplication ? codec['payload-types'] : [{id: 5000} as PayloadType];\r\n    const ids = payloadTypes.map(type => type.id);\r\n    add(\r\n      generateMediaFirstLine(type, port, ids),\r\n      'c=IN IP4 0.0.0.0',\r\n      `a=rtcp:${port} IN IP4 0.0.0.0`,\r\n    );\r\n\r\n    if(transport['rtcp-mux']) {\r\n      add('a=rtcp-mux');\r\n    }\r\n\r\n    add(`a=mid:${mid}`);\r\n    /* if(type === 'video') {\r\n      add('b=AS:2500');\r\n    } */\r\n\r\n    let setDirection = direction;\r\n    if(direction !== 'sendrecv' && isAnswer && !(isInactive || isApplication)) {\r\n      setDirection = direction === 'sendonly' ? 'recvonly' : 'sendonly';\r\n    }\r\n\r\n    // a=bundle-only\r\n    add(`a=${setDirection}`);\r\n    \r\n    // this.addTransport(transport, isAnswer);\r\n    this.addTransport(transport);\r\n\r\n    if(!isApplication) {\r\n      const hdrexts = codec['rtp-hdrexts'];\r\n      if(hdrexts?.length) {\r\n        hdrexts.forEach(hdrext => {\r\n          add(`a=extmap:${hdrext.id} ${hdrext.uri}`);\r\n        });\r\n      }\r\n  \r\n      payloadTypes.forEach(type => {\r\n        add(`a=rtpmap:${type.id} ${type.name}/${type.clockrate}${type.channels && type.channels > 1 ? `/${type.channels}` : ''}`);\r\n  \r\n        const parameters = type.parameters;\r\n        if(Array.isArray(parameters)) {\r\n          if(parameters.length) {\r\n            console.error('parameters is array???', parameters);\r\n          }\r\n        } else if(parameters && Object.keys(parameters).length) {\r\n          const p: string[] = [];\r\n          for(const i in parameters) {\r\n            p.push(`${i}=${parameters[i]}`);\r\n          }\r\n          add(`a=fmtp:${type.id} ${p.join(';')}`);\r\n        }\r\n  \r\n        const fbs = type['rtcp-fbs'];\r\n        if(fbs?.length) {\r\n          fbs.forEach(fb => {\r\n            add(`a=rtcp-fb:${type.id} ${fb.type}${fb.subtype ? ' ' + fb.subtype : ''}`);\r\n          });\r\n        }\r\n      });\r\n    } else {\r\n      add(`a=sctpmap:${payloadTypes[0].id} webrtc-datachannel 256`);\r\n    }\r\n\r\n    if(entry.source && (setDirection === 'sendonly' || setDirection === 'sendrecv')) {\r\n      this.addSsrc(entry);\r\n    }\r\n\r\n    return this;\r\n  }\r\n  \r\n  public addConference(options: {\r\n    conference: LocalConferenceDescription, \r\n    bundle: string[],\r\n    entries: ConferenceEntry[],\r\n    isAnswer?: boolean, \r\n  }) {\r\n    const {conference, entries, bundle, isAnswer} = options;\r\n    this.addHeader(conference.sessionId, bundle);\r\n\r\n    if(IS_FIREFOX) {\r\n      this.addTransport(conference.transport); // support Firefox\r\n    }\r\n\r\n    for(const entry of entries) {\r\n      // this.addSsrcEntry(entry, conference, isAnswer);\r\n      this.addSsrcEntry((isAnswer ? entry.recvEntry || entry.sendEntry : entry.sendEntry || entry.recvEntry) || entry, conference, isAnswer);\r\n    }\r\n\r\n    return this;\r\n  }\r\n  \r\n  public static fromConference(options: Parameters<SDPBuilder['addConference']>[0]) {\r\n    return new SDPBuilder().addConference(options).finalize();\r\n  }\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport SDPMediaSection from \"./mediaSection\";\r\nimport SDPSessionSection from \"./sessionSection\";\r\n\r\nexport type AttributeKey = 'group' | 'rtcp' | 'ice-ufrag' | \r\n  'ice-pwd' | 'ice-options' | 'fingerprint' | 'setup' | \r\n  'mid' | 'extmap' | 'sendonly' | 'msid' | 'rtcp-mux' | \r\n  'rtpmap' | 'rtcp-fb' | 'fmtp' | 'ssrc' | 'ssrc-group' |\r\n  'extmap-allow-mixed' | 'msid-semantic';\r\n\r\nexport type AttributeMap = {[k in AttributeKey]?: boolean};\r\n\r\nexport default class SDP {\r\n  #session: SDPSessionSection;\r\n  #media: SDPMediaSection[];\r\n\r\n  constructor(session: SDP['session'], mediaSections: SDP['media']) {\r\n    this.#session = session;\r\n    this.#media = mediaSections;\r\n  }\r\n\r\n  public get session() {\r\n    return this.#session;\r\n  }\r\n\r\n  public get media() {\r\n    return this.#media;\r\n  }\r\n\r\n  public get bundle() {\r\n    const bundleLine = this.session.lines.find(line => line.parsed?.key === 'group');\r\n    return bundleLine.value.split(' ').slice(1);\r\n  }\r\n\r\n  toString() {\r\n    return this.session.lines\r\n    .concat(...this.media.map(section => section.lines))\r\n    .map(line => line.toString()).join('\\r\\n') + '\\r\\n';\r\n  }\r\n\r\n  /* get buggedMedia() {\r\n    const bundle = this.bundle;\r\n    type A = {\r\n      mid: SDPMediaSection['mid'],\r\n      mediaType: SDPMediaSection['mediaType'],\r\n      direction: SDPMediaSection['direction']\r\n    };\r\n    const out: A[] = [];\r\n    for(let i = 0, length = this.media.length; i < length; ++i) {\r\n      const section = this.media[i];\r\n      const mid = section.mid;\r\n      if(!bundle.includes(mid)) {\r\n        out.push(section);\r\n      }\r\n    }\r\n\r\n    return out;\r\n  } */\r\n\r\n  /* get mediaTypes() {\r\n    return this.media.map((section) => {\r\n      return {mid: section.oa.get('mid').oa, type: section.mediaType, direction: section.direction};\r\n    });\r\n  } */\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nexport default function splitStringByLimitWithRest(str: string, separator: string, limit: number) {\r\n  const splitted = str.split(separator);\r\n  const out: string[] = [];\r\n\r\n  while(limit > 0 && splitted.length) {\r\n    out.push(splitted.shift());\r\n    --limit;\r\n  }\r\n\r\n  if(splitted.length) {\r\n    out.push(splitted.join(separator));\r\n  }\r\n\r\n  return out;\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nexport default class UniqueNumberGenerator {\r\n  #set: Set<number>;\r\n  #min: number;\r\n  #max: number;\r\n\r\n  constructor(min: number, max: number) {\r\n    this.#set = new Set();\r\n    this.#min = min;\r\n    this.#max = max;\r\n  }\r\n\r\n  public generate() {\r\n    const min = this.#min;\r\n    const max = this.#max;\r\n    const set = this.#set;\r\n\r\n    const maxTries = max - min + 1;\r\n    let value = Math.floor(min + maxTries * Math.random()), _try = 0;\r\n    while(set.has(value)) {\r\n      if(value < max) {\r\n        ++value;\r\n      } else {\r\n        value = min;\r\n      }\r\n\r\n      if(++_try >= maxTries) {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    set.add(value);\r\n    return value;\r\n  }\r\n\r\n  public add(value: number) {\r\n    this.#set.add(value);\r\n  }\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport { AttributeKey } from \".\";\r\n\r\nexport default class SDPAttributeSplitted {\r\n  #key: AttributeKey;\r\n  #value: string;\r\n\r\n  // key = 'ssrc-group', value = 'SIM 1 2 3'\r\n  constructor(key: AttributeKey, value: string) {\r\n    this.#key = key;\r\n    this.#value = value;\r\n  }\r\n\r\n  public get key() {\r\n    return this.#key;\r\n  }\r\n\r\n  public get value() {\r\n    return this.#value;\r\n  }\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nexport default class SDPMediaLineParts {\r\n  #type: 'audio' | 'video' | 'application';\r\n  #port: string;\r\n  #protocol: string;\r\n  #ids: string[];\r\n\r\n  constructor(\r\n    type: SDPMediaLineParts['type'], \r\n    port: SDPMediaLineParts['port'], \r\n    protocol: SDPMediaLineParts['protocol'], \r\n    ids: SDPMediaLineParts['ids']\r\n  ) {\r\n    this.#type = type;\r\n    this.#port = port;\r\n    this.#protocol = protocol;\r\n    this.#ids = ids;\r\n  }\r\n\r\n  public get type() {\r\n    return this.#type;\r\n  }\r\n  \r\n  public get port() {\r\n    return this.#port;\r\n  }\r\n\r\n  public get protocol() {\r\n    return this.#protocol;\r\n  }\r\n\r\n  public get ids() {\r\n    return this.#ids;\r\n  }\r\n\r\n  toString() {\r\n    return this.type + ' ' + this.port + ' ' + this.protocol + ' ' + this.ids.join(' ');\r\n  }\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport splitStringByLimitWithRest from \"../../../helpers/string/splitStringByLimitWithRest\";\r\nimport SDPAttributeSplitted from \"./attributeSplitted\";\r\nimport SDPMediaLineParts from \"./mediaLineParts\";\r\n\r\nexport default class SDPLine {\r\n  #key: 'm' | 'a' | 'o' | 'v' | 's' | 't' | 'c';\r\n  #value: string;\r\n  #mediaLineParts: SDPMediaLineParts;\r\n  #parsed?: SDPAttributeSplitted;\r\n\r\n  // key = 'a', value = 'ssrc-group:SIM 1 2 3'\r\n  constructor(key: SDPLine['key'], value: string | SDPMediaLineParts | SDPAttributeSplitted) {\r\n    this.#key = key;\r\n\r\n    if(typeof(value) === 'string') {\r\n      this.#value = value;\r\n\r\n      if(key === 'm') {\r\n        const splitted = value.split(' ');\r\n        this.#mediaLineParts = new SDPMediaLineParts(splitted[0] as any, splitted[1], splitted[2], splitted.slice(3));\r\n      } else {\r\n        if(key === 'a') {\r\n          const result = splitStringByLimitWithRest(value, ':', 1);\r\n          value = result[0];\r\n          this.#parsed = result.length === 1 ? new SDPAttributeSplitted(value as any, null) : new SDPAttributeSplitted(value as any, result[1]);\r\n        }\r\n      }\r\n    } else {\r\n      if(value instanceof SDPMediaLineParts) {\r\n        this.#mediaLineParts = value;\r\n        this.#value = value.toString();\r\n      } else if(value instanceof SDPAttributeSplitted) {\r\n        this.#parsed = value;\r\n        this.#value = value.value ? `${value.key}:${value.value}` : value.key;\r\n      }\r\n    }\r\n  }\r\n\r\n  public get key() {\r\n    return this.#key;\r\n  }\r\n\r\n  public get value() {\r\n    return this.#value;\r\n  }\r\n\r\n  public get parsed() {\r\n    return this.#parsed;\r\n  }\r\n\r\n  public get mediaLineParts() {\r\n    return this.#mediaLineParts;\r\n  }\r\n\r\n  toString() {\r\n    return `${this.key}=${this.value}`;\r\n  }\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport splitStringByLimitWithRest from \"../../../helpers/string/splitStringByLimitWithRest\";\r\n\r\nexport default class SDPAttributeInner {\r\n  #key: string;\r\n  #lines: Array<string>;\r\n  #prefix: string;\r\n  #nestedMap: Map<string, SDPAttributeInner>;\r\n  #missed: boolean;\r\n  #keys: Array<string>;\r\n\r\n  constructor(key: SDPAttributeInner['key'], lines: SDPAttributeInner['lines'], prefix: string = ':', missed = false) {\r\n    this.#key = key;\r\n    this.#lines = lines;\r\n    this.#prefix = prefix;\r\n    this.#missed = missed;\r\n    this.#nestedMap = missed ? new Map() : null;\r\n    this.#keys = missed ? [] : null;\r\n  }\r\n\r\n  public get lines() {\r\n    return this.#lines;\r\n  }\r\n\r\n  public get value() {\r\n    return this.#missed || !this.lines.length ? null : this.lines[0];\r\n  }\r\n\r\n  public get exists() {\r\n    return !this.#missed;\r\n  }\r\n\r\n  public get key() {\r\n    return this.#key;\r\n  }\r\n\r\n  public get keys() {\r\n    SDPAttributeInner.fill(this);\r\n    return this.#keys;\r\n  }\r\n\r\n  public forEach(callback: Parameters<Map<string, SDPAttributeInner>['forEach']>[0]) {\r\n    SDPAttributeInner.fill(this);\r\n    this.#nestedMap.forEach(callback);\r\n  }\r\n\r\n  public get(key: string) {\r\n    SDPAttributeInner.fill(this);\r\n    return this.#nestedMap.get(key) || new SDPAttributeInner(key, [], ':', true);\r\n  }\r\n  \r\n  private static fill(attribute: SDPAttributeInner) {\r\n    if(attribute.#nestedMap !== null) {\r\n      return;\r\n    }\r\n\r\n    const map: Map<string, Array<string>> = new Map();\r\n    attribute.lines.forEach(str => {\r\n      const [key, rest] = splitStringByLimitWithRest(str, attribute.#prefix, 1);\r\n      const values = map.get(key) || [];\r\n      map.set(key, [...values, rest || '']);\r\n    });\r\n  \r\n    const nestedMap = attribute.#nestedMap = SDPAttributeInner.makeAttributes(map);\r\n    attribute.#keys = Array.from(nestedMap.keys());\r\n  }\r\n\r\n  private static makeAttributes(innerParts: Map<string, Array<string>>) {\r\n    const out: Map<string, SDPAttributeInner> = new Map();\r\n  \r\n    innerParts.forEach((lines, key) => {\r\n      out.set(key, new SDPAttributeInner(key, lines));\r\n    });\r\n  \r\n    return out;\r\n  }\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport SDPAttributeInner from \"./attributeInner\";\r\nimport SDPLine from \"./line\";\r\n\r\nexport default class SDPAttributes {\r\n  #lines: SDPLine[];\r\n  #attributes: Map<string, SDPAttributeInner>;\r\n\r\n  constructor(lines: SDPLine[]) {\r\n    this.#lines = lines;\r\n    this.#attributes = new Map();\r\n    SDPAttributes.fillAttributes(this);\r\n  }\r\n\r\n  public get(key: string) {\r\n    return this.#attributes.get(key) || new SDPAttributeInner(key, [], ' ', true);\r\n  }\r\n\r\n  private static fillAttributes(attributes: SDPAttributes) {\r\n    const attributesMap: Map<string, Array<string>> = new Map();\r\n    attributes.#lines.forEach((line) => {\r\n      if(line.key === 'a') {\r\n        const {key, value} = line.parsed;\r\n\r\n        let linesArray = attributesMap.get(key);\r\n        if(!linesArray) {\r\n          linesArray = [];\r\n          attributesMap.set(key, linesArray);\r\n        }\r\n        \r\n        linesArray.push(value || '');\r\n      }\r\n    });\r\n\r\n    attributesMap.forEach((linesArray, key) => {\r\n      attributes.#attributes.set(key, new SDPAttributeInner(key, linesArray, ' ', false));\r\n    });\r\n  }\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport { AttributeMap } from \".\";\r\nimport { NoExtraProperties } from \"../../../types\";\r\nimport SDPAttributes from \"./attributes\";\r\nimport SDPLine from \"./line\";\r\n\r\nexport type SDPMediaDirection = 'sendonly' | 'recvonly' | 'inactive' | 'sendrecv';\r\nexport default class SDPMediaSection {\r\n  #lines: Array<SDPLine>;\r\n  #mediaLine: SDPLine;\r\n  #attributes: SDPAttributes;\r\n  #direction: SDPMediaDirection;\r\n\r\n  constructor(lines: Array<SDPLine>) {\r\n    this.#lines = lines;\r\n    this.#mediaLine = lines[0];\r\n    this.#attributes = this.#direction = null;\r\n  }\r\n\r\n  public get lines() {\r\n    return this.#lines;\r\n  }\r\n\r\n  public get mediaLine() {\r\n    return this.#mediaLine;\r\n  }\r\n\r\n  public get mediaLineParts() {\r\n    return this.#mediaLine.mediaLineParts;\r\n  }\r\n\r\n  public get mediaType() {\r\n    return this.mediaLineParts.type;\r\n  }\r\n\r\n  public get direction() {\r\n    if(!this.#direction) {\r\n      const attributes = this.attributes;\r\n\r\n      let direction: SDPMediaDirection;\r\n      if(attributes.get('sendonly').exists) direction = 'sendonly';\r\n      else if(attributes.get('recvonly').exists) direction = 'recvonly';\r\n      else if(attributes.get('inactive').exists) direction = 'inactive';\r\n      else direction = 'sendrecv';\r\n\r\n      this.#direction = direction;\r\n    }\r\n\r\n    return this.#direction;\r\n  }\r\n\r\n  public get isSending() {\r\n    return this.direction === 'sendrecv' || this.direction === 'sendonly';\r\n  }\r\n\r\n  public get isReceiving() {\r\n    return this.direction === 'sendrecv' || this.direction === 'recvonly';\r\n  }\r\n\r\n  public get attributes() {\r\n    this.#attributes || (this.#attributes = new SDPAttributes(this.lines));\r\n    return this.#attributes;\r\n  }\r\n\r\n  public get mid() {\r\n    return this.attributes.get('mid').value;\r\n  }\r\n\r\n  public lookupAttributeKeys<T extends AttributeMap>(keys: NoExtraProperties<AttributeMap, T>): {[k in keyof T]: T[k] extends true ? string : string[]} {\r\n    const out: any = {};\r\n\r\n    for(const key in keys) {\r\n      const result = this.attributes.get(key);\r\n      // @ts-ignore\r\n      const resultShouldBeArray = !keys[key];\r\n      if(!result) {\r\n        out[key] = resultShouldBeArray ? [] : undefined;\r\n      } else {\r\n        out[key] = resultShouldBeArray ? result.lines : result.value;\r\n      }\r\n    }\r\n\r\n    return out;\r\n  }\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport SDPLine from \"./line\";\r\n\r\nexport default class SDPSessionSection {\r\n  #lines: SDPLine[];\r\n  #sessionId: string;\r\n\r\n  constructor(lines: SDPLine[]) {\r\n    this.#lines = lines;\r\n    this.#sessionId = lines.filter(line => line.key === 'o').map(line => line.value.split(' ')[1])[0];\r\n  }\r\n\r\n  public get lines() {\r\n    return this.#lines;\r\n  }\r\n\r\n  public get sessionId() {\r\n    return this.#sessionId;\r\n  }\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport SDP from \".\";\r\nimport splitStringByLimitWithRest from \"../../../helpers/string/splitStringByLimitWithRest\";\r\nimport UniqueNumberGenerator from \"../../../helpers/uniqueNumberGenerator\";\r\nimport SDPLine from \"./line\";\r\nimport SDPMediaSection from \"./mediaSection\";\r\nimport SDPSessionSection from \"./sessionSection\";\r\n\r\nexport function parseSdp(str: string) {\r\n  function createSection() {\r\n    if(sessionSection) {\r\n      mediaSections.push(new SDPMediaSection(lines));\r\n    } else {\r\n      sessionSection = new SDPSessionSection(lines);\r\n    }\r\n  }\r\n\r\n  let sessionSection: SDPSessionSection = null, mediaSections: SDPMediaSection[] = [], lines: SDPLine[] = [];\r\n  str.split(/\\r?\\n/).forEach(lineStr => {\r\n    if(!isIncorrectSdpLine(lineStr)) {\r\n      const line = parseSdpLine(lineStr);\r\n      if(line.key === 'm') {\r\n        createSection();\r\n        lines = [];\r\n      }\r\n\r\n      lines.push(line);\r\n    }\r\n  });\r\n\r\n  createSection();\r\n  return new SDP(sessionSection, mediaSections);\r\n}\r\n\r\nexport function isIncorrectSdpLine(str: string) {\r\n  return /^[\\s\\xa0]*$/.test(str);\r\n}\r\n\r\nexport function parseSdpLine(str: string) {\r\n  const splitted = splitStringByLimitWithRest(str, '=', 1);\r\n  return new SDPLine(splitted[0] as any, splitted[1]);\r\n}\r\n\r\nexport function addSimulcast(sdp: SDP) {\r\n  let generator: UniqueNumberGenerator;\r\n  sdp.media.forEach((section, idx) => {\r\n    if(section.mediaType === 'video' && section.isSending && !section.attributes.get('ssrc-group').get('SIM').exists) {\r\n      if(!generator) {\r\n        generator = new UniqueNumberGenerator(2, 4294967295);\r\n      }\r\n\r\n      const originalSsrcs = section.attributes.get('ssrc-group').get('FID').value.split(' ');\r\n      const lines = section.lines;\r\n      originalSsrcs.forEach(ssrc => generator.add(+ssrc)); // fix possible duplicates\r\n      const ssrcs = [originalSsrcs[0], generator.generate(), generator.generate()];\r\n      const ssrcs2 = [originalSsrcs[1], generator.generate(), generator.generate()];\r\n\r\n      lines.push(parseSdpLine('a=ssrc-group:SIM ' + ssrcs.join(' ')));\r\n\r\n      const ssrcsStrLines = section.attributes.get('ssrc').get(originalSsrcs[0]).lines;\r\n\r\n      ssrcs.forEach((ssrc, idx) => {\r\n        const ssrc2 = ssrcs2[idx];\r\n        if(idx > 0) {\r\n          lines.push(parseSdpLine('a=ssrc-group:FID ' + ssrc + ' ' + ssrc2));\r\n\r\n          ssrcsStrLines.forEach(v => {\r\n            lines.push(parseSdpLine('a=ssrc:' + ssrc + ' ' + v));\r\n          });\r\n\r\n          ssrcsStrLines.forEach(v => {\r\n            lines.push(parseSdpLine('a=ssrc:' + ssrc2 + ' ' + v));\r\n          });\r\n        }\r\n      });\r\n\r\n      sdp.media[idx] = new SDPMediaSection(lines);\r\n    }\r\n  });\r\n\r\n  return !!generator;\r\n}\r\n","export default function bytesToHex(bytes: ArrayLike<number>) {\r\n  const length = bytes.length;\r\n  const arr: string[] = new Array(length);\r\n  for(let i = 0; i < length; ++i) {\r\n    arr[i] = (bytes[i] < 16 ? '0' : '') + (bytes[i] || 0).toString(16);\r\n  }\r\n  return arr.join('');\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport { RefreshReferenceTask, RefreshReferenceTaskResponse } from \"./apiFileManager\";\r\nimport appMessagesManager from \"../appManagers/appMessagesManager\";\r\nimport appStickersManager from \"../appManagers/appStickersManager\";\r\nimport { Photo } from \"../../layer\";\r\nimport { MOUNT_CLASS_TO } from \"../../config/debug\";\r\nimport apiManager from \"./mtprotoworker\";\r\nimport assumeType from \"../../helpers/assumeType\";\r\nimport { logger } from \"../logger\";\r\nimport bytesToHex from \"../../helpers/bytes/bytesToHex\";\r\nimport deepEqual from \"../../helpers/object/deepEqual\";\r\n\r\nexport type ReferenceContext = ReferenceContext.referenceContextProfilePhoto | ReferenceContext.referenceContextMessage | ReferenceContext.referenceContextEmojiesSounds | ReferenceContext.referenceContextReactions;\r\nexport namespace ReferenceContext {\r\n  export type referenceContextProfilePhoto = {\r\n    type: 'profilePhoto',\r\n    peerId: PeerId\r\n  };\r\n\r\n  export type referenceContextMessage = {\r\n    type: 'message',\r\n    peerId: PeerId,\r\n    messageId: number\r\n  };\r\n\r\n  export type referenceContextEmojiesSounds = {\r\n    type: 'emojiesSounds'\r\n  };\r\n\r\n  export type referenceContextReactions = {\r\n    type: 'reactions'\r\n  };\r\n}\r\n\r\nexport type ReferenceBytes = Photo.photo['file_reference'];\r\nexport type ReferenceContexts = Set<ReferenceContext>;\r\n\r\n//type ReferenceBytes = Uint8Array;\r\n\r\nclass ReferenceDatabase {\r\n  private contexts: Map<ReferenceBytes, ReferenceContexts> = new Map();\r\n  //private references: Map<ReferenceBytes, number[]> = new Map();\r\n  private links: {[hex: string]: ReferenceBytes} = {};\r\n  private log = logger('RD', undefined, true);\r\n  private refreshEmojiesSoundsPromise: Promise<any>;\r\n\r\n  constructor() {\r\n    apiManager.addTaskListener('refreshReference', (task: RefreshReferenceTask) => {\r\n      const originalPayload = task.payload;\r\n\r\n      assumeType<RefreshReferenceTaskResponse>(task);\r\n      task.originalPayload = originalPayload;\r\n\r\n      this.refreshReference(originalPayload).then((bytes) => {\r\n        task.payload = bytes;\r\n      }, (err) => {\r\n        task.error = err;\r\n      }).then(() => apiManager.postMessage(task));\r\n    });\r\n  }\r\n\r\n  public saveContext(reference: ReferenceBytes, context: ReferenceContext, contexts?: ReferenceContexts) {\r\n    [contexts, reference] = this.getContexts(reference);\r\n    if(!contexts) {\r\n      contexts = new Set();\r\n      this.contexts.set(reference, contexts);\r\n    }\r\n    \r\n    this.links[bytesToHex(reference)] = reference;\r\n    for(const _context of contexts) {\r\n      if(deepEqual(_context, context)) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    contexts.add(context);\r\n  }\r\n\r\n  public getReferenceByLink(reference: ReferenceBytes) {\r\n    return this.links[bytesToHex(reference)];\r\n  }\r\n\r\n  public getContexts(reference: ReferenceBytes): [ReferenceContexts, ReferenceBytes] {\r\n    const contexts = this.contexts.get(reference) || (reference = this.getReferenceByLink(reference) || reference, this.contexts.get(reference));\r\n    return [contexts, reference];\r\n  }\r\n\r\n  public getContext(reference: ReferenceBytes): [ReferenceContext, ReferenceBytes] {\r\n    const contexts = this.getContexts(reference);\r\n    return contexts[0] ? [contexts[0].values().next().value, contexts[1]] : undefined;\r\n  }\r\n\r\n  public deleteContext(reference: ReferenceBytes, context: ReferenceContext, contexts?: ReferenceContexts) {\r\n    [contexts, reference] = this.getContexts(reference);\r\n    if(contexts) {\r\n      for(const _context of contexts) {\r\n        if(deepEqual(_context, context)) {\r\n          contexts.delete(_context);\r\n          if(!contexts.size) {\r\n            this.contexts.delete(reference);\r\n            delete this.links[bytesToHex(reference)];\r\n          }\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  public refreshReference(reference: ReferenceBytes, context?: ReferenceContext): Promise<Uint8Array | number[]> {\r\n    this.log('refreshReference: start', reference.slice(), context);\r\n    if(!context) {\r\n      const c = this.getContext(reference);\r\n      if(!c) {\r\n        this.log('refreshReference: got no context for reference:', reference.slice());\r\n        return Promise.reject('NO_CONTEXT');\r\n      }\r\n\r\n      [context, reference] = c;\r\n    }\r\n\r\n    let promise: Promise<any>;\r\n    switch(context?.type) {\r\n      case 'message': {\r\n        promise = appMessagesManager.wrapSingleMessage(context.peerId, context.messageId, true);\r\n        break; \r\n        // .then(() => {\r\n        //   console.log('FILE_REFERENCE_EXPIRED: got message', context, appMessagesManager.getMessage((context as ReferenceContext.referenceContextMessage).messageId).media, reference);\r\n        // });\r\n      }\r\n\r\n      case 'emojiesSounds': {\r\n        promise = this.refreshEmojiesSoundsPromise || appStickersManager.getAnimatedEmojiSounds(true).then(() => {\r\n          this.refreshEmojiesSoundsPromise = undefined;\r\n        });\r\n        break;\r\n      }\r\n\r\n      default: {\r\n        this.log.warn('refreshReference: not implemented context', context);\r\n        return Promise.reject();\r\n      }\r\n    }\r\n\r\n    const hex = bytesToHex(reference);\r\n    this.log('refreshReference: refreshing reference:', hex);\r\n    return promise.then(() => {\r\n      const newHex = bytesToHex(reference);\r\n      this.log('refreshReference: refreshed, reference before:', hex, 'after:', newHex);\r\n      if(hex !== newHex) {\r\n        return reference;\r\n      }\r\n\r\n      this.deleteContext(reference, context);\r\n\r\n      const newContext = this.getContext(reference);\r\n      if(newContext) {\r\n        return this.refreshReference(reference, newContext[0]);\r\n      }\r\n\r\n      this.log.error('refreshReference: no new context, reference before:', hex, 'after:', newHex, context);\r\n\r\n      throw 'NO_NEW_CONTEXT';\r\n    });\r\n  }\r\n\r\n  /* public replaceReference(oldReference: ReferenceBytes, newReference: ReferenceBytes) {\r\n    const contexts = this.contexts.get(oldReference);\r\n    if(contexts) {\r\n      this.contexts.delete(oldReference);\r\n      this.contexts.set(newReference, contexts);\r\n    }\r\n  } */\r\n}\r\n\r\nconst referenceDatabase = new ReferenceDatabase();\r\nMOUNT_CLASS_TO.referenceDatabase = referenceDatabase;\r\nexport default referenceDatabase;","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport SDP from \"../sdp\";\r\nimport SDPMediaSection from \"../sdp/mediaSection\";\r\nimport { toTelegramSource } from \"../utils\";\r\nimport { parseSourceGroups } from \"./parseSourceGroups\";\r\n\r\nexport default function parseMediaSectionInfo(sdp: SDP, channel: SDPMediaSection) {\r\n  const clientInfo = channel.lookupAttributeKeys({\r\n    'ice-ufrag': true,\r\n    'ice-pwd': true,\r\n    fingerprint: true,\r\n    setup: true,\r\n    ssrc: true,\r\n    mid: true,\r\n    'ssrc-group': false\r\n  });\r\n\r\n  if(!clientInfo.fingerprint) { // support Firefox\r\n    const line = sdp.session.lines.find(line => line.parsed?.key === 'fingerprint');\r\n    clientInfo.fingerprint = line.parsed.value;\r\n  }\r\n\r\n  const telegramSourceGroups = parseSourceGroups(clientInfo['ssrc-group']);\r\n  const [hash, fingerprint] = clientInfo.fingerprint.split(' ', 2);\r\n  const ssrc = clientInfo.ssrc && toTelegramSource(+clientInfo.ssrc.split(' ', 1)[0]);\r\n  // ssrc = telegramSourceGroups ? telegramSourceGroups[0].sources[0] : ssrc;\r\n\r\n  return {\r\n    raw: clientInfo,\r\n    ufrag: clientInfo['ice-ufrag'],\r\n    pwd: clientInfo['ice-pwd'],\r\n    fingerprint: {\r\n      fingerprint,\r\n      setup: clientInfo.setup,\r\n      hash\r\n    },\r\n    source: ssrc,\r\n    sourceGroups: telegramSourceGroups,\r\n    mid: clientInfo.mid\r\n  };\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport { GroupCallParticipantVideoSourceGroup } from \"../../../layer\";\r\nimport { toTelegramSource } from \"../utils\";\r\n\r\nexport function parseSourceGroups(sdpLines: string[]) {\r\n  const telegramSourceGroups = sdpLines.map(str => {\r\n    const [semantics, ...rest] = str.split(' ');\r\n\r\n    const sourceGroup: GroupCallParticipantVideoSourceGroup = {\r\n      _: 'groupCallParticipantVideoSourceGroup',\r\n      semantics,\r\n      // sources: rest.map(ssrc => +ssrc)\r\n      sources: rest.map(ssrc => toTelegramSource(+ssrc))\r\n    };\r\n\r\n    return sourceGroup;\r\n  });\r\n\r\n  /* const simIndex = telegramSourceGroups.findIndex(g => g.semantics === 'SIM');\r\n  if(simIndex !== -1) {\r\n    const sourceGroup = telegramSourceGroups.splice(simIndex, 1)[0];\r\n    telegramSourceGroups.unshift(sourceGroup);\r\n  } */\r\n\r\n  return telegramSourceGroups.length ? telegramSourceGroups : undefined;\r\n}\r\n","const IS_VIBRATE_SUPPORTED = !!navigator?.vibrate;\r\n\r\nexport default IS_VIBRATE_SUPPORTED;\r\n","export default function convertInputKeyToKey<T extends string>(inputKey: string) {\r\n  const str = inputKey.replace('input', '');\r\n  return (str[0].toLowerCase() + str.slice(1)) as T;\r\n}\r\n","export default function defineNotNumerableProperties<T extends any>(obj: T, names: (keyof T)[]) {\r\n  //const perf = performance.now();\r\n  const props = {writable: true, configurable: true};\r\n  const out: {[name in keyof T]?: typeof props} = {};\r\n  names.forEach(name => {\r\n    if(!obj.hasOwnProperty(name)) {\r\n      out[name] = props;\r\n    }\r\n  });\r\n  Object.defineProperties(obj, out);\r\n  //console.log('defineNotNumerableProperties time:', performance.now() - perf);\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport { MOUNT_CLASS_TO } from \"../config/debug\";\r\nimport { IS_SAFARI } from \"../environment/userAgent\";\r\nimport { logger, LogTypes } from \"./logger\";\r\n\r\ntype Result = {\r\n  bytes: Uint8Array, \r\n  waveform?: Uint8Array\r\n};\r\n\r\ntype Task = {\r\n  pages: Uint8Array,\r\n  withWaveform: boolean,\r\n  waveform?: Uint8Array,\r\n  callback: {resolve: (result: Result) => void, reject: (err: any) => void},\r\n  timeout: number\r\n};\r\n\r\nexport class OpusDecodeController {\r\n  private worker: Worker;\r\n  private wavWorker : Worker;\r\n  private sampleRate = 48000;\r\n  private tasks: Array<Task> = [];\r\n  private keepAlive = false;\r\n  private isPlaySupportedResult: boolean;\r\n  private log = logger('OPUS', LogTypes.Error);\r\n\r\n  public isPlaySupported() {\r\n    if(this.isPlaySupportedResult !== undefined) return this.isPlaySupportedResult;\r\n\r\n    const audio = document.createElement('audio');\r\n    return this.isPlaySupportedResult = !!(audio.canPlayType && audio.canPlayType('audio/ogg;').replace(/no/, ''))/*  && false */;\r\n  }\r\n\r\n  public loadWavWorker() {\r\n    if(this.wavWorker) return;\r\n\r\n    this.wavWorker = new Worker('waveWorker.min.js');\r\n    this.wavWorker.addEventListener('message', (e) => {\r\n      const data = e.data;\r\n\r\n      this.log('[WAV] got message:', data);\r\n      if(data && data.page) {\r\n        const bytes = data.page;\r\n        this.onTaskEnd(this.tasks.shift(), bytes);\r\n      }\r\n    });\r\n  }\r\n\r\n  public loadWorker() {\r\n    if(this.worker) return;\r\n\r\n    this.worker = new Worker('decoderWorker.min.js');\r\n    this.worker.addEventListener('message', (e) => {\r\n      const data = e.data;\r\n      \r\n      this.log('[DECODER] got message', data);\r\n      if(data.type === 'done') {\r\n        //this.log('[DECODER] send done to wav');\r\n        this.wavWorker.postMessage({command: 'done'});\r\n\r\n        if(data.waveform) {\r\n          this.tasks[0].waveform = data.waveform;\r\n        }\r\n      } else { // e.data contains decoded buffers as float32 values\r\n        //this.log('[DECODER] send encode to wav');\r\n        this.wavWorker.postMessage({\r\n          command: 'encode',\r\n          buffers: e.data\r\n        }, IS_SAFARI ? undefined : data.map((typedArray: Uint8Array) => typedArray.buffer));\r\n      }\r\n    });\r\n  }\r\n\r\n  public setKeepAlive(keepAlive: boolean) {\r\n    this.keepAlive = keepAlive;\r\n    if(this.keepAlive) {\r\n      this.loadWorker();\r\n      this.loadWavWorker();\r\n    } else if(!this.tasks.length) {\r\n      this.terminateWorkers();\r\n    }\r\n  }\r\n\r\n  public onTaskEnd(task: Task, result?: Uint8Array) {\r\n    if(!result) {\r\n      task.callback.reject('timeout');\r\n    } else {\r\n      clearTimeout(task.timeout);\r\n      task.callback.resolve({bytes: result, waveform: task.waveform});\r\n    }\r\n\r\n    if(this.tasks.length) {\r\n      this.executeNewTask(this.tasks[0]);\r\n    }\r\n\r\n    this.terminateWorkers();\r\n  }\r\n\r\n  public terminateWorkers(kill = false) {\r\n    if((this.keepAlive || this.tasks.length) && !kill) return;\r\n\r\n    if(this.worker) {\r\n      this.worker.terminate();\r\n      this.worker = null;\r\n    }\r\n    \r\n    if(this.wavWorker) {\r\n      this.wavWorker.terminate();\r\n      this.wavWorker = null;\r\n    }\r\n  }\r\n\r\n  public executeNewTask(task: Task) {\r\n    this.worker.postMessage({ \r\n      command: 'init',\r\n      decoderSampleRate: this.sampleRate,\r\n      outputBufferSampleRate: this.sampleRate\r\n    });\r\n\r\n    this.wavWorker.postMessage({ \r\n      command: 'init',\r\n      wavBitDepth: 16,\r\n      wavSampleRate: this.sampleRate\r\n    });\r\n\r\n    //console.log('sending command to worker:', task);\r\n    //setTimeout(() => {\r\n      this.log('[DECODER] send decode');\r\n      this.worker.postMessage({\r\n        command: 'decode',\r\n        pages: task.pages,\r\n        waveform: task.withWaveform\r\n      }, IS_SAFARI ? undefined : [task.pages.buffer]);\r\n    //}, 1e3);\r\n\r\n    task.timeout = window.setTimeout(() => {\r\n      this.log.error('decode timeout'/* , task */);\r\n\r\n      this.terminateWorkers(true);\r\n      if(this.tasks.length) {\r\n        this.loadWorker();\r\n        this.loadWavWorker();\r\n      }\r\n\r\n      this.onTaskEnd(this.tasks.shift());\r\n    }, 10e3);\r\n  }\r\n\r\n  public pushDecodeTask(pages: Uint8Array, withWaveform: boolean) {\r\n    return new Promise<Result>((resolve, reject) => {\r\n      const task = {\r\n        pages,\r\n        withWaveform,\r\n        callback: {resolve, reject},\r\n        timeout: 0\r\n      };\r\n\r\n      this.loadWorker();\r\n      this.loadWavWorker();\r\n\r\n      if(this.tasks.push(task) === 1) {\r\n        this.executeNewTask(task);\r\n      }\r\n    });\r\n  }\r\n\r\n  public async decode(typedArray: Uint8Array, withWaveform = false) {\r\n    return this.pushDecodeTask(typedArray, withWaveform).then(result => {\r\n      const dataBlob = new Blob([result.bytes], {type: \"audio/wav\"});\r\n      return {url: URL.createObjectURL(dataBlob), waveform: result.waveform};\r\n    });\r\n  }\r\n}\r\n\r\nconst opusDecodeController = new OpusDecodeController();\r\nMOUNT_CLASS_TO.opusDecodeController = opusDecodeController;\r\nexport default opusDecodeController;","import { IS_APPLE_MOBILE, IS_SAFARI } from \"./userAgent\";\r\n\r\nconst IS_WEBM_SUPPORTED = !!document.createElement('video').canPlayType('video/webm') && !IS_SAFARI && !IS_APPLE_MOBILE;\r\n\r\n(window as any).IS_WEBM_SUPPORTED = IS_WEBM_SUPPORTED;\r\nexport default IS_WEBM_SUPPORTED;\r\n","/**\r\n * Will be used for FILE_REFERENCE_EXPIRED\r\n * @param key \r\n * @param wasObject \r\n * @param newObject \r\n */\r\n export default function safeReplaceArrayInObject<K>(key: K, wasObject: any, newObject: any) {\r\n  if('byteLength' in newObject[key]) { // Uint8Array\r\n    newObject[key] = [...newObject[key]];\r\n  }\r\n\r\n  if(wasObject && wasObject[key] !== newObject[key]) {\r\n    wasObject[key].length = newObject[key].length;\r\n    (newObject[key] as any[]).forEach((v, i) => {\r\n      wasObject[key][i] = v;\r\n    });\r\n\r\n    /* wasObject[key].set(newObject[key]); */\r\n    newObject[key] = wasObject[key];\r\n  }\r\n}\r\n","import IS_WEBP_SUPPORTED from \"./webpSupport\";\r\n\r\nconst IMAGE_MIME_TYPES_SUPPORTED = new Set([\r\n  'image/jpeg',\r\n  'image/png',\r\n  'image/bmp'\r\n]);\r\n\r\nif(IS_WEBP_SUPPORTED) {\r\n  IMAGE_MIME_TYPES_SUPPORTED.add('image/webp');\r\n}\r\n\r\nexport default IMAGE_MIME_TYPES_SUPPORTED;\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nconst ASSETS_PATH = 'assets/audio/';\r\n\r\nexport default class AudioAssetPlayer<AssetName extends string> {\r\n  private audio: HTMLAudioElement;\r\n  private tempId: number;\r\n  private assetName: AssetName;\r\n\r\n  constructor(private assets: AssetName[]) {\r\n    this.tempId = 0;\r\n  }\r\n\r\n  public playSound(name: AssetName, loop = false) {\r\n    ++this.tempId;\r\n    this.assetName = name;\r\n\r\n    try {\r\n      const audio = this.createAudio();\r\n      audio.autoplay = true;\r\n      audio.src = ASSETS_PATH + name;\r\n      audio.loop = loop;\r\n      audio.play();\r\n    } catch(e) {\r\n      console.error('playSound', name, e);\r\n    }\r\n  }\r\n\r\n  public playSoundIfDifferent(name: AssetName, loop?: boolean) {\r\n    if(this.assetName !== name) {\r\n      this.playSound(name, loop);\r\n    }\r\n  }\r\n\r\n  public createAudio() {\r\n    let {audio} = this;\r\n    if(audio) {\r\n      return audio;\r\n    }\r\n\r\n    audio = this.audio = new Audio();\r\n    audio.play();\r\n    return audio;\r\n  }\r\n\r\n  public stopSound() {\r\n    if(!this.audio) {\r\n      return;\r\n    }\r\n    \r\n    this.audio.pause();\r\n  }\r\n\r\n  public cancelDelayedPlay() {\r\n    ++this.tempId;\r\n  }\r\n\r\n  public playSoundWithTimeout(name: AssetName, loop: boolean, timeout: number) {\r\n    // timeout = 0;\r\n    const tempId = ++this.tempId;\r\n    setTimeout(() => {\r\n      if(this.tempId !== tempId) {\r\n        return;\r\n      }\r\n\r\n      this.playSound(name, loop);\r\n    }, timeout);\r\n  }\r\n}\r\n","export default function getScreenConstraints(skipAudio?: boolean) {\r\n  const constraints: DisplayMediaStreamConstraints = {\r\n   video: {\r\n      // @ts-ignore\r\n      // cursor: 'always',\r\n      width: {max: 1920},\r\n      height: {max: 1080},\r\n      frameRate: {max: 30}\r\n    }\r\n  };\r\n\r\n  if(!skipAudio) {\r\n    constraints.audio = true;\r\n  }\r\n\r\n  return constraints;\r\n}\r\n","export default async function getScreenStream(constraints: DisplayMediaStreamConstraints) {\r\n  const screenStream = await navigator.mediaDevices.getDisplayMedia(constraints);\r\n  const track = screenStream.getVideoTracks()[0];\r\n  track.contentHint = 'text';\r\n  return screenStream;\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n * \r\n * Originally from:\r\n * https://github.com/evgeny-nadymov/telegram-react\r\n * Copyright (C) 2018 Evgeny Nadymov\r\n * https://github.com/evgeny-nadymov/telegram-react/blob/master/LICENSE\r\n */\r\n\r\nexport default class StringFromLineBuilder {\r\n  private lines: string[];\r\n  private newLine: string[];\r\n\r\n  constructor(private joiner = '\\r\\n') {\r\n    this.lines = [];\r\n    this.newLine = [];\r\n  }\r\n\r\n  public add(...strs: string[]) {\r\n    this.lines.push(...strs);\r\n    return this;\r\n  }\r\n\r\n  public push(word: string) {\r\n    this.newLine.push(word);\r\n    return this;\r\n  }\r\n  \r\n  public addJoined(separator = '') {\r\n    this.add(this.newLine.join(separator));\r\n    this.newLine = [];\r\n    return this;\r\n  }\r\n\r\n  public join() {\r\n    return this.lines.join(this.joiner);\r\n  }\r\n\r\n  public finalize() {\r\n    return this.join() + this.joiner;\r\n  }\r\n}\r\n","// credits to https://github.com/sindresorhus/escape-string-regexp/blob/master/index.js\r\nexport default function escapeRegExp(str: string) {\r\n  return str\r\n    .replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\r\n    .replace(/-/g, '\\\\x2d');\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport forEachReverse from \"../../helpers/array/forEachReverse\";\r\nimport throttle from \"../../helpers/schedulers/throttle\";\r\nimport { Updates, PhoneJoinGroupCall, PhoneJoinGroupCallPresentation, Update } from \"../../layer\";\r\nimport apiUpdatesManager from \"../appManagers/apiUpdatesManager\";\r\nimport appGroupCallsManager, { GroupCallConnectionType, JoinGroupCallJsonPayload } from \"../appManagers/appGroupCallsManager\";\r\nimport apiManager from \"../mtproto/mtprotoworker\";\r\nimport rootScope from \"../rootScope\";\r\nimport CallConnectionInstanceBase, { CallConnectionInstanceOptions } from \"./callConnectionInstanceBase\";\r\nimport GroupCallInstance from \"./groupCallInstance\";\r\nimport filterServerCodecs from \"./helpers/filterServerCodecs\";\r\nimport fixLocalOffer from \"./helpers/fixLocalOffer\";\r\nimport processMediaSection from \"./helpers/processMediaSection\";\r\nimport { ConferenceEntry } from \"./localConferenceDescription\";\r\nimport SDP from \"./sdp\";\r\nimport SDPMediaSection from \"./sdp/mediaSection\";\r\nimport { WebRTCLineType } from \"./sdpBuilder\";\r\nimport { UpdateGroupCallConnectionData } from \"./types\";\r\n\r\nexport default class GroupCallConnectionInstance extends CallConnectionInstanceBase {\r\n  private groupCall: GroupCallInstance;\r\n  public updateConstraints?: boolean;\r\n  private type: GroupCallConnectionType;\r\n  private options: {\r\n    type: Extract<GroupCallConnectionType, 'main'>, \r\n    isMuted?: boolean, \r\n    joinVideo?: boolean, \r\n    rejoin?: boolean\r\n  } | {\r\n    type: Extract<GroupCallConnectionType, 'presentation'>,\r\n  };\r\n\r\n  private updateConstraintsInterval: number;\r\n  public negotiateThrottled: () => void;\r\n\r\n  constructor(options: CallConnectionInstanceOptions & {\r\n    groupCall: GroupCallConnectionInstance['groupCall'],\r\n    type: GroupCallConnectionInstance['type'],\r\n    options: GroupCallConnectionInstance['options'],\r\n  }) {\r\n    super(options);\r\n\r\n    this.negotiateThrottled = throttle(this.negotiate.bind(this), 0, false);\r\n  }\r\n\r\n  public createPeerConnection() {\r\n    return this.connection || super.createPeerConnection({ \r\n      iceServers: [], \r\n      iceTransportPolicy: 'all', \r\n      bundlePolicy: 'max-bundle', \r\n      rtcpMuxPolicy: 'require', \r\n      iceCandidatePoolSize: 0, \r\n      // sdpSemantics: \"unified-plan\", \r\n      // extmapAllowMixed: true,\r\n    });\r\n  }\r\n\r\n  public createDataChannel() {\r\n    if(this.dataChannel) {\r\n      return this.dataChannel;\r\n    }\r\n\r\n    const dataChannel = super.createDataChannel();\r\n\r\n    dataChannel.addEventListener('open', () => {\r\n      this.maybeUpdateRemoteVideoConstraints();\r\n    });\r\n\r\n    dataChannel.addEventListener('close', () => {\r\n      if(this.updateConstraintsInterval) {\r\n        clearInterval(this.updateConstraintsInterval);\r\n        this.updateConstraintsInterval = undefined;\r\n      }\r\n    });\r\n\r\n    return dataChannel;\r\n  }\r\n\r\n  public createDescription() {\r\n    if(this.description) {\r\n      return this.description;\r\n    }\r\n\r\n    const description = super.createDescription();\r\n\r\n    /* const perType = 0;\r\n    const types = ['audio' as const, 'video' as const];\r\n    const count = types.length * perType;\r\n    const init: RTCRtpTransceiverInit = {direction: 'recvonly'};\r\n    types.forEach(type => {\r\n      for(let i = 0; i < perType; ++i) {\r\n        description.createEntry(type).createTransceiver(connection, init);\r\n      }\r\n    }); */\r\n\r\n    return description;\r\n  }\r\n\r\n  public appendStreamToConference() {\r\n    super.appendStreamToConference();/* .then(() => {\r\n      currentGroupCall.connections.main.negotiating = false;\r\n      this.startNegotiation({\r\n        type: type,\r\n        isMuted: muted,\r\n        rejoin\r\n      });\r\n    }); */\r\n  }\r\n\r\n  private async invokeJoinGroupCall(localSdp: SDP, mainChannels: SDPMediaSection[], options: GroupCallConnectionInstance['options']) {\r\n    const {groupCall, description} = this;\r\n    const groupCallId = groupCall.id;\r\n\r\n    const processedChannels = mainChannels.map(section => {\r\n      const processed = processMediaSection(localSdp, section);\r\n\r\n      this.sources[processed.entry.type as 'video' | 'audio'] = processed.entry;\r\n      \r\n      return processed;\r\n    });\r\n\r\n    let promise: Promise<Updates>;\r\n    const audioChannel = processedChannels.find(channel => channel.media.mediaType === 'audio');\r\n    const videoChannel = processedChannels.find(channel => channel.media.mediaType === 'video');\r\n    let {source, params} = audioChannel || {};\r\n    const useChannel = videoChannel || audioChannel;\r\n\r\n    const channels: {[type in WebRTCLineType]?: typeof audioChannel} = {\r\n      audio: audioChannel,\r\n      video: videoChannel\r\n    };\r\n\r\n    description.entries.forEach(entry => {\r\n      if(entry.direction === 'sendonly') {\r\n        const channel = channels[entry.type];\r\n        if(!channel) return;\r\n\r\n        description.setEntrySource(entry, channel.sourceGroups || channel.source);\r\n        description.setEntryPeerId(entry, rootScope.myId);\r\n      }\r\n    });\r\n\r\n    // overwrite ssrc with audio in video params\r\n    if(params !== useChannel.params) {\r\n      const data: JoinGroupCallJsonPayload = JSON.parse(useChannel.params.data);\r\n      // data.ssrc = source || data.ssrc - 1; // audio channel can be missed in screensharing\r\n      if(source) data.ssrc = source;\r\n      else delete data.ssrc;\r\n      params = {\r\n        _: 'dataJSON',\r\n        data: JSON.stringify(data)\r\n      };\r\n    }\r\n    \r\n    const groupCallInput = appGroupCallsManager.getGroupCallInput(groupCallId);\r\n    if(options.type === 'main') {\r\n      const request: PhoneJoinGroupCall = {\r\n        call: groupCallInput,\r\n        join_as: {_: 'inputPeerSelf'},\r\n        params,\r\n        muted: options.isMuted,\r\n        video_stopped: !options.joinVideo\r\n      };\r\n\r\n      promise = apiManager.invokeApi('phone.joinGroupCall', request);\r\n      this.log(`[api] joinGroupCall id=${groupCallId}`, request);\r\n    } else {\r\n      const request: PhoneJoinGroupCallPresentation = {\r\n        call: groupCallInput,\r\n        params,\r\n      };\r\n\r\n      promise = apiManager.invokeApi('phone.joinGroupCallPresentation', request);\r\n      this.log(`[api] joinGroupCallPresentation id=${groupCallId}`, request);\r\n    }\r\n\r\n    const updates = await promise;\r\n    apiUpdatesManager.processUpdateMessage(updates);\r\n    const update = (updates as Updates.updates).updates.find(update => update._ === 'updateGroupCallConnection') as Update.updateGroupCallConnection;\r\n\r\n    const data: UpdateGroupCallConnectionData = JSON.parse(update.params.data);\r\n\r\n    data.audio = data.audio || groupCall.connections.main.description.audio;\r\n    description.setData(data);\r\n    filterServerCodecs(mainChannels, data);\r\n\r\n    return data;\r\n  }\r\n\r\n  protected async negotiateInternal() {\r\n    const {connection, description} = this;\r\n    const isNewConnection = connection.iceConnectionState === 'new' && !description.getEntryByMid('0').source;\r\n    const log = this.log.bindPrefix('startNegotiation');\r\n    log('start');\r\n    \r\n    const originalOffer = await connection.createOffer({iceRestart: false});\r\n\r\n    if(isNewConnection && this.dataChannel) {\r\n      const dataChannelEntry = description.createEntry('application');\r\n      dataChannelEntry.setDirection('sendrecv');\r\n    }\r\n\r\n    const {sdp: localSdp, offer} = fixLocalOffer({\r\n      offer: originalOffer, \r\n      data: description\r\n    });\r\n\r\n    log('[sdp] setLocalDescription', offer.sdp);\r\n    await connection.setLocalDescription(offer);\r\n\r\n    const mainChannels = localSdp.media.filter(media => {\r\n      return media.mediaType !== 'application' && media.isSending;\r\n    });\r\n\r\n    if(isNewConnection) {\r\n      try {\r\n        await this.invokeJoinGroupCall(localSdp, mainChannels, this.options);\r\n      } catch(e) {\r\n        this.log.error('[tdweb] joinGroupCall error', e);\r\n      }\r\n    }\r\n    \r\n    /* if(!data) {\r\n      log('abort 0');\r\n      this.closeConnectionAndStream(connection, streamManager);\r\n      return;\r\n    } */\r\n\r\n    /* if(connection.iceConnectionState !== 'new') {\r\n      log(`abort 1 connectionState=${connection.iceConnectionState}`);\r\n      this.closeConnectionAndStream(connection, streamManager);\r\n      return;\r\n    } */\r\n    /* if(this.currentGroupCall !== currentGroupCall || connectionHandler.connection !== connection) {\r\n      log('abort', this.currentGroupCall, currentGroupCall);\r\n      this.closeConnectionAndStream(connection, streamManager);\r\n      return;\r\n    } */\r\n    \r\n    const isAnswer = true;\r\n    // const _bundleMids = bundleMids.slice();\r\n    const entriesToDelete: ConferenceEntry[] = [];\r\n    const bundle = localSdp.bundle;\r\n    forEachReverse(bundle, (mid, idx, arr) => {\r\n      const entry = description.getEntryByMid(mid);\r\n      if(entry.shouldBeSkipped(isAnswer)) {\r\n        arr.splice(idx, 1);\r\n        entriesToDelete.push(entry);\r\n      }\r\n    });\r\n\r\n    /* forEachReverse(description.entries, (entry, idx, arr) => {\r\n      const mediaSection = _parsedSdp.media.find(section => section.oa.get('mid').oa === entry.mid);\r\n      const deleted = !mediaSection;\r\n      // const deleted = !_bundleMids.includes(entry.mid); // ! can't use it because certain mid can be missed in bundle\r\n      if(deleted) {\r\n        arr.splice(idx, 1);\r\n      }\r\n    }); */\r\n\r\n    const entries = localSdp.media.map((section) => {\r\n      const mid = section.mid;\r\n      let entry = description.getEntryByMid(mid);\r\n      if(!entry) {\r\n        entry = new ConferenceEntry(mid, section.mediaType);\r\n        entry.setDirection('inactive');\r\n      }\r\n\r\n      return entry;\r\n    });\r\n\r\n    const answerDescription: RTCSessionDescriptionInit = {\r\n      type: 'answer',\r\n      sdp: description.generateSdp({\r\n        bundle, \r\n        entries, \r\n        isAnswer\r\n      })\r\n    };\r\n\r\n    entriesToDelete.forEach(entry => {\r\n      description.deleteEntry(entry);\r\n    });\r\n\r\n    log(`[sdp] setRemoteDescription signaling=${connection.signalingState} ice=${connection.iceConnectionState} gathering=${connection.iceGatheringState} connection=${connection.connectionState}`, answerDescription.sdp);\r\n    await connection.setRemoteDescription(answerDescription);\r\n\r\n    log('end');\r\n  }\r\n\r\n  public negotiate() {\r\n    let promise = this.negotiating;\r\n    if(promise) {\r\n      return promise;\r\n    }\r\n\r\n    promise = super.negotiate();\r\n\r\n    if(this.updateConstraints) {\r\n      promise.then(() => {\r\n        this.maybeUpdateRemoteVideoConstraints();\r\n        this.updateConstraints = false;\r\n      });\r\n    }\r\n\r\n    if(this.options.type === 'presentation') {\r\n      promise.then(() => {\r\n        this.connection.getTransceivers().find(transceiver => {\r\n          if(transceiver.sender?.track?.kind === 'video') {\r\n            transceiver.sender.setParameters({\r\n              ...transceiver.sender.getParameters(),\r\n              degradationPreference: 'maintain-resolution'\r\n            });\r\n          }\r\n        });\r\n      });\r\n    }\r\n\r\n    return promise;\r\n  }\r\n\r\n  public maybeUpdateRemoteVideoConstraints() {\r\n    if(this.dataChannel.readyState !== 'open') {\r\n      return;\r\n    }\r\n\r\n    this.log('maybeUpdateRemoteVideoConstraints');\r\n    \r\n    // * https://github.com/TelegramMessenger/tgcalls/blob/6f2746e04c9b040f8c8dfc64d916a1853d09c4ce/tgcalls/group/GroupInstanceCustomImpl.cpp#L2549\r\n    type VideoConstraints = {minHeight?: number, maxHeight: number};\r\n    const obj: {\r\n      colibriClass: 'ReceiverVideoConstraints',\r\n      constraints: {[endpoint: string]: VideoConstraints},\r\n      defaultConstraints: VideoConstraints,\r\n      onStageEndpoints: string[]\r\n    } = {\r\n      colibriClass: 'ReceiverVideoConstraints',\r\n      constraints: {},\r\n      defaultConstraints: {maxHeight: 0},\r\n      onStageEndpoints: []\r\n    };\r\n\r\n    for(const entry of this.description.entries) {\r\n      if(entry.direction !== 'recvonly' || entry.type !== 'video') {\r\n        continue;\r\n      }\r\n\r\n      const {endpoint} = entry;\r\n      obj.onStageEndpoints.push(endpoint);\r\n      obj.constraints[endpoint] = {\r\n        minHeight: 180,\r\n        maxHeight: 720\r\n      };\r\n    }\r\n\r\n    this.sendDataChannelData(obj);\r\n\r\n    if(!obj.onStageEndpoints.length) {\r\n      if(this.updateConstraintsInterval) {\r\n        clearInterval(this.updateConstraintsInterval);\r\n        this.updateConstraintsInterval = undefined;\r\n      }\r\n    } else if(!this.updateConstraintsInterval) {\r\n      this.updateConstraintsInterval = window.setInterval(this.maybeUpdateRemoteVideoConstraints.bind(this), 5000);\r\n    }\r\n  }\r\n  \r\n  public addInputVideoStream(stream: MediaStream) {\r\n    // const {sources} = this;\r\n    // if(sources?.video) {\r\n      // const source = this.sources.video.source;\r\n      // stream.source = '' + source;\r\n      this.groupCall.saveInputVideoStream(stream, this.type);\r\n    // }\r\n\r\n    this.streamManager.addStream(stream, 'input');\r\n    this.appendStreamToConference(); // replace sender track\r\n  }\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport { DataJSON } from \"../../../layer\";\r\nimport { JoinGroupCallJsonPayload } from \"../../appManagers/appGroupCallsManager\";\r\nimport SDP from \"../sdp\";\r\nimport { Ssrc } from \"../types\";\r\nimport parseMediaSectionInfo from \"./parseMediaSectionInfo\";\r\n\r\nexport default function processMediaSection(sdp: SDP, media: SDP['media'][0]) {\r\n  const sectionInfo = parseMediaSectionInfo(sdp, media);\r\n\r\n  const mediaType: Exclude<typeof media['mediaType'], 'application'> = media.mediaType as any;\r\n  const entry: Ssrc = {\r\n    source: sectionInfo.source,\r\n    sourceGroups: sectionInfo.sourceGroups,\r\n    type: mediaType\r\n  };\r\n\r\n  // do not change this value, otherwise onconnectionstatechange won't fire\r\n  sectionInfo.fingerprint.setup = 'active';\r\n  const payload: JoinGroupCallJsonPayload = {\r\n    fingerprints: [sectionInfo.fingerprint],\r\n    pwd: sectionInfo.pwd,\r\n    ssrc: sectionInfo.source,\r\n    'ssrc-groups': sectionInfo.sourceGroups || [],\r\n    ufrag: sectionInfo.ufrag\r\n  };\r\n  const paramsDataJson = JSON.stringify(payload);\r\n\r\n  const params: DataJSON = {\r\n    _: 'dataJSON',\r\n    data: paramsDataJson\r\n  };\r\n\r\n  return {\r\n    params, \r\n    source: sectionInfo.source, \r\n    media, \r\n    sourceGroups: sectionInfo.sourceGroups, \r\n    entry\r\n  };\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport forEachReverse from \"../../../helpers/array/forEachReverse\";\r\nimport SDPMediaSection from \"../sdp/mediaSection\";\r\nimport { UpdateGroupCallConnectionData, Codec } from \"../types\";\r\n\r\nexport default function filterServerCodecs(mainChannels: SDPMediaSection[], data: UpdateGroupCallConnectionData) {\r\n  // ! Need to filter server's extmap for Firefox\r\n  const performExtmap = (channel: typeof mainChannels[0]) => {\r\n    const out: {[id: string]: string} = {};\r\n    const extmap = channel.attributes.get('extmap');\r\n    extmap.forEach((extmap) => {\r\n      const id = extmap.key.split('/', 1)[0];\r\n      out[id] = extmap.value;\r\n    });\r\n\r\n    return out;\r\n  };\r\n\r\n  const codecsToPerform: [Codec, 'audio' | 'video'][] = /* flatten([data, dataPresentation].filter(Boolean).map(data => {\r\n    return  */['audio' as const, 'video' as const].filter(type => data[type]).map(type => ([data[type], type]));\r\n  // }));\r\n\r\n  codecsToPerform.forEach(([codec, type]) => {\r\n    const channel = mainChannels.find(line => line.mediaType === type);\r\n    if(!channel) {\r\n      return;\r\n    }\r\n\r\n    const extmap = performExtmap(channel);\r\n    forEachReverse(codec[\"rtp-hdrexts\"], (value, index, arr) => {\r\n      if(extmap[value.id] !== value.uri) {\r\n        arr.splice(index, 1);\r\n        console.log(`[sdp] filtered extmap:`, value, index, type);\r\n      }\r\n    });\r\n  });\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport forEachReverse from \"../../../helpers/array/forEachReverse\";\r\nimport copy from \"../../../helpers/object/copy\";\r\nimport { ConferenceEntry } from \"../localConferenceDescription\";\r\nimport { parseSdp, addSimulcast } from \"../sdp/utils\";\r\nimport { generateMediaFirstLine, SDPBuilder } from \"../sdpBuilder\";\r\nimport { UpdateGroupCallConnectionData } from \"../types\";\r\nimport parseMediaSectionInfo from \"./parseMediaSectionInfo\";\r\n\r\nexport default function fixLocalOffer(options: {\r\n  offer: RTCSessionDescriptionInit, \r\n  data: UpdateGroupCallConnectionData,\r\n  skipAddingMulticast?: boolean\r\n  // mids?: string[]\r\n}) {\r\n  const {offer, data} = options;\r\n  const sdp = parseSdp(offer.sdp);\r\n  let hasMunged = false;\r\n\r\n  if(!options.skipAddingMulticast) {\r\n    hasMunged = addSimulcast(sdp) || hasMunged;\r\n  }\r\n\r\n  // const bundleLine = parsedSdp.session.lines.find(line => line.Ha?.key === 'group');\r\n  // const bundleMids = bundleLine.value.split(' ').slice(1);\r\n\r\n  forEachReverse(sdp.media, (section, idx, arr) => {\r\n    // const mid = section.oa.get('mid').oa;\r\n\r\n    // это может случиться при выключении и включении видео. почему-то появится секция уже удалённая\r\n    // ! нельзя тут модифицировать локальное описание, будет критовать\r\n    /* if(mids && !mids.includes(mid) && !bundleMids.includes(mid)) {\r\n      console.error('wtf');\r\n      hasMunged = true;\r\n      arr.splice(idx, 1);\r\n      return;\r\n    } */\r\n\r\n    if(/* section.mediaType !== 'video' ||  */section.isSending) {\r\n      return;\r\n    }\r\n\r\n    if(section.mediaType === 'application') {\r\n      return;\r\n    }\r\n\r\n    const mediaLine = section.mediaLine;\r\n    const mediaLineParts = mediaLine.mediaLineParts;\r\n    const mediaCodecIds = mediaLineParts.ids;\r\n    const localMLine = mediaLine.toString();\r\n\r\n    const codec = data[section.mediaType];\r\n    const payloadTypes = codec['payload-types'];\r\n\r\n    /* forEachReverse(payloadTypes, (payloadType, idx, arr) => {\r\n      if(!mediaCodecIds.includes('' + payloadType.id) && section.mediaType === 'video') {\r\n      // if(payloadType.name === 'H265') {\r\n        console.warn('[sdp] filtered unsupported codec', payloadType, mediaCodecIds, section.mediaType);\r\n        arr.splice(idx, 1);\r\n      }\r\n    }); */\r\n\r\n    const codecIds = payloadTypes.map(payload => '' + payload.id);\r\n    const correctMLine = generateMediaFirstLine(section.mediaType, undefined, codecIds);\r\n    \r\n    if(localMLine !== correctMLine) {\r\n      const sectionInfo = parseMediaSectionInfo(sdp, section);\r\n\r\n      let newData = {...data};\r\n      newData.transport = copy(newData.transport);\r\n      newData.transport.ufrag = sectionInfo.ufrag;\r\n      newData.transport.pwd = sectionInfo.pwd;\r\n      newData.transport.fingerprints = [sectionInfo.fingerprint];\r\n      newData.transport.candidates = [];\r\n\r\n      const entry = new ConferenceEntry(sectionInfo.mid, mediaLineParts.type);\r\n      entry.setPort(mediaLineParts.port);\r\n      sectionInfo.source && entry.setSource(sectionInfo.sourceGroups || sectionInfo.source);\r\n      entry.setDirection(section.direction);\r\n\r\n      const newSdp = new SDPBuilder().addSsrcEntry(entry, newData).finalize();\r\n\r\n      const newChannel = parseSdp(newSdp).media[0];\r\n      arr[idx] = newChannel;\r\n\r\n      hasMunged = true;\r\n    }\r\n  });\r\n\r\n  if(hasMunged) {\r\n    const mungedSdp = sdp.toString();\r\n    offer.sdp = mungedSdp;\r\n  }\r\n\r\n  return {offer, sdp/* , bundleMids */};\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport { IS_SAFARI } from \"../../environment/userAgent\";\r\nimport indexOfAndSplice from \"../../helpers/array/indexOfAndSplice\";\r\nimport safeAssign from \"../../helpers/object/safeAssign\";\r\nimport throttle from \"../../helpers/schedulers/throttle\";\r\nimport { GroupCall, GroupCallParticipant, Updates } from \"../../layer\";\r\nimport apiUpdatesManager from \"../appManagers/apiUpdatesManager\";\r\nimport appGroupCallsManager, { GroupCallConnectionType, GroupCallId, GroupCallOutputSource } from \"../appManagers/appGroupCallsManager\";\r\nimport appPeersManager from \"../appManagers/appPeersManager\";\r\nimport { logger } from \"../logger\";\r\nimport apiManager from \"../mtproto/mtprotoworker\";\r\nimport { NULL_PEER_ID } from \"../mtproto/mtproto_config\";\r\nimport rootScope from \"../rootScope\";\r\nimport CallInstanceBase, { TryAddTrackOptions } from \"./callInstanceBase\";\r\nimport GroupCallConnectionInstance from \"./groupCallConnectionInstance\";\r\nimport GROUP_CALL_STATE from \"./groupCallState\";\r\nimport getScreenConstraints from \"./helpers/getScreenConstraints\";\r\nimport getScreenStream from \"./helpers/getScreenStream\";\r\nimport getStream from \"./helpers/getStream\";\r\nimport getVideoConstraints from \"./helpers/getVideoConstraints\";\r\nimport stopTrack from \"./helpers/stopTrack\";\r\nimport localConferenceDescription from \"./localConferenceDescription\";\r\nimport { WebRTCLineType } from \"./sdpBuilder\";\r\nimport StreamManager from \"./streamManager\";\r\nimport { Ssrc } from \"./types\";\r\n\r\nexport default class GroupCallInstance extends CallInstanceBase<{\r\n  state: (state: GROUP_CALL_STATE) => void,\r\n  pinned: (source?: GroupCallOutputSource) => void,\r\n}> {\r\n  public id: GroupCallId;\r\n  public chatId: ChatId;\r\n  public handleUpdateGroupCallParticipants: boolean;\r\n  public updatingSdp: boolean;\r\n  public isSpeakingMap: Map<any, any>;\r\n  public connections: {[k in GroupCallConnectionType]?: GroupCallConnectionInstance};\r\n  public groupCall: GroupCall;\r\n  public participant: GroupCallParticipant;\r\n  \r\n  // will be set with negotiation\r\n  public joined: boolean;\r\n  \r\n  private pinnedSources: Array<GroupCallOutputSource>;\r\n  private participantsSsrcs: Map<PeerId, Ssrc[]>;\r\n  private hadAutoPinnedSources: Set<GroupCallOutputSource>;\r\n  private dispatchPinnedThrottled: () => void;\r\n  private startVideoSharingPromise: Promise<void>;\r\n  private startScreenSharingPromise: Promise<void>;\r\n\r\n  constructor(options: {\r\n    id: GroupCallInstance['id'],\r\n    chatId: GroupCallInstance['chatId'],\r\n    isSpeakingMap?: GroupCallInstance['isSpeakingMap'],\r\n    connections?: GroupCallInstance['connections']\r\n  }) {\r\n    super();\r\n\r\n    safeAssign(this, options);\r\n\r\n    if(!this.log) {\r\n      this.log = logger('GROUP-CALL');\r\n    }\r\n\r\n    if(!this.connections) {\r\n      this.connections = {};\r\n    }\r\n\r\n    if(!this.isSpeakingMap) {\r\n      this.isSpeakingMap = new Map();\r\n    }\r\n\r\n    this.pinnedSources = [];\r\n    this.participantsSsrcs = new Map();\r\n    this.hadAutoPinnedSources = new Set();\r\n    this.dispatchPinnedThrottled = throttle(() => {\r\n      this.dispatchEvent('pinned', this.pinnedSource);\r\n    }, 0, false);\r\n\r\n    this.addEventListener('state', (state) => {\r\n      if(state === GROUP_CALL_STATE.CLOSED) {\r\n        this.cleanup();\r\n      }\r\n    });\r\n  }\r\n\r\n  get connectionState() {\r\n    return this.connections.main.connection.iceConnectionState;\r\n  }\r\n\r\n  get state() {\r\n    const {connectionState} = this;\r\n    if(connectionState === 'closed') {\r\n      return GROUP_CALL_STATE.CLOSED;\r\n    } else if(connectionState !== 'connected' && (!IS_SAFARI || connectionState !== 'completed')) {\r\n      return GROUP_CALL_STATE.CONNECTING;\r\n    } else {\r\n      const {participant} = this;\r\n      if(!participant.pFlags.can_self_unmute) {\r\n        return GROUP_CALL_STATE.MUTED_BY_ADMIN;\r\n      } else if(participant.pFlags.muted) {\r\n        return GROUP_CALL_STATE.MUTED;\r\n      } else {\r\n        return GROUP_CALL_STATE.UNMUTED;\r\n      }\r\n    }\r\n  }\r\n\r\n  get participants() {\r\n    return appGroupCallsManager.getCachedParticipants(this.id);\r\n  }\r\n\r\n  get isSharingScreen() {\r\n    return !!this.connections.presentation;\r\n  }\r\n\r\n  get pinnedSource() {\r\n    return this.pinnedSources[this.pinnedSources.length - 1];\r\n  }\r\n\r\n  public get isMuted() {\r\n    return this.state !== GROUP_CALL_STATE.UNMUTED;\r\n  }\r\n\r\n  public get isClosing() {\r\n    const {state} = this;\r\n    return state === GROUP_CALL_STATE.CLOSED;\r\n  }\r\n\r\n  public get streamManager(): StreamManager {\r\n    return this.connections.main.streamManager;\r\n  }\r\n\r\n  public get description(): localConferenceDescription {\r\n    return this.connections.main.description;\r\n  }\r\n\r\n  public pinSource(source: GroupCallOutputSource) {\r\n    indexOfAndSplice(this.pinnedSources, source);\r\n    this.pinnedSources.push(source);\r\n    this.dispatchPinnedThrottled();\r\n  }\r\n\r\n  public unpinSource(source: GroupCallOutputSource) {\r\n    this.hadAutoPinnedSources.delete(source);\r\n    indexOfAndSplice(this.pinnedSources, source);\r\n    this.dispatchPinnedThrottled();\r\n  }\r\n\r\n  public unpinAll() {\r\n    this.pinnedSources.length = 0;\r\n    this.dispatchPinnedThrottled();\r\n  }\r\n\r\n  public getParticipantByPeerId(peerId: PeerId) {\r\n    return NULL_PEER_ID === peerId ? this.participant : this.participants.get(peerId);\r\n  }\r\n\r\n  public toggleMuted() {\r\n    return this.requestAudioSource(true).then(() => appGroupCallsManager.toggleMuted());\r\n  }\r\n\r\n  public getElement(endpoint: GroupCallOutputSource) {\r\n    return super.getElement(endpoint);\r\n  }\r\n\r\n  public getVideoElementFromParticipantByType(participant: GroupCallParticipant, type: 'video' | 'presentation') {\r\n    let source: GroupCallOutputSource;\r\n    if(participant.pFlags.self) {\r\n      const connectionType: GroupCallConnectionType = type === 'video' ? 'main' : 'presentation';\r\n      source = connectionType;\r\n    } else {\r\n      const codec = participant[type];\r\n      source = codec.source_groups[0].sources[0];\r\n    }\r\n\r\n    const element = this.getElement(source) as HTMLVideoElement;\r\n    if(!element) return;\r\n\r\n    const clone = element.cloneNode() as typeof element;\r\n    clone.srcObject = element.srcObject;\r\n    return {video: clone, source};\r\n  }\r\n\r\n  public createConnectionInstance(options: {\r\n    streamManager: StreamManager,\r\n    type: GroupCallConnectionType,\r\n    options: GroupCallConnectionInstance['options'],\r\n  }) {\r\n    return this.connections[options.type] = new GroupCallConnectionInstance({\r\n      groupCall: this,\r\n      log: this.log.bindPrefix(options.type),\r\n      ...options\r\n    });\r\n  }\r\n\r\n  public changeRaiseHand(raise: boolean) {\r\n    return appGroupCallsManager.editParticipant(this.id, this.participant, {raiseHand: raise});\r\n  }\r\n\r\n  public async startScreenSharingInternal() {\r\n    try {\r\n      const type: GroupCallConnectionType = 'presentation';\r\n\r\n      const stream = await getScreenStream(getScreenConstraints());\r\n      const streamManager = new StreamManager();\r\n      \r\n      const connectionInstance = this.createConnectionInstance({\r\n        streamManager,\r\n        type,\r\n        options: {\r\n          type\r\n        }\r\n      });\r\n      \r\n      const connection = connectionInstance.createPeerConnection();\r\n      connection.addEventListener('negotiationneeded', () => {\r\n        connectionInstance.negotiate();\r\n      });\r\n\r\n      stream.getVideoTracks()[0].addEventListener('ended', () => {\r\n        if(this.connections.presentation) { // maybe user has stopped screensharing through browser's ui\r\n          this.stopScreenSharing();\r\n        }\r\n      }, {once: true});\r\n      \r\n      connectionInstance.createDescription();\r\n      connectionInstance.addInputVideoStream(stream);\r\n    } catch(err) {\r\n      this.log.error('start screen sharing error', err);\r\n    }\r\n  }\r\n\r\n  public startScreenSharing() {\r\n    return this.startScreenSharingPromise || (this.startScreenSharingPromise = this.startScreenSharingInternal().finally(() => {\r\n      this.startScreenSharingPromise = undefined;\r\n    }));\r\n  }\r\n\r\n  public stopScreenSharing() {\r\n    const connectionInstance = this.connections.presentation;\r\n    if(!connectionInstance) {\r\n      return Promise.resolve();\r\n    }\r\n\r\n    delete this.connections.presentation;\r\n    this.unpinSource('presentation');\r\n    connectionInstance.closeConnectionAndStream(true);\r\n\r\n    delete this.participant.presentation;\r\n    appGroupCallsManager.saveApiParticipant(this.id, this.participant);\r\n\r\n    return apiManager.invokeApi('phone.leaveGroupCallPresentation', {\r\n      call: appGroupCallsManager.getGroupCallInput(this.id)\r\n    }).then(updates => {\r\n      apiUpdatesManager.processUpdateMessage(updates);\r\n    });\r\n  }\r\n\r\n  public toggleScreenSharing() {\r\n    if(this.isSharingScreen) {\r\n      return this.stopScreenSharing();\r\n    } else {\r\n      return this.startScreenSharing();\r\n    }\r\n  }\r\n\r\n  public async startVideoSharingInternal() {\r\n    const constraints: MediaStreamConstraints = {\r\n      video: getVideoConstraints()\r\n    };\r\n\r\n    try {\r\n      const stream = await getStream(constraints, false);\r\n      const connectionInstance = this.connections.main;\r\n      connectionInstance.addInputVideoStream(stream);\r\n\r\n      await appGroupCallsManager.editParticipant(this.id, this.participant, {\r\n        videoPaused: false,\r\n        videoStopped: false\r\n      });\r\n    } catch(err) {\r\n      this.log.error('startVideoSharing error', err, constraints);\r\n    }\r\n  }\r\n\r\n  public startVideoSharing() {\r\n    return this.startVideoSharingPromise || (this.startVideoSharingPromise = this.startVideoSharingInternal().finally(() => {\r\n      this.startVideoSharingPromise = undefined;\r\n    }));\r\n  }\r\n\r\n  public async stopVideoSharing() {\r\n    const connectionInstance = this.connections.main;\r\n    const track = connectionInstance.streamManager.inputStream.getVideoTracks()[0];\r\n    if(!track) {\r\n      return;\r\n    }\r\n\r\n    stopTrack(track);\r\n    connectionInstance.streamManager.appendToConference(connectionInstance.description); // clear sender track\r\n\r\n    await appGroupCallsManager.editParticipant(this.id, this.participant, {\r\n      videoStopped: true\r\n    });\r\n  }\r\n\r\n  public toggleVideoSharing() {\r\n    if(this.isSharingVideo) {\r\n      return this.stopVideoSharing();\r\n    } else {\r\n      return this.startVideoSharing();\r\n    }\r\n  }\r\n\r\n  public async hangUp(discard = false, rejoin = false, isDiscarded = false) {\r\n    for(const type in this.connections) {\r\n      const connection = this.connections[type as GroupCallConnectionType];\r\n      connection.closeConnectionAndStream(!rejoin);\r\n    }\r\n\r\n    this.dispatchEvent('state', this.state);\r\n\r\n    if(isDiscarded) {\r\n      return;\r\n    }\r\n    \r\n    if(!rejoin) {\r\n      let promise: Promise<Updates>;\r\n      const groupCallInput = appGroupCallsManager.getGroupCallInput(this.id);\r\n\r\n      if(discard) {\r\n        this.log(`[api] discardGroupCall id=${this.id}`);\r\n        promise = apiManager.invokeApi('phone.discardGroupCall', {\r\n          call: groupCallInput\r\n        });\r\n      } else if(this.joined) {\r\n        this.log(`[api] leaveGroupCall id=${this.id}`);\r\n        const connectionInstance = this.connections.main;\r\n        promise = apiManager.invokeApi('phone.leaveGroupCall', {\r\n          call: groupCallInput,\r\n          source: connectionInstance.sources.audio.source\r\n        });\r\n      } else {\r\n        this.log(`[api] id=${this.id} payload=null`);\r\n        promise = apiManager.invokeApi('phone.joinGroupCall', {\r\n          call: groupCallInput,\r\n          join_as: {_: 'inputPeerSelf'},\r\n          muted: true,\r\n          video_stopped: true,\r\n          params: {\r\n            _: 'dataJSON',\r\n            data: ''\r\n          }\r\n        });\r\n      }\r\n\r\n      const updates = await promise;\r\n      apiUpdatesManager.processUpdateMessage(updates);\r\n    }\r\n  }\r\n\r\n  public tryAddTrack(options: Omit<TryAddTrackOptions, 'streamManager'>) {\r\n    const {description} = this;\r\n    const source = super.tryAddTrack(options);\r\n    \r\n    if(options.type === 'output') {\r\n      const entry = description.getEntryBySource(+source);\r\n      const participant = this.participants.get(entry.peerId);\r\n      if(participant) {\r\n        rootScope.dispatchEvent('group_call_participant', {groupCallId: this.id, participant});\r\n      }\r\n    }\r\n\r\n    return source;\r\n  }\r\n\r\n  public onParticipantUpdate(participant: GroupCallParticipant, doNotDispatchParticipantUpdate?: PeerId) {\r\n    const connectionInstance = this.connections.main;\r\n    const {connection, description} = connectionInstance;\r\n\r\n    const peerId = appPeersManager.getPeerId(participant.peer);\r\n    const hasLeft = !!participant.pFlags.left;\r\n    const oldSsrcs = this.participantsSsrcs.get(peerId) || [];\r\n\r\n    if(participant.presentation && !hasLeft) {\r\n      const {source} = appGroupCallsManager.makeSsrcFromParticipant(participant, 'video', participant.presentation.source_groups, participant.presentation.endpoint);\r\n      if(!this.hadAutoPinnedSources.has(source)) {\r\n        this.hadAutoPinnedSources.add(source);\r\n        this.pinSource(participant.pFlags.self ? 'presentation' : source);\r\n      }\r\n    }\r\n\r\n    if(participant.pFlags.self) {\r\n      this.participant = participant;\r\n\r\n      if(connectionInstance.sources.audio.source !== participant.source) {\r\n        this.hangUp();\r\n      }\r\n\r\n      let mute = false;\r\n      if(!participant.pFlags.can_self_unmute) {\r\n        this.stopScreenSharing();\r\n        this.stopVideoSharing();\r\n        mute = true;\r\n      } else if(participant.pFlags.muted) {\r\n        mute = true;\r\n      }\r\n\r\n      if(mute) {\r\n        this.setMuted(true);\r\n      }\r\n\r\n      if(doNotDispatchParticipantUpdate !== peerId) {\r\n        this.dispatchEvent('state', this.state);\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    const ssrcs = hasLeft ? [] : appGroupCallsManager.makeSsrcsFromParticipant(participant);\r\n\r\n    if(!hasLeft) {\r\n      this.participantsSsrcs.set(peerId, ssrcs);\r\n    } else {\r\n      this.participantsSsrcs.delete(peerId);\r\n    }\r\n\r\n    // const TEST_OLD = false;\r\n\r\n    const modifiedTypes: Set<WebRTCLineType> = new Set();\r\n    oldSsrcs.forEach(oldSsrc => {\r\n      const oldSource = oldSsrc.source;\r\n      const newSsrc = ssrcs.find(ssrc => ssrc.source === oldSource);\r\n      if(!newSsrc) {\r\n        this.unpinSource(oldSource);\r\n\r\n        const oldEntry = description.getEntryBySource(oldSource);\r\n        if(oldEntry && oldEntry.direction !== 'inactive') {\r\n          oldEntry.setDirection('inactive');\r\n          modifiedTypes.add(oldEntry.type);\r\n        }\r\n      }\r\n    });\r\n\r\n    ssrcs.forEach(ssrc => {\r\n      let entry = description.getEntryBySource(ssrc.source);\r\n      if(entry) {\r\n        if(entry.direction === 'inactive') {\r\n          entry.setDirection(entry.originalDirection);\r\n          modifiedTypes.add(entry.type);\r\n        }\r\n\r\n        return;\r\n      }\r\n\r\n      entry = description.createEntry(ssrc.type);\r\n      description.setEntrySource(entry, ssrc.sourceGroups || ssrc.source);\r\n      description.setEntryPeerId(entry, peerId);\r\n\r\n      // if(TEST_OLD) {\r\n      //   description.bundleMids.push(entry.mid);\r\n      //   entry.setDirection('recvonly');\r\n      // } else {\r\n        ssrc.type === 'video' && entry.setEndpoint(ssrc.endpoint);\r\n        entry.createTransceiver(connection, {direction: 'recvonly'});\r\n      // }\r\n\r\n      modifiedTypes.add(entry.type);\r\n    });\r\n\r\n    /* if(TEST_OLD) {\r\n      this.setRemoteOffer({\r\n        connection,\r\n        description,\r\n        ssrcs\r\n      });\r\n    } else  */if(modifiedTypes.size) {\r\n      if(modifiedTypes.has('video')) {\r\n        connectionInstance.updateConstraints = true;\r\n      }\r\n\r\n      connectionInstance.negotiateThrottled();\r\n    }\r\n  }\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport safeAssign from \"../../helpers/object/safeAssign\";\r\nimport { logger } from \"../logger\";\r\nimport createDataChannel from \"./helpers/createDataChannel\";\r\nimport createPeerConnection from \"./helpers/createPeerConnection\";\r\nimport LocalConferenceDescription from \"./localConferenceDescription\";\r\nimport StreamManager from \"./streamManager\";\r\nimport { Ssrc } from \"./types\";\r\n\r\nexport type CallConnectionInstanceOptions = {\r\n  streamManager: StreamManager,\r\n  connection?: RTCPeerConnection,\r\n  log?: ReturnType<typeof logger>\r\n};\r\n\r\nexport default abstract class CallConnectionInstanceBase {\r\n  public connection: RTCPeerConnection;\r\n  public streamManager: StreamManager;\r\n  public dataChannel: RTCDataChannel;\r\n  public description: LocalConferenceDescription;\r\n  public sources: {\r\n    audio: Ssrc,\r\n    video?: Ssrc,\r\n  };\r\n  protected negotiating: Promise<void>;\r\n  protected log: ReturnType<typeof logger>;\r\n\r\n  constructor(options: CallConnectionInstanceOptions) {\r\n    safeAssign(this, options);\r\n\r\n    if(!this.log) {\r\n      this.log = this.connection?.log || logger('CALL-CONNECTION-BASE');\r\n    }\r\n\r\n    this.sources = {} as any;\r\n  }\r\n\r\n  public createPeerConnection(config?: RTCConfiguration) {\r\n    return this.connection || (this.connection = createPeerConnection(config, this.log.bindPrefix('connection')).connection);\r\n  }\r\n\r\n  public createDataChannel(dict?: RTCDataChannelInit) {\r\n    return this.dataChannel || (this.dataChannel = createDataChannel(this.connection, dict, this.log.bindPrefix('data')));\r\n  }\r\n\r\n  public createDescription() {\r\n    return this.description || (this.description = new LocalConferenceDescription(this.connection));\r\n  }\r\n\r\n  public appendStreamToConference() {\r\n    return this.streamManager.appendToConference(this.description);\r\n  }\r\n\r\n  public closeConnection() {\r\n    const {connection} = this;\r\n    if(!connection) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      connection.log('close');\r\n      connection.close();\r\n    } catch(e) {\r\n      this.log.error(e);\r\n    }\r\n  }\r\n\r\n  public closeConnectionAndStream(stopStream: boolean) {\r\n    this.closeConnection();\r\n    stopStream && this.streamManager.stop();\r\n  }\r\n\r\n  protected abstract negotiateInternal(): CallConnectionInstanceBase['negotiating'];\r\n\r\n  public negotiate() {\r\n    let promise = this.negotiating;\r\n    if(promise) {\r\n      return promise;\r\n    }\r\n\r\n    return this.negotiating = this.negotiateInternal().finally(() => {\r\n      this.negotiating = undefined;\r\n    });\r\n  }\r\n\r\n  public sendDataChannelData(data: any) {\r\n    if(this.dataChannel.readyState !== 'open') {\r\n      return;\r\n    }\r\n\r\n    this.dataChannel.send(JSON.stringify(data));\r\n  }\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport { Logger, logger } from \"../../logger\";\r\n\r\nexport default function createPeerConnection(config: RTCConfiguration, log?: Logger) {\r\n  if(!log) {\r\n    log = logger('RTCPeerConnection');\r\n  }\r\n\r\n  log('constructor');\r\n\r\n  // @ts-ignore\r\n  const connection = new RTCPeerConnection(config);\r\n  connection.addEventListener('track', (event) => {\r\n    log('ontrack', event);\r\n  });\r\n  connection.addEventListener('signalingstatechange', () => {\r\n    log('onsignalingstatechange', connection.signalingState);\r\n  });\r\n  connection.addEventListener('connectionstatechange', () => {\r\n    log('onconnectionstatechange', connection.connectionState);\r\n  });\r\n  connection.addEventListener('negotiationneeded', () => { // * will be fired every time input device changes\r\n    log('onnegotiationneeded', connection.signalingState);\r\n  });\r\n  connection.addEventListener('icecandidate', (event) => {\r\n    log('onicecandidate', event);\r\n  });\r\n  connection.addEventListener('iceconnectionstatechange', () => {\r\n    log('oniceconnectionstatechange', connection.iceConnectionState);\r\n  });\r\n  connection.addEventListener('datachannel', () => {\r\n    log('ondatachannel');\r\n  });\r\n\r\n  connection.log = log;\r\n\r\n  return {connection};\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport { Logger, logger } from \"../../logger\";\r\n\r\nexport default function createDataChannel(connection: RTCPeerConnection, dict?: RTCDataChannelInit, log?: Logger) {\r\n  // return;\r\n\r\n  if(!log) {\r\n    log = logger('RTCDataChannel');\r\n  }\r\n\r\n  const channel = connection.createDataChannel('data', dict);\r\n\r\n  channel.addEventListener('message', (e) => {\r\n    log('onmessage', e);\r\n  });\r\n  channel.addEventListener('open', () => {\r\n    log('onopen');\r\n  });\r\n  channel.addEventListener('close', () => {\r\n    log('onclose');\r\n  });\r\n\r\n  channel.log = log;\r\n\r\n  return channel;\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport I18n, { i18n, join, LangPackKey } from \"../lib/langPack\";\r\nimport formatDuration, { DurationType } from \"./formatDuration\";\r\n\r\nconst CALL_DURATION_LANG_KEYS: {[type in DurationType]: LangPackKey} = {\r\n  s: 'Seconds',\r\n  m: 'Minutes',\r\n  h: 'Hours',\r\n  d: 'Days',\r\n  w: 'Weeks'\r\n};\r\nexport default function formatCallDuration(duration: number, plain?: boolean) {\r\n  const a = formatDuration(duration, 2);\r\n  if(plain) {\r\n    const strings = a.map(d => I18n.format(CALL_DURATION_LANG_KEYS[d.type], true, [d.duration]));\r\n    return join(strings, false, plain);\r\n  }\r\n\r\n  const elements = a.map(d => i18n(CALL_DURATION_LANG_KEYS[d.type], [d.duration]));\r\n\r\n  const fragment = document.createElement('span');\r\n  fragment.append(...join(elements, false));\r\n\r\n  return fragment;\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nexport type DurationType = 's' | 'm' | 'h' | 'd' | 'w';\r\nexport default function formatDuration(duration: number, showLast = 2) {\r\n  if(!duration) {\r\n    duration = 1;\r\n  }\r\n\r\n  let d: {duration: number, type: DurationType}[] = [];\r\n  const p = [\r\n    {m: 1, t: 's'},\r\n    {m: 60, t: 'm'}, \r\n    {m: 60, t: 'h'}, \r\n    {m: 24, t: 'd'}, \r\n    {m: 7, t: 'w'}\r\n  ] as Array<{m?: number, t: DurationType}>\r\n  const s = 1;\r\n  let t = s;\r\n  p.forEach((o, idx) => {\r\n    t *= o.m;\r\n\r\n    if(duration < t) {\r\n      return;\r\n    }\r\n\r\n    const modulus = p[idx === (p.length - 1) ? idx : idx + 1].m;\r\n    d.push({\r\n      duration: (duration / t % modulus | 0),\r\n      type: o.t\r\n    });\r\n  });\r\n\r\n  const out = d.slice(-showLast).reverse();\r\n  for(let i = out.length - 1; i >= 0; --i) {\r\n    if(out[i].duration === 0) {\r\n      out.splice(i, 1);\r\n    }\r\n  }\r\n  \r\n  return out;\r\n}\r\n","import { IS_APPLE_MOBILE, IS_SAFARI } from \"./userAgent\";\r\n\r\n// mov is not supported in Chrome on macOS\r\nconst IS_MOV_SUPPORTED = !!document.createElement('video').canPlayType('video/quicktime') || IS_SAFARI || IS_APPLE_MOBILE;\r\n\r\nexport default IS_MOV_SUPPORTED;\r\n","import IS_MOV_SUPPORTED from \"./movSupport\";\r\n\r\nconst VIDEO_MIME_TYPES_SUPPORTED = new Set([\r\n  'image/gif', // have to display it as video\r\n  'video/mp4',\r\n  'video/webm'\r\n]);\r\n\r\nif(IS_MOV_SUPPORTED) {\r\n  VIDEO_MIME_TYPES_SUPPORTED.add('video/quicktime');\r\n}\r\n\r\nexport default VIDEO_MIME_TYPES_SUPPORTED;\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport getScreenStream from \"./getScreenStream\";\r\nimport getStream from \"./getStream\";\r\n\r\n/**\r\n * ! Use multiple constraints together only with first invoke\r\n */\r\nexport default function getStreamCached() {\r\n  const _cache: {\r\n    main: Partial<{\r\n      audio: Promise<MediaStream>,\r\n      video: Promise<MediaStream>\r\n    }>,\r\n    screen: Partial<{\r\n      audio: Promise<MediaStream>,\r\n      video: Promise<MediaStream>\r\n    }>\r\n  } = {\r\n    main: {},\r\n    screen: {}\r\n  };\r\n\r\n  return async(options: {\r\n    isScreen: true, \r\n    constraints: DisplayMediaStreamConstraints,\r\n  } | {\r\n    isScreen?: false,\r\n    constraints: MediaStreamConstraints, \r\n    muted: boolean\r\n  }) => {\r\n    const {isScreen, constraints} = options;\r\n    const cache = _cache[isScreen ? 'screen' : 'main'];\r\n    let promise: Promise<MediaStream> = cache[constraints.audio ? 'audio' : 'video'];\r\n\r\n    if(!promise) {\r\n      promise = (isScreen ? getScreenStream : getStream)(constraints, (options as any).muted);\r\n      if(constraints.audio && !cache.audio) cache.audio = promise.finally(() => cache.audio = undefined);\r\n      if(constraints.video && !cache.video) cache.video = promise.finally(() => cache.video = undefined);\r\n    }\r\n\r\n    try {\r\n      return await promise;\r\n      /* let out: Partial<{\r\n        audio: MediaStream,\r\n        video: MediaStream\r\n      }> = {};\r\n\r\n      await Promise.all([\r\n        constraints.audio && cache.audio.then(stream => out.audio = stream),\r\n        constraints.video && cache.video.then(stream => out.video = stream)\r\n      ].filter(Boolean));\r\n\r\n      return out; */\r\n    } catch(err) {\r\n      throw err;\r\n    }\r\n  };\r\n}\r\n\r\n(window as any).getStreamCached = getStreamCached;\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport EventListenerBase, { EventListenerListeners } from \"../../helpers/eventListenerBase\";\r\nimport noop from \"../../helpers/noop\";\r\nimport { logger } from \"../logger\";\r\nimport getAudioConstraints from \"./helpers/getAudioConstraints\";\r\nimport getScreenConstraints from \"./helpers/getScreenConstraints\";\r\nimport getStreamCached from \"./helpers/getStreamCached\";\r\nimport getVideoConstraints from \"./helpers/getVideoConstraints\";\r\nimport stopTrack from \"./helpers/stopTrack\";\r\nimport LocalConferenceDescription from \"./localConferenceDescription\";\r\nimport StreamManager, { StreamItem } from \"./streamManager\";\r\n\r\nexport type TryAddTrackOptions = {\r\n  stream: MediaStream, \r\n  track: MediaStreamTrack, \r\n  type: StreamItem['type'], \r\n  source?: string\r\n};\r\n\r\nexport default abstract class CallInstanceBase<E extends EventListenerListeners> extends EventListenerBase<E> {\r\n  protected log: ReturnType<typeof logger>;\r\n  protected outputDeviceId: string;\r\n\r\n  protected player: HTMLElement;\r\n  protected elements: Map<string, HTMLMediaElement>;\r\n\r\n  protected audio: HTMLAudioElement;\r\n  // protected fixedSafariAudio: boolean;\r\n\r\n  protected getStream: ReturnType<typeof getStreamCached>;\r\n\r\n  constructor() {\r\n    super(false);\r\n\r\n    const player = this.player = document.createElement('div');\r\n    player.classList.add('call-player');\r\n    player.style.display = 'none';\r\n    document.body.append(player);\r\n\r\n    this.elements = new Map();\r\n\r\n    // possible Safari fix\r\n    const audio = this.audio = new Audio();\r\n    audio.autoplay = true;\r\n    audio.volume = 1.0;\r\n    this.player.append(audio);\r\n    this.elements.set('audio', audio);\r\n\r\n    this.fixSafariAudio();\r\n\r\n    this.getStream = getStreamCached();\r\n  }\r\n\r\n  public get isSharingAudio() {\r\n    return !!this.streamManager.hasInputTrackKind('audio');\r\n  }\r\n\r\n  public get isSharingVideo() {\r\n    return !!this.streamManager.hasInputTrackKind('video');\r\n  }\r\n\r\n  public abstract get isMuted(): boolean;\r\n  public abstract get isClosing(): boolean;\r\n\r\n  public fixSafariAudio() {\r\n    // if(this.fixedSafariAudio) return;\r\n    this.audio.play().catch(noop);\r\n    // this.fixedSafariAudio = true;\r\n  }\r\n\r\n  public requestAudioSource(muted: boolean) {\r\n    return this.requestInputSource(true, false, muted);\r\n  }\r\n\r\n  public requestInputSource(audio: boolean, video: boolean, muted: boolean) {\r\n    const {streamManager} = this;\r\n    if(streamManager) {\r\n      const isAudioGood = !audio || this.isSharingAudio;\r\n      const isVideoGood = !video || this.isSharingVideo;\r\n      if(isAudioGood && isVideoGood) {\r\n        return Promise.resolve();\r\n      }\r\n    }\r\n\r\n    const constraints: MediaStreamConstraints = {\r\n      audio: audio && getAudioConstraints(),\r\n      video: video && getVideoConstraints()\r\n    };\r\n    \r\n    return this.getStream({\r\n      constraints, \r\n      muted\r\n    }).then((stream) => {\r\n      this.onInputStream(stream);\r\n    });\r\n  }\r\n\r\n  public requestScreen() {\r\n    return this.getStream({\r\n      isScreen: true,\r\n      constraints: getScreenConstraints(true)\r\n    }).then((stream) => {\r\n      this.onInputStream(stream);\r\n    });\r\n  }\r\n\r\n  public getElement(endpoint: number | string) {\r\n    return this.elements.get('' + endpoint);\r\n  }\r\n\r\n  public abstract get streamManager(): StreamManager;\r\n  public abstract get description(): LocalConferenceDescription;\r\n  public abstract toggleMuted(): Promise<void>;\r\n\r\n  public cleanup() {\r\n    this.player.textContent = '';\r\n    this.player.remove();\r\n    this.elements.clear();\r\n\r\n    // can have no connectionInstance but streamManager with input stream\r\n    this.streamManager.stop();\r\n\r\n    super.cleanup();\r\n  }\r\n\r\n  public onTrack(event: RTCTrackEvent) {\r\n    this.tryAddTrack({\r\n      stream: event.streams[0], \r\n      track: event.track, \r\n      type: 'output'\r\n    });\r\n  }\r\n\r\n  public saveInputVideoStream(stream: MediaStream, type?: string) {\r\n    const track = stream.getVideoTracks()[0];\r\n    this.tryAddTrack({\r\n      stream, \r\n      track, \r\n      type: 'input', \r\n      source: type || 'main'\r\n    });\r\n  }\r\n  \r\n  public tryAddTrack({stream, track, type, source}: TryAddTrackOptions) {\r\n    if(!source) {\r\n      source = StreamManager.getSource(stream, type);\r\n    }\r\n\r\n    this.log('tryAddTrack', stream, track, type, source);\r\n\r\n    const isOutput = type === 'output';\r\n\r\n    const {player, elements, streamManager} = this;\r\n    \r\n    const tagName = track.kind as StreamItem['kind'];\r\n    const isVideo = tagName === 'video';\r\n\r\n    const elementEndpoint = isVideo ? source : tagName;\r\n    let element = elements.get(elementEndpoint);\r\n\r\n    if(isVideo) {\r\n      track.addEventListener('ended', () => {\r\n        this.log('[track] onended');\r\n        elements.delete(elementEndpoint);\r\n        // element.remove();\r\n      }, {once: true});\r\n    }\r\n    \r\n    if(isOutput) {\r\n      streamManager.addTrack(stream, track, type);\r\n    }\r\n\r\n    const useStream = isVideo ? stream : streamManager.outputStream;\r\n    if(!element) {\r\n      element = document.createElement(tagName);\r\n      element.autoplay = true;\r\n      element.srcObject = useStream;\r\n      element.volume = 1.0;\r\n\r\n      if((element as any).sinkId !== 'undefined') {\r\n        const {outputDeviceId} = this;\r\n        if(outputDeviceId) {\r\n          (element as any).setSinkId(outputDeviceId);\r\n        }\r\n      }\r\n      \r\n      if(!isVideo) {\r\n        player.appendChild(element);\r\n      } else {\r\n        element.setAttribute('playsinline', 'true');\r\n        element.muted = true;\r\n      }\r\n      // audio.play();\r\n\r\n      elements.set(elementEndpoint, element);\r\n    } else {\r\n      if(element.paused) {\r\n        element.play().catch(noop);\r\n      }\r\n\r\n      // ! EVEN IF MEDIASTREAM IS THE SAME NEW TRACK WON'T PLAY WITHOUT REPLACING IT WHEN NEW PARTICIPANT IS ENTERING !\r\n      // if(element.srcObject !== useStream) {\r\n        element.srcObject = useStream;\r\n      // }\r\n    }\r\n\r\n    return source;\r\n  }\r\n\r\n  public setMuted(muted?: boolean) {\r\n    this.streamManager.inputStream.getAudioTracks().forEach((track) => {\r\n      if(track?.kind === 'audio') {\r\n        track.enabled = muted === undefined ? !track.enabled : !muted;\r\n      }\r\n    });\r\n  }\r\n\r\n  protected onInputStream(stream: MediaStream): void {\r\n    if(!this.isClosing) {\r\n      const videoTracks = stream.getVideoTracks();\r\n      if(videoTracks.length) {\r\n        this.saveInputVideoStream(stream, 'main');\r\n      }\r\n\r\n      const {streamManager, description} = this;\r\n      streamManager.addStream(stream, 'input');\r\n      \r\n      if(description) {\r\n        streamManager.appendToConference(description);\r\n      }\r\n    } else { // if call is declined earlier than stream appears\r\n      stream.getTracks().forEach(track => {\r\n        stopTrack(track);\r\n      });\r\n    }\r\n  }\r\n}\r\n","import constraintSupported, { MyMediaTrackSupportedConstraints } from \"../../../environment/constraintSupport\";\r\n\r\nexport default function getAudioConstraints(): MediaTrackConstraints {\r\n  const constraints: MediaTrackConstraints = {\r\n    channelCount: 2\r\n  };\r\n\r\n  const desirable: (keyof MyMediaTrackSupportedConstraints)[] = [\r\n    'noiseSuppression',\r\n    'echoCancellation',\r\n    'autoGainControl'\r\n  ];\r\n\r\n  desirable.forEach(constraint => {\r\n    if(constraintSupported(constraint)) {\r\n      // @ts-ignore\r\n      constraints[constraint] = true;\r\n    }\r\n  });\r\n\r\n  return constraints;\r\n}\r\n","export type MyMediaTrackSupportedConstraints = MediaTrackSupportedConstraints & {\r\n  noiseSuppression?: boolean, \r\n  autoGainControl?: boolean\r\n};\r\n\r\nexport default function constraintSupported(constraint: keyof MyMediaTrackSupportedConstraints) {\r\n  return (!!navigator?.mediaDevices?.getSupportedConstraints() as any as MyMediaTrackSupportedConstraints)[constraint];\r\n}\r\n"],"sourceRoot":""}