{"version":3,"file":"sw.980a7c675f04d81b18e5.chunk.js","mappings":"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","sources":["webpack://tweb/webpack/bootstrap","webpack://tweb/webpack/runtime/define property getters","webpack://tweb/webpack/runtime/hasOwnProperty shorthand","webpack://tweb/webpack/runtime/compat","webpack://tweb/./src/config/modes.ts","webpack://tweb/./src/config/debug.ts","webpack://tweb/./src/environment/ctx.ts","webpack://tweb/./src/environment/userAgent.ts","webpack://tweb/./src/helpers/context.ts","webpack://tweb/./src/helpers/dT.ts","webpack://tweb/./src/lib/logger.ts","webpack://tweb/./src/lib/serviceWorker/cache.ts","webpack://tweb/./src/helpers/schedulers/pause.ts","webpack://tweb/./src/helpers/noop.ts","webpack://tweb/./src/helpers/blob/blobConstruct.ts","webpack://tweb/./src/helpers/blob/blobSafeMimeType.ts","webpack://tweb/./src/lib/fileManager.ts","webpack://tweb/./src/lib/cacheStorage.ts","webpack://tweb/./src/lib/serviceWorker/stream.ts","webpack://tweb/./src/helpers/schedulers/debounce.ts","webpack://tweb/./src/helpers/cancellablePromise.ts","webpack://tweb/./src/helpers/blob/readBlobAsUint8Array.ts","webpack://tweb/./src/helpers/blob/readBlobAsArrayBuffer.ts","webpack://tweb/./src/helpers/blob/readBlobAs.ts","webpack://tweb/./src/helpers/object/deepEqual.ts","webpack://tweb/./src/lib/idb.ts","webpack://tweb/./src/helpers/object/safeAssign.ts","webpack://tweb/./src/lib/serviceWorker/push.ts","webpack://tweb/./src/config/databases/state.ts","webpack://tweb/./src/lib/serviceWorker/index.service.ts","webpack://tweb/./src/lib/serviceWorker/timeout.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","(() => {\n  if (typeof __webpack_require__ !== 'undefined') {\n    var oldGetScript = __webpack_require__.u;\n    var oldLoadScript = __webpack_require__.e;\n    var queryMap = {};\n    var countMap = {};\n    var getRetryDelay = function () {\n      return 3000;\n    };\n    __webpack_require__.u = function (chunkId) {\n      var result = oldGetScript(chunkId);\n      return (\n        result +\n        (queryMap.hasOwnProperty(chunkId) ? '?' + queryMap[chunkId] : '')\n      );\n    };\n    __webpack_require__.e = function (chunkId) {\n      var result = oldLoadScript(chunkId);\n      return result.catch(function (error) {\n        var retries = countMap.hasOwnProperty(chunkId)\n          ? countMap[chunkId]\n          : 999999;\n        if (retries < 1) {\n          var realSrc = oldGetScript(chunkId);\n          error.message =\n            'Loading chunk ' +\n            chunkId +\n            ' failed after 999999 retries.\\n(' +\n            realSrc +\n            ')';\n          error.request = realSrc;\n          throw error;\n        }\n        return new Promise(function (resolve) {\n          var retryAttempt = 999999 - retries + 1;\n          setTimeout(function () {\n            var retryAttemptString = '&retry-attempt=' + retryAttempt;\n            var cacheBust = (function () {\n              return Date.now();\n            })();\n            +retryAttemptString;\n            queryMap[chunkId] = cacheBust;\n            countMap[chunkId] = retries - 1;\n            resolve(__webpack_require__.e(chunkId));\n          }, getRetryDelay(retryAttempt));\n        });\n      });\n    };\n  }\n})();\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n * \n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\nimport type { TransportType } from \"../lib/mtproto/dcConfigurator\";\n\nconst Modes = {\n  test: location.search.indexOf('test=1') > 0/*  || true */,\n  debug: location.search.indexOf('debug=1') > 0,\n  http: false,\n  ssl: true, // location.search.indexOf('ssl=1') > 0 || location.protocol === 'https:' && location.search.indexOf('ssl=0') === -1,\n  multipleConnections: true,\n  asServiceWorker: false,\n  transport: 'websocket' as TransportType\n};\n\n                        \nModes.http = location.search.indexOf('http=1') > 0;\n          \n\n                                       \n                  \n          \n\nif(Modes.http) {\n  Modes.transport = 'https';\n}\n\n                  \n                             \n          \n\nexport default Modes;\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport Modes from \"./modes\";\r\n\r\nexport const DEBUG = (process.env.NODE_ENV !== 'production' || Modes.debug)/*  && false */;\r\nconst ctx: any = typeof(window) !== 'undefined' ? window : self;\r\nexport const MOUNT_CLASS_TO: any = DEBUG || true/*  && false */ ? ctx : {};\r\nexport default DEBUG;\r\n\r\n//let m = DEBUG;\r\n/* if(!DEBUG) {\r\n  ctx.sandpitTurtle = () => {\r\n    //if(!m) {\r\n      for(let i in MOUNT_CLASS_TO) {\r\n        ctx[i] = MOUNT_CLASS_TO[i];\r\n      }\r\n      //m = true;\r\n    //}\r\n  \r\n    //DEBUG = !DEBUG;\r\n  };\r\n} */\r\n\r\n/* export const superDebug = (object: any, key: string) => {\r\n  var d = object[key];\r\n  var beforeStr = '', afterStr = '';\r\n  for(var r of d) {\r\n    beforeStr += r.before.hex + '\\n';\r\n    afterStr += r.after.hex + '\\n';\r\n  }\r\n\r\n  beforeStr = beforeStr.trim();\r\n  afterStr = afterStr.trim();\r\n  //var beforeStr = d.map((r) => r.before.hex).join('\\n');\r\n  //var afterStr = d.map((r) => r.after.hex).join('\\n');\r\n\r\n  var dada = (name: string, str: string) => {\r\n    var a = document.createElement('a');\r\n    a.target = '_blank';\r\n    a.download = name + '.txt';\r\n    a.href = URL.createObjectURL(new Blob([str], {\r\n      type: 'text/plain'\r\n    }));\r\n    document.body.append(a);\r\n    a.click();\r\n  };\r\n\r\n  dada(key + '_' + 'before', beforeStr);\r\n  dada(key + '_' + 'after', afterStr);\r\n}\r\n\r\nMOUNT_CLASS_TO.superDebug = superDebug; */\r\n","const ctx = typeof(window) !== 'undefined' ? window : self;\r\n\r\nexport default ctx;\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport ctx from './ctx';\r\n\r\nexport const USER_AGENT = navigator ? navigator.userAgent : null;\r\nexport const IS_APPLE = navigator.userAgent.search(/OS X|iPhone|iPad|iOS/i) !== -1;\r\nexport const IS_ANDROID = navigator.userAgent.toLowerCase().indexOf('android') !== -1;\r\nexport const IS_CHROMIUM = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);\r\n\r\n// https://stackoverflow.com/a/58065241\r\nexport const IS_APPLE_MOBILE = (/iPad|iPhone|iPod/.test(navigator.platform) ||\r\n  (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1)) &&\r\n  !(ctx as any).MSStream;\r\n\r\nexport const IS_SAFARI = !!('safari' in ctx) || !!(USER_AGENT && (/\\b(iPad|iPhone|iPod)\\b/.test(USER_AGENT) || (!!USER_AGENT.match('Safari') && !USER_AGENT.match('Chrome'))))/*  || true */;\r\nexport const IS_FIREFOX = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;\r\n\r\nexport const IS_MOBILE_SAFARI = IS_SAFARI && IS_APPLE_MOBILE;\r\n\r\nexport const IS_MOBILE = /* screen.width && screen.width < 480 ||  */navigator.maxTouchPoints > 0 && navigator.userAgent.search(/iOS|iPhone OS|Android|BlackBerry|BB10|Series ?[64]0|J2ME|MIDP|opera mini|opera mobi|mobi.+Gecko|Windows Phone/i) != -1;\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\n// в SW может быть сразу две переменных TRUE\r\nexport const IS_SERVICE_WORKER = typeof ServiceWorkerGlobalScope !== 'undefined' && self instanceof ServiceWorkerGlobalScope;\r\nexport const IS_WEB_WORKER = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope && !IS_SERVICE_WORKER;\r\nexport const IS_WORKER = IS_WEB_WORKER || IS_SERVICE_WORKER;\r\n\r\nexport const getWindowClients = () => {\r\n  return (self as any as ServiceWorkerGlobalScope)\r\n  .clients\r\n  .matchAll({includeUncontrolled: false, type: 'window'});\r\n};\r\n\r\nconst postMessage = (listener: WindowClient | DedicatedWorkerGlobalScope, ...args: any[]) => {\r\n  try {\r\n    // @ts-ignore\r\n    listener.postMessage(...args);\r\n  } catch(err) {\r\n    console.error('[worker] postMessage error:', err, args);\r\n  }\r\n};\r\n\r\nconst notifyServiceWorker = (all: boolean, ...args: any[]) => {\r\n  getWindowClients().then((listeners) => {\r\n    if(!listeners.length) {\r\n      //console.trace('no listeners?', self, listeners);\r\n      return;\r\n    }\r\n\r\n    listeners.slice(all ? 0 : -1).forEach((listener) => {\r\n      postMessage(listener, ...args);\r\n    });\r\n  });\r\n};\r\n\r\nconst notifyWorker = (...args: any[]) => {\r\n  postMessage(self as any as DedicatedWorkerGlobalScope, ...args);\r\n};\r\n\r\nconst noop = () => {};\r\n\r\nexport const notifySomeone = IS_SERVICE_WORKER ? notifyServiceWorker.bind(null, false) : (IS_WEB_WORKER ? notifyWorker : noop);\r\nexport const notifyAll = IS_SERVICE_WORKER ? notifyServiceWorker.bind(null, true) : (IS_WEB_WORKER ? notifyWorker : noop);\r\n","const _logTimer = Date.now();\r\nexport default function dT() {\r\n  return '[' + ((Date.now() - _logTimer) / 1000).toFixed(3) + ']';\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport DEBUG from \"../config/debug\";\r\nimport { IS_FIREFOX, IS_SAFARI } from \"../environment/userAgent\";\r\nimport { IS_SERVICE_WORKER, IS_WEB_WORKER } from \"../helpers/context\";\r\nimport dT from \"../helpers/dT\";\r\n\r\nexport enum LogTypes {\r\n  None = 0,\r\n  Error = 1,\r\n  Warn = 2,\r\n  Log = 4,\r\n  Debug = 8\r\n};\r\n\r\nexport const LOG_LEVELS = [LogTypes.None, LogTypes.Error, LogTypes.Warn, LogTypes.Log, LogTypes.Debug];\r\n\r\nconst IS_WEBKIT = IS_SAFARI || IS_FIREFOX;\r\n\r\n// let getCallerFunctionNameFromLine: (line: string) => string;\r\n// if(IS_WEBKIT) {\r\n//   getCallerFunctionNameFromLine = (line) => {\r\n//     const splitted = line.split('@');\r\n//     return splitted[0];\r\n//   };\r\n// } else {\r\n//   getCallerFunctionNameFromLine = (line: string) => {\r\n//     const splitted = line.trim().split(' ');\r\n//     if(splitted.length === 3) {\r\n//       return splitted[1].slice(splitted[1].lastIndexOf('.') + 1);\r\n//     }\r\n//   };\r\n// }\r\n\r\nconst STYLES_SUPPORTED = !IS_WEBKIT;\r\n// const LINE_INDEX = IS_WEBKIT ? 2 : 3;\r\n\r\n// function getCallerFunctionName() {\r\n//   const stack = new Error().stack;\r\n//   const lines = stack.split('\\n');\r\n//   const line = lines[LINE_INDEX] || lines[lines.length - 1];\r\n//   // const match = line.match(/\\.([^\\.]+?)\\s/);\r\n//   // line = match ? match[1] : line.trim();\r\n//   const caller = getCallerFunctionNameFromLine(line) || '<anonymous>';\r\n//   return '[' + caller + ']';\r\n// }\r\n\r\nexport const LOGGER_STYLES = {\r\n  reset: \"\\x1b[0m\",\r\n  bright: \"\\x1b[1m\",\r\n  dim: \"\\x1b[2m\",\r\n  underscore: \"\\x1b[4m\",\r\n  blink: \"\\x1b[5m\",\r\n  reverse: \"\\x1b[7m\",\r\n  hidden: \"\\x1b[8m\",\r\n  // Foreground (text) colors\r\n  fg: {\r\n    black: \"\\x1b[30m\",\r\n    red: \"\\x1b[31m\",\r\n    green: \"\\x1b[32m\",\r\n    yellow: \"\\x1b[33m\",\r\n    blue: \"\\x1b[34m\",\r\n    magenta: \"\\x1b[35m\",\r\n    cyan: \"\\x1b[36m\",\r\n    white: \"\\x1b[37m\"\r\n  },\r\n  // Background colors\r\n  bg: {\r\n    black: \"\\x1b[40m\",\r\n    red: \"\\x1b[41m\",\r\n    green: \"\\x1b[42m\",\r\n    yellow: \"\\x1b[43m\",\r\n    blue: \"\\x1b[44m\",\r\n    magenta: \"\\x1b[45m\",\r\n    cyan: \"\\x1b[46m\",\r\n    white: \"\\x1b[47m\"\r\n  }\r\n};\r\n\r\nexport type Logger = {\r\n  (...args: any[]): void;\r\n  warn(...args: any[]): void;\r\n  info(...args: any[]): void;\r\n  error(...args: any[]): void;\r\n  trace(...args: any[]): void;\r\n  debug(...args: any[]): void;\r\n  assert(...args: any[]): void;\r\n  // log(...args: any[]): void;\r\n  group(...args: any[]): void;\r\n  groupCollapsed(...args: any[]): void;\r\n  groupEnd(...args: any[]): void;\r\n  setPrefix(newPrefix: string): void;\r\n  setLevel(level: 0 | 1 | 2 | 3 | 4): void;\r\n  bindPrefix(prefix: string): Logger;\r\n};\r\n\r\nconst methods: ['debug' | 'info' | 'warn' | 'error' | 'assert' | 'trace'/*  | 'log' */ | 'group' | 'groupCollapsed' | 'groupEnd', LogTypes][] = [\r\n  [\"debug\", LogTypes.Debug], \r\n  [\"info\", LogTypes.Log], \r\n  [\"warn\", LogTypes.Warn], \r\n  [\"error\", LogTypes.Error], \r\n  [\"assert\", LogTypes.Error],\r\n  [\"trace\", LogTypes.Log],\r\n  [\"group\", LogTypes.Log],\r\n  [\"groupCollapsed\", LogTypes.Log],\r\n  [\"groupEnd\", LogTypes.Log]\r\n  // [\"log\", LogTypes.Log]\r\n];\r\n\r\nexport function logger(prefix: string, type: LogTypes = LogTypes.Log | LogTypes.Warn | LogTypes.Error, ignoreDebugReset = false, style = ''): Logger {\r\n  let originalPrefix: string;\r\n  if(!DEBUG && !ignoreDebugReset/*  || true */) {\r\n    type = LogTypes.Error;\r\n  }\r\n\r\n  if(!STYLES_SUPPORTED) {\r\n    style = '';\r\n  } else if(!style) {\r\n    if(IS_SERVICE_WORKER) style = LOGGER_STYLES.fg.yellow;\r\n    else if(IS_WEB_WORKER) style = LOGGER_STYLES.fg.cyan;\r\n  }\r\n\r\n  let originalStyle = style;\r\n  if(style) style = `%s ${style}%s`;\r\n  else style = '%s';\r\n\r\n  //level = LogLevels.log | LogLevels.warn | LogLevels.error | LogLevels.debug\r\n\r\n  const log: Logger = function(...args: any[]) {\r\n    return type & LogTypes.Log && console.log(style, dT(), prefix, /* getCallerFunctionName(), */ ...args);\r\n  } as any;\r\n\r\n  methods.forEach(([method, logType]) => {\r\n    log[method] = function(...args: any[]) {\r\n      return type & logType && console[method](style, dT(), prefix, /* getCallerFunctionName(), */ ...args);\r\n    };\r\n  });\r\n\r\n  log.setPrefix = function(newPrefix: string) {\r\n    originalPrefix = newPrefix;\r\n    prefix = '[' + newPrefix + ']';\r\n  };\r\n\r\n  log.setPrefix(prefix);\r\n\r\n  log.setLevel = function(level: 0 | 1 | 2 | 3 | 4) {\r\n    type = LOG_LEVELS.slice(0, level + 1).reduce((acc, v) => acc | v, 0) as any;\r\n  };\r\n\r\n  log.bindPrefix = function(prefix: string) {\r\n    return logger(`${originalPrefix}] [${prefix}`, type, ignoreDebugReset, originalStyle);\r\n  };\r\n\r\n  return log;\r\n};\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport pause from \"../../helpers/schedulers/pause\";\r\n\r\nconst ctx = self as any as ServiceWorkerGlobalScope;\r\nexport const CACHE_ASSETS_NAME = 'cachedAssets';\r\n\r\nfunction isCorrectResponse(response: Response) {\r\n  return response.ok && response.status === 200;\r\n}\r\n\r\nfunction timeoutRace<T extends Promise<any>>(promise: T) {\r\n  return Promise.race([\r\n    promise,\r\n    pause(10000).then(() => Promise.reject())\r\n  ]);\r\n}\r\n\r\nexport async function requestCache(event: FetchEvent) {\r\n  try {\r\n    // const cache = await ctx.caches.open(CACHE_ASSETS_NAME);\r\n    const cache = await timeoutRace(ctx.caches.open(CACHE_ASSETS_NAME));\r\n    const file = await timeoutRace(cache.match(event.request, {ignoreVary: true}));\r\n  \r\n    if(file && isCorrectResponse(file)) {\r\n      return file;\r\n    }\r\n  \r\n    const headers: HeadersInit = {'Vary': '*'};\r\n    let response = await fetch(event.request, {headers});\r\n    if(isCorrectResponse(response)) {\r\n      cache.put(event.request, response.clone());\r\n    } else if(response.status === 304) { // possible fix for 304 in Safari\r\n      const url = event.request.url.replace(/\\?.+$/, '') + '?' + (Math.random() * 100000 | 0);\r\n      response = await fetch(url, {headers});\r\n      if(isCorrectResponse(response)) {\r\n        cache.put(event.request, response.clone());\r\n      }\r\n    }\r\n  \r\n    return response;\r\n  } catch(err) {\r\n    return fetch(event.request);\r\n  }\r\n}\r\n","export default function pause(ms: number) {\r\n  return new Promise<void>((resolve) => {\r\n    setTimeout(resolve, ms);\r\n  });\r\n}\r\n","export default function noop() {}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n * \r\n * Originally from:\r\n * https://github.com/zhukov/webogram\r\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\r\n * https://github.com/zhukov/webogram/blob/master/LICENSE\r\n */\r\n\r\nimport blobSafeMimeType from \"./blobSafeMimeType\";\r\n\r\nexport default function blobConstruct<T extends Uint8Array | string>(blobParts: Array<T> | T, mimeType: string = ''): Blob {\r\n  if(!Array.isArray(blobParts)) {\r\n    blobParts = [blobParts];\r\n  }\r\n\r\n  let blob;\r\n  const safeMimeType = blobSafeMimeType(mimeType);\r\n  try {\r\n    blob = new Blob(blobParts, {type: safeMimeType});\r\n  } catch(e) {\r\n    // @ts-ignore\r\n    let bb = new BlobBuilder;\r\n    blobParts.forEach((blobPart: any) => {\r\n      bb.append(blobPart);\r\n    });\r\n    blob = bb.getBlob(safeMimeType);\r\n  }\r\n  return blob;\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n * \r\n * Originally from:\r\n * https://github.com/zhukov/webogram\r\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\r\n * https://github.com/zhukov/webogram/blob/master/LICENSE\r\n */\r\n\r\n// https://www.iana.org/assignments/media-types/media-types.xhtml\r\nexport default function blobSafeMimeType(mimeType: string) {\r\n  if([\r\n    'image/jpeg',\r\n    'image/png',\r\n    'image/gif',\r\n    'image/svg+xml',\r\n    'image/webp',\r\n    'image/bmp',\r\n    'video/mp4',\r\n    'video/webm',\r\n    'video/quicktime',\r\n    'audio/ogg',\r\n    'audio/mpeg',\r\n    'audio/mp4',\r\n    'audio/wav', // though it is not in list\r\n    'application/json',\r\n    'application/pdf'\r\n  ].indexOf(mimeType) === -1) {\r\n    return 'application/octet-stream';\r\n  }\r\n\r\n  return mimeType;\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n * \r\n * Originally from:\r\n * https://github.com/zhukov/webogram\r\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\r\n * https://github.com/zhukov/webogram/blob/master/LICENSE\r\n */\r\n\r\nimport blobConstruct from \"../helpers/blob/blobConstruct\";\r\n\r\nexport class FileManager {\r\n  private blobSupported = true;\r\n  \r\n  constructor() {\r\n    try {\r\n      blobConstruct([], '');\r\n    } catch(e) {\r\n      this.blobSupported = false;\r\n    }\r\n  }\r\n  \r\n  public isAvailable() {\r\n    return this.blobSupported;\r\n  }\r\n  \r\n  public getFakeFileWriter(mimeType: string, size: number, saveFileCallback?: (blob: Blob) => Promise<Blob>) {\r\n    let bytes: Uint8Array = new Uint8Array(size);\r\n    const fakeFileWriter = {\r\n      write: async(part: Uint8Array, offset: number) => {\r\n        if(!this.blobSupported) {\r\n          throw false;\r\n        }\r\n        \r\n        // sometimes file size can be bigger than the prov\r\n        const endOffset = offset + part.byteLength;\r\n        if(endOffset > bytes.byteLength) {\r\n          const newBytes = new Uint8Array(endOffset);\r\n          newBytes.set(bytes, 0);\r\n          bytes = newBytes;\r\n        }\r\n\r\n        bytes.set(part, offset);\r\n      },\r\n      truncate: () => {\r\n        bytes = new Uint8Array();\r\n      },\r\n      trim: (size: number) => {\r\n        bytes = bytes.slice(0, size);\r\n      },\r\n      finalize: (saveToStorage = true) => {\r\n        const blob = blobConstruct(bytes, mimeType);\r\n\r\n        if(saveToStorage && saveFileCallback) {\r\n          saveFileCallback(blob);\r\n        }\r\n        \r\n        return blob;\r\n      },\r\n      getParts: () => bytes,\r\n      replaceParts: (parts: typeof bytes) => {\r\n        bytes = parts;\r\n      }\r\n    };\r\n    \r\n    return fakeFileWriter;\r\n  }\r\n}\r\n\r\nexport default new FileManager();\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport Modes from '../config/modes';\r\nimport blobConstruct from '../helpers/blob/blobConstruct';\r\nimport FileManager from './fileManager';\r\n//import { MOUNT_CLASS_TO } from './mtproto/mtproto_config';\r\n//import { logger } from './polyfill';\r\n\r\nexport type CacheStorageDbName = 'cachedFiles' | 'cachedStreamChunks' | 'cachedAssets';\r\n\r\nexport default class CacheStorageController {\r\n  private static STORAGES: CacheStorageController[] = [];\r\n  private openDbPromise: Promise<Cache>;\r\n\r\n  private useStorage = true;\r\n\r\n  //private log: ReturnType<typeof logger> = logger('CS');\r\n\r\n  constructor(private dbName: CacheStorageDbName) {\r\n    if(Modes.test) {\r\n      this.dbName += '_test';\r\n    }\r\n\r\n    if(CacheStorageController.STORAGES.length) {\r\n      this.useStorage = CacheStorageController.STORAGES[0].useStorage;\r\n    }\r\n    \r\n    this.openDatabase();\r\n    CacheStorageController.STORAGES.push(this);\r\n  }\r\n\r\n  private openDatabase(): Promise<Cache> {\r\n    return this.openDbPromise ?? (this.openDbPromise = caches.open(this.dbName));\r\n  }\r\n\r\n  public delete(entryName: string) {\r\n    return this.timeoutOperation((cache) => cache.delete('/' + entryName));\r\n  }\r\n\r\n  public deleteAll() {\r\n    return caches.delete(this.dbName);\r\n  }\r\n\r\n  public get(entryName: string) {\r\n    return this.timeoutOperation((cache) => cache.match('/' + entryName));\r\n  }\r\n\r\n  public save(entryName: string, response: Response) {\r\n    // return new Promise((resolve) => {}); // DEBUG\r\n    return this.timeoutOperation((cache) => cache.put('/' + entryName, response));\r\n  }\r\n\r\n  public getFile(fileName: string, method: 'blob' | 'json' | 'text' = 'blob'): Promise<any> {\r\n    /* if(method === 'blob') {\r\n      return Promise.reject();\r\n    } */\r\n\r\n    // const str = `get fileName: ${fileName}`;\r\n    // console.time(str);\r\n    return this.get(fileName).then((response) => {\r\n      if(!response) {\r\n        //console.warn('getFile:', response, fileName);\r\n        throw 'NO_ENTRY_FOUND';\r\n      }\r\n\r\n      const promise = response[method]();\r\n      // promise.then(() => {\r\n      //   console.timeEnd(str);\r\n      // });\r\n      return promise;\r\n    });\r\n  }\r\n\r\n  public saveFile(fileName: string, blob: Blob | Uint8Array) {\r\n    //return Promise.resolve(blobConstruct([blob]));\r\n    if(!(blob instanceof Blob)) {\r\n      blob = blobConstruct(blob);\r\n    }\r\n\r\n    const response = new Response(blob, {\r\n      headers: {\r\n        'Content-Length': '' + blob.size\r\n      }\r\n    });\r\n    \r\n    return this.save(fileName, response).then(() => blob as Blob);\r\n  }\r\n\r\n  public timeoutOperation<T>(callback: (cache: Cache) => Promise<T>) {\r\n    if(!this.useStorage) {\r\n      return Promise.reject('STORAGE_OFFLINE');\r\n    }\r\n\r\n    return new Promise<T>(async(resolve, reject) => {\r\n      let rejected = false;\r\n      const timeout = setTimeout(() => {\r\n        reject();\r\n        //console.warn('CACHESTORAGE TIMEOUT');\r\n        rejected = true;\r\n      }, 15e3);\r\n\r\n      try {\r\n        const cache = await this.openDatabase();\r\n        if(!cache) {\r\n          this.useStorage = false;\r\n          this.openDbPromise = undefined;\r\n          throw 'no cache?';\r\n        }\r\n\r\n        const res = await callback(cache);\r\n\r\n        if(rejected) return;\r\n        resolve(res);\r\n      } catch(err) {\r\n        reject(err);\r\n      }\r\n\r\n      clearTimeout(timeout);\r\n    });\r\n  }\r\n\r\n  public getFileWriter(fileName: string, fileSize: number, mimeType: string) {\r\n    const fakeWriter = FileManager.getFakeFileWriter(mimeType, fileSize, (blob) => {\r\n      return this.saveFile(fileName, blob).catch(() => blob);\r\n    });\r\n\r\n    return Promise.resolve(fakeWriter);\r\n  }\r\n\r\n  public static toggleStorage(enabled: boolean, clearWrite: boolean) {\r\n    return Promise.all(this.STORAGES.map((storage) => {\r\n      storage.useStorage = enabled;\r\n\r\n      if(!clearWrite) {\r\n        return;\r\n      }\r\n      \r\n      if(!enabled) {\r\n        return storage.deleteAll();\r\n      }\r\n    }));\r\n  }\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport readBlobAsUint8Array from \"../../helpers/blob/readBlobAsUint8Array\";\r\nimport deferredPromise, { CancellablePromise } from \"../../helpers/cancellablePromise\";\r\nimport { getWindowClients } from \"../../helpers/context\";\r\nimport debounce from \"../../helpers/schedulers/debounce\";\r\nimport { InputFileLocation, UploadFile } from \"../../layer\";\r\nimport CacheStorageController from \"../cacheStorage\";\r\nimport { DownloadOptions } from \"../mtproto/apiFileManager\";\r\nimport { RequestFilePartTask, deferredPromises, log } from \"./index.service\";\r\nimport timeout from \"./timeout\";\r\n\r\nconst cacheStorage = new CacheStorageController('cachedStreamChunks');\r\nconst CHUNK_TTL = 86400;\r\nconst CHUNK_CACHED_TIME_HEADER = 'Time-Cached';\r\n\r\nconst clearOldChunks = () => {\r\n  return cacheStorage.timeoutOperation((cache) => {\r\n    return cache.keys().then((requests) => {\r\n      const filtered: Map<StreamId, Request> = new Map();\r\n      const timestamp = Date.now() / 1000 | 0;\r\n      for(const request of requests) {\r\n        const match = request.url.match(/\\/(\\d+?)\\?/);\r\n        if(match && !filtered.has(match[1])) {\r\n          filtered.set(match[1], request);\r\n        }\r\n      }\r\n\r\n      const promises: Promise<any>[] = [];\r\n      for(const [id, request] of filtered) {\r\n        const promise = cache.match(request).then((response) => {\r\n          if((+response.headers.get(CHUNK_CACHED_TIME_HEADER) + CHUNK_TTL) <= timestamp) {\r\n            log('will delete stream chunk:', id);\r\n            return cache.delete(request, {ignoreSearch: true, ignoreVary: true});\r\n          }\r\n        });\r\n\r\n        promises.push(promise);\r\n      }\r\n\r\n      return Promise.all(promises);\r\n    });\r\n  });\r\n};\r\n\r\nsetInterval(clearOldChunks, 1800e3);\r\nsetInterval(() => {\r\n  getWindowClients().then((clients) => {\r\n    for(const [clientId, promises] of deferredPromises) {\r\n      if(!clients.find((client) => client.id === clientId)) {\r\n        for(const taskId in promises) {\r\n          const promise = promises[taskId];\r\n          promise.reject();\r\n        }\r\n\r\n        deferredPromises.delete(clientId);\r\n      }\r\n    }\r\n  });\r\n}, 120e3);\r\n\r\ntype StreamRange = [number, number];\r\ntype StreamId = DocId;\r\nconst streams: Map<StreamId, Stream> = new Map();\r\nclass Stream {\r\n  private destroyDebounced: () => void;\r\n  private id: StreamId;\r\n  private limitPart: number;\r\n  private loadedOffsets: Set<number> = new Set();\r\n\r\n  constructor(private info: DownloadOptions) {\r\n    this.id = Stream.getId(info);\r\n    streams.set(this.id, this);\r\n\r\n    // ! если грузить очень большое видео чанками по 512Кб в мобильном Safari, то стрим не запустится\r\n    this.limitPart = info.size > (75 * 1024 * 1024) ? STREAM_CHUNK_UPPER_LIMIT : STREAM_CHUNK_MIDDLE_LIMIT;\r\n    this.destroyDebounced = debounce(this.destroy, 150000, false, true);\r\n  }\r\n\r\n  private destroy = () => {\r\n    streams.delete(this.id);\r\n  };\r\n\r\n  private async requestFilePartFromWorker(alignedOffset: number, limit: number, fromPreload = false) {\r\n    const task: Omit<RequestFilePartTask, 'id'> = {\r\n      type: 'requestFilePart',\r\n      payload: {\r\n        docId: this.id,\r\n        dcId: this.info.dcId,\r\n        offset: alignedOffset,\r\n        limit\r\n      }\r\n    };\r\n\r\n    const taskId = JSON.stringify(task);\r\n    (task as RequestFilePartTask).id = taskId;\r\n\r\n    const windowClient = await getWindowClients().then((clients) => {\r\n      if(!clients.length) {\r\n        return;\r\n      }\r\n\r\n      return clients.find((client) => deferredPromises.has(client.id)) || clients[0];\r\n    });\r\n\r\n    if(!windowClient) {\r\n      throw new Error('no window');\r\n    }\r\n\r\n    let promises = deferredPromises.get(windowClient.id);\r\n    if(!promises) {\r\n      deferredPromises.set(windowClient.id, promises = {});\r\n    }\r\n    \r\n    let deferred = promises[taskId] as CancellablePromise<UploadFile.uploadFile>;\r\n    if(deferred) {\r\n      return deferred.then((uploadFile) => uploadFile.bytes);\r\n    }\r\n    \r\n    windowClient.postMessage(task);\r\n    this.loadedOffsets.add(alignedOffset);\r\n    \r\n    deferred = promises[taskId] = deferredPromise<UploadFile.uploadFile>();\r\n    const bytesPromise = deferred.then((uploadFile) => uploadFile.bytes);\r\n\r\n    this.saveChunkToCache(bytesPromise, alignedOffset, limit);\r\n    !fromPreload && this.preloadChunks(alignedOffset, alignedOffset + (this.limitPart * 15));\r\n\r\n    return bytesPromise;\r\n  }\r\n\r\n  private requestFilePartFromCache(alignedOffset: number, limit: number, fromPreload?: boolean) {\r\n    const key = this.getChunkKey(alignedOffset, limit);\r\n    return cacheStorage.getFile(key).then((blob: Blob) => {\r\n      return fromPreload ? new Uint8Array() : readBlobAsUint8Array(blob);\r\n    }, (error) => {\r\n      if(error === 'NO_ENTRY_FOUND') {\r\n        return;\r\n      }\r\n    });\r\n  }\r\n\r\n  private requestFilePart(alignedOffset: number, limit: number, fromPreload?: boolean) {\r\n    return this.requestFilePartFromCache(alignedOffset, limit, fromPreload).then((bytes) => {\r\n      return bytes || this.requestFilePartFromWorker(alignedOffset, limit, fromPreload);\r\n    });\r\n  }\r\n\r\n  private saveChunkToCache(deferred: Promise<Uint8Array>, alignedOffset: number, limit: number) {\r\n    return deferred.then((bytes) => {\r\n      const key = this.getChunkKey(alignedOffset, limit);\r\n      const response = new Response(bytes, {\r\n        headers: {\r\n          'Content-Length': '' + bytes.length,\r\n          'Content-Type': 'application/octet-stream',\r\n          [CHUNK_CACHED_TIME_HEADER]: '' + (Date.now() / 1000 | 0)\r\n        }\r\n      });\r\n\r\n      return cacheStorage.save(key, response);\r\n    });\r\n  }\r\n\r\n  private preloadChunk(offset: number) {\r\n    if(this.loadedOffsets.has(offset)) {\r\n      return;\r\n    }\r\n\r\n    this.loadedOffsets.add(offset);\r\n    this.requestFilePart(offset, this.limitPart, true);\r\n  }\r\n\r\n  private preloadChunks(offset: number, end: number) {\r\n    if(end > this.info.size) {\r\n      end = this.info.size;\r\n    }\r\n\r\n    if(!offset) { // load last chunk for bounds\r\n      this.preloadChunk(alignOffset(offset, this.limitPart));\r\n    } else { // don't preload next chunks before the start\r\n      for(; offset < end; offset += this.limitPart) {\r\n        this.preloadChunk(offset);\r\n      }\r\n    }\r\n  }\r\n\r\n  public requestRange(range: StreamRange) {\r\n    this.destroyDebounced();\r\n\r\n    const possibleResponse = responseForSafariFirstRange(range, this.info.mimeType, this.info.size);\r\n    if(possibleResponse) {\r\n      return possibleResponse;\r\n    }\r\n\r\n    let [offset, end] = range;\r\n\r\n    /* if(info.size > limitPart && isSafari && offset === limitPart) {\r\n      //end = info.size - 1;\r\n      //offset = info.size - 1 - limitPart;\r\n      offset = info.size - (info.size % limitPart);\r\n    } */\r\n\r\n    const limit = end && end < this.limitPart ? alignLimit(end - offset + 1) : this.limitPart;\r\n    const alignedOffset = alignOffset(offset, limit);\r\n\r\n    if(!end) {\r\n      end = Math.min(offset + limit, this.info.size - 1);\r\n    }\r\n\r\n    return this.requestFilePart(alignedOffset, limit).then((ab) => {\r\n      //log.debug('[stream] requestFilePart result:', result);\r\n\r\n      // if(isSafari) {\r\n      if(offset !== alignedOffset || end !== (alignedOffset + limit)) {\r\n        ab = ab.slice(offset - alignedOffset, end - alignedOffset + 1);\r\n      }\r\n      \r\n      const headers: Record<string, string> = {\r\n        'Accept-Ranges': 'bytes',\r\n        'Content-Range': `bytes ${offset}-${offset + ab.byteLength - 1}/${this.info.size || '*'}`,\r\n        'Content-Length': `${ab.byteLength}`\r\n      };\r\n\r\n      if(this.info.mimeType) {\r\n        headers['Content-Type'] = this.info.mimeType;\r\n      }\r\n\r\n      // simulate slow connection\r\n      //setTimeout(() => {\r\n        return new Response(ab, {\r\n          status: 206,\r\n          statusText: 'Partial Content',\r\n          headers,\r\n        });\r\n      //}, 2.5e3);\r\n    });\r\n  }\r\n\r\n  private getChunkKey(alignedOffset: number, limit: number) {\r\n    return this.id + '?offset=' + alignedOffset + '&limit=' + limit;\r\n  }\r\n\r\n  public static get(info: DownloadOptions) {\r\n    return streams.get(this.getId(info)) ?? new Stream(info);\r\n  }\r\n\r\n  private static getId(info: DownloadOptions) {\r\n    return (info.location as InputFileLocation.inputDocumentFileLocation).id;\r\n  }\r\n}\r\n\r\nexport default function onStreamFetch(event: FetchEvent, params: string) {\r\n  const range = parseRange(event.request.headers.get('Range'));\r\n  const info: DownloadOptions = JSON.parse(decodeURIComponent(params));\r\n  const stream = Stream.get(info);\r\n\r\n  //log.debug('[stream]', url, offset, end);\r\n\r\n  event.respondWith(Promise.race([\r\n    timeout(45 * 1000),\r\n    stream.requestRange(range)\r\n  ]));\r\n}\r\n\r\nfunction responseForSafariFirstRange(range: StreamRange, mimeType: string, size: number): Response {\r\n  if(range[0] === 0 && range[1] === 1) {\r\n    return new Response(new Uint8Array(2).buffer, {\r\n      status: 206,\r\n      statusText: 'Partial Content',\r\n      headers: {\r\n        'Accept-Ranges': 'bytes',\r\n        'Content-Range': `bytes 0-1/${size || '*'}`,\r\n        'Content-Length': '2',\r\n        'Content-Type': mimeType || 'video/mp4',\r\n      },\r\n    });\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n/* const STREAM_CHUNK_UPPER_LIMIT = 256 * 1024;\r\nconst SMALLEST_CHUNK_LIMIT = 256 * 4; */\r\n/* const STREAM_CHUNK_UPPER_LIMIT = 1024 * 1024;\r\nconst SMALLEST_CHUNK_LIMIT = 1024 * 4; */\r\nconst STREAM_CHUNK_MIDDLE_LIMIT = 512 * 1024;\r\nconst STREAM_CHUNK_UPPER_LIMIT = 1024 * 1024;\r\nconst SMALLEST_CHUNK_LIMIT = 512 * 4;\r\n\r\nfunction parseRange(header: string): StreamRange {\r\n  if(!header) return [0, 0];\r\n  const [, chunks] = header.split('=');\r\n  const ranges = chunks.split(', ');\r\n  const [offset, end] = ranges[0].split('-');\r\n\r\n  return [+offset, +end || 0];\r\n}\r\n\r\nfunction alignOffset(offset: number, base = SMALLEST_CHUNK_LIMIT) {\r\n  return offset - (offset % base);\r\n}\r\n\r\nfunction alignLimit(limit: number) {\r\n  return 2 ** Math.ceil(Math.log(limit) / Math.log(2));\r\n}\r\n","// * Jolly Cobra's schedulers\r\n\r\nimport ctx from \"../../environment/ctx\";\r\nimport { AnyFunction, Awaited } from \"../../types\";\r\nimport noop from \"../noop\";\r\n\r\nexport type DebounceReturnType<F extends AnyFunction> = { \r\n  (...args: Parameters<F>): Promise<Awaited<ReturnType<F>>>; \r\n  clearTimeout(): void; \r\n};\r\n\r\nexport default function debounce<F extends AnyFunction>(\r\n  fn: F,\r\n  ms: number,\r\n  shouldRunFirst = true,\r\n  shouldRunLast = true,\r\n): DebounceReturnType<F> {\r\n  let waitingTimeout: number;\r\n  let waitingPromise: Promise<Awaited<ReturnType<F>>>, resolve: (result: any) => void, reject: () => void;\r\n  let hadNewCall = false;\r\n\r\n  const invoke = (args: Parameters<F>) => {\r\n    const _resolve = resolve, _reject = reject;\r\n    try {\r\n      const result = fn.apply(null, args);\r\n      _resolve(result);\r\n    } catch(err) {\r\n      console.error('debounce error', err);\r\n      // @ts-ignore\r\n      _reject(err);\r\n    }\r\n  };\r\n\r\n  const debounce = (...args: Parameters<F>) => {\r\n    if(!waitingPromise) waitingPromise = new Promise((_resolve, _reject) => (resolve = _resolve, reject = _reject));\r\n\r\n    if(waitingTimeout) {\r\n      clearTimeout(waitingTimeout);\r\n      hadNewCall = true;\r\n      reject();\r\n      waitingPromise = new Promise((_resolve, _reject) => (resolve = _resolve, reject = _reject));\r\n    } else if(shouldRunFirst) {\r\n      invoke(args);\r\n      hadNewCall = false;\r\n    }\r\n\r\n    const _waitingTimeout = ctx.setTimeout(() => {\r\n      // will run if should run last or first but with new call\r\n      if(shouldRunLast && (!shouldRunFirst || hadNewCall)) {\r\n        invoke(args);\r\n      }\r\n      \r\n      // if debounce was called during invoking\r\n      if(waitingTimeout === _waitingTimeout) {\r\n        waitingTimeout = waitingPromise = resolve = reject = undefined;\r\n        hadNewCall = false;\r\n      }\r\n    }, ms);\r\n\r\n    waitingTimeout = _waitingTimeout;\r\n    waitingPromise.catch(noop);\r\n    return waitingPromise;\r\n  };\r\n\r\n  debounce.clearTimeout = () => {\r\n    if(waitingTimeout) {\r\n      ctx.clearTimeout(waitingTimeout);\r\n      reject();\r\n      waitingTimeout = waitingPromise = resolve = reject = undefined;\r\n      hadNewCall = false;\r\n    }\r\n  };\r\n\r\n  return debounce;\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport noop from \"./noop\";\r\n\r\nexport interface CancellablePromise<T> extends Promise<T> {\r\n  resolve?: (value: T) => void,\r\n  reject?: (...args: any[]) => void,\r\n  cancel?: (reason?: any) => void,\r\n\r\n  notify?: (...args: any[]) => void,\r\n  notifyAll?: (...args: any[]) => void,\r\n  lastNotify?: any,\r\n  listeners?: Array<(...args: any[]) => void>,\r\n  addNotifyListener?: (callback: (...args: any[]) => void) => void,\r\n\r\n  isFulfilled?: boolean,\r\n  isRejected?: boolean\r\n}\r\n\r\nexport default function deferredPromise<T>() {\r\n  let deferredHelper: any = {\r\n    isFulfilled: false, \r\n    isRejected: false,\r\n\r\n    notify: () => {}, \r\n    notifyAll: (...args: any[]) => {\r\n      deferredHelper.lastNotify = args;\r\n      deferredHelper.listeners.forEach((callback: any) => callback(...args));\r\n    }, \r\n\r\n    listeners: [],\r\n    addNotifyListener: (callback: (...args: any[]) => void) => {\r\n      if(deferredHelper.lastNotify) {\r\n        callback(...deferredHelper.lastNotify);\r\n      }\r\n\r\n      deferredHelper.listeners.push(callback);\r\n    }\r\n  };\r\n\r\n  let deferred: CancellablePromise<T> = new Promise<T>((resolve, reject) => {\r\n    deferredHelper.resolve = (value: T) => {\r\n      if(deferred.isFulfilled || deferred.isRejected) return;\r\n\r\n      deferred.isFulfilled = true;\r\n      resolve(value);\r\n    };\r\n    \r\n    deferredHelper.reject = (...args: any[]) => {\r\n      if(deferred.isRejected || deferred.isFulfilled) return;\r\n      \r\n      deferred.isRejected = true;\r\n      reject(...args);\r\n    };\r\n  });\r\n\r\n  // @ts-ignore\r\n  /* deferred.then = (resolve: (value: T) => any, reject: (...args: any[]) => any) => {\r\n    const n = deferredPromise<ReturnType<typeof resolve>>();\r\n    \r\n  }; */\r\n\r\n  deferred.catch(noop).finally(() => {\r\n    deferred.notify = deferred.notifyAll = deferred.lastNotify = null;\r\n    deferred.listeners.length = 0;\r\n\r\n    if(deferred.cancel) {\r\n      deferred.cancel = noop;\r\n    }\r\n  });\r\n\r\n  Object.assign(deferred, deferredHelper);\r\n\r\n  return deferred;\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport readBlobAsArrayBuffer from \"./readBlobAsArrayBuffer\";\r\n\r\nexport default function readBlobAsUint8Array(blob: Blob) {\r\n  return readBlobAsArrayBuffer(blob).then((buffer) => new Uint8Array(buffer));\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport readBlobAs from \"./readBlobAs\";\r\n\r\nexport default function readBlobAsArrayBuffer(blob: Blob) {\r\n  return readBlobAs(blob, 'readAsArrayBuffer');\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\n// import { IS_WEB_WORKER } from \"../context\";\r\n\r\n// const id = IS_WEB_WORKER ? Math.random() * 0x1000 | 0 : 0;\r\nexport default function readBlobAs(blob: Blob, method: 'readAsText'): Promise<string>;\r\nexport default function readBlobAs(blob: Blob, method: 'readAsDataURL'): Promise<string>;\r\nexport default function readBlobAs(blob: Blob, method: 'readAsArrayBuffer'): Promise<ArrayBuffer>;\r\nexport default function readBlobAs(blob: Blob, method: 'readAsArrayBuffer' | 'readAsText' | 'readAsDataURL'): Promise<any> {\r\n  // const perf = performance.now();\r\n  return new Promise<any>((resolve) => {\r\n    const reader = new FileReader();\r\n    reader.addEventListener('loadend', (e) => {\r\n      // console.log(`readBlobAs [${id}] ${method} time ${performance.now() - perf}`);\r\n      resolve(e.target.result);\r\n    });\r\n    reader[method](blob);\r\n  });\r\n}\r\n","export default function deepEqual(x: any, y: any): boolean {\r\n  const ok = Object.keys, tx = typeof x, ty = typeof y;\r\n  return x && y && tx === 'object' && tx === ty ? (\r\n    ok(x).length === ok(y).length &&\r\n      ok(x).every((key) => deepEqual(x[key], y[key]))\r\n  ) : (x === y);\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n * \r\n * Originally from:\r\n * https://github.com/zhukov/webogram\r\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\r\n * https://github.com/zhukov/webogram/blob/master/LICENSE\r\n */\r\n\r\nimport { Database } from '../config/databases';\r\nimport Modes from '../config/modes';\r\nimport safeAssign from '../helpers/object/safeAssign';\r\nimport { logger } from './logger';\r\n\r\n/**\r\n * https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/createIndex\r\n */\r\nexport type IDBIndex = {\r\n  indexName: string,\r\n  keyPath: string,\r\n  objectParameters: IDBIndexParameters\r\n};\r\n\r\nexport type IDBStore = {\r\n  name: string, \r\n  indexes?: IDBIndex[]\r\n};\r\n\r\nexport type IDBOptions = {\r\n  name?: string,\r\n  storeName: string,\r\n  stores?: IDBStore[],\r\n  version?: number\r\n};\r\n\r\nconst DEBUG = false;\r\n\r\nexport class IDB {\r\n  private static INSTANCES: IDB[] = [];\r\n  private openDbPromise: Promise<IDBDatabase>;\r\n  private db: IDBDatabase;\r\n  private storageIsAvailable: boolean;\r\n  private log: ReturnType<typeof logger>;\r\n  private name: string;\r\n  private version: number;\r\n  private stores: IDBStore[];\r\n\r\n  constructor(db: Database<any>) {\r\n    safeAssign(this, db);\r\n\r\n    if(Modes.test) {\r\n      this.name += '_test';\r\n    }\r\n\r\n    this.storageIsAvailable = true;\r\n    this.log = logger(['IDB', db.name].join('-'));\r\n    this.log('constructor');\r\n\r\n    this.openDatabase(true);\r\n\r\n    IDB.INSTANCES.push(this);\r\n  }\r\n\r\n  public isAvailable() {\r\n    return this.storageIsAvailable;\r\n  }\r\n\r\n  public openDatabase(createNew = false): Promise<IDBDatabase> {\r\n    if(this.openDbPromise && !createNew) {\r\n      return this.openDbPromise;\r\n    }\r\n\r\n    const createIndexes = (os: IDBObjectStore, store: IDBStore) => {\r\n      const indexNames = Array.from(os.indexNames);\r\n      for(const indexName of indexNames) {\r\n        os.deleteIndex(indexName);\r\n      }\r\n\r\n      if(!store.indexes?.length) {\r\n        return;\r\n      }\r\n\r\n      for(const index of store.indexes) {\r\n        if(os.indexNames.contains(index.indexName)) {\r\n          continue;\r\n        }\r\n\r\n        os.createIndex(index.indexName, index.keyPath, index.objectParameters);\r\n      }\r\n    };\r\n\r\n    const createObjectStore = (db: IDBDatabase, store: IDBStore) => {\r\n      const os = db.createObjectStore(store.name);\r\n      createIndexes(os, store);\r\n    };\r\n\r\n    try {\r\n      var request = indexedDB.open(this.name, this.version);\r\n\r\n      if(!request) {\r\n        return Promise.reject();\r\n      }\r\n    } catch(error) {\r\n      this.log.error('error opening db', (error as Error).message);\r\n      this.storageIsAvailable = false;\r\n      return Promise.reject(error);\r\n    }\r\n\r\n    let finished = false;\r\n    setTimeout(() => {\r\n      if(!finished) {\r\n        request.onerror({type: 'IDB_CREATE_TIMEOUT'} as Event);\r\n      }\r\n    }, 3000);\r\n\r\n    return this.openDbPromise = new Promise<IDBDatabase>((resolve, reject) => {\r\n      request.onsuccess = (event) => {\r\n        finished = true;\r\n        const db = request.result;\r\n        let calledNew = false;\r\n\r\n        this.log('Opened');\r\n  \r\n        db.onerror = (error) => {\r\n          this.storageIsAvailable = false;\r\n          this.log.error('Error creating/accessing IndexedDB database', error);\r\n          reject(error);\r\n        };\r\n\r\n        db.onclose = (e) => {\r\n          this.log.error('closed:', e);\r\n          !calledNew && this.openDatabase();\r\n        };\r\n\r\n        db.onabort = (e) => {\r\n          this.log.error('abort:', e);\r\n          const transaction = e.target as IDBTransaction;\r\n          \r\n          this.openDatabase(calledNew = true);\r\n\r\n          if(transaction.onerror) {\r\n            transaction.onerror(e);\r\n          }\r\n\r\n          db.close();\r\n        };\r\n\r\n        db.onversionchange = (e) => {\r\n          this.log.error('onversionchange, lol?');\r\n        };\r\n\r\n        resolve(this.db = db);\r\n      };\r\n  \r\n      request.onerror = (event) => {\r\n        finished = true;\r\n        this.storageIsAvailable = false;\r\n        this.log.error('Error creating/accessing IndexedDB database', event);\r\n        reject(event);\r\n      };\r\n  \r\n      request.onupgradeneeded = (event) => {\r\n        finished = true;\r\n        this.log.warn('performing idb upgrade from', event.oldVersion, 'to', event.newVersion);\r\n\r\n        const target = event.target as IDBOpenDBRequest;\r\n        const db = target.result;\r\n        this.stores.forEach((store) => {\r\n          /* if(db.objectStoreNames.contains(store.name)) {\r\n            //if(event.oldVersion === 1) {\r\n              db.deleteObjectStore(store.name);\r\n            //}\r\n          } */\r\n    \r\n          if(!db.objectStoreNames.contains(store.name)) {\r\n            createObjectStore(db, store);\r\n          } else {\r\n            const txn = target.transaction;\r\n            const os = txn.objectStore(store.name);\r\n            createIndexes(os, store);\r\n          }\r\n        });\r\n      };\r\n    });\r\n  }\r\n\r\n  public static create<T extends Database<any>>(db: T) {\r\n    return this.INSTANCES.find((instance) => instance.name === db.name) ?? new IDB(db);\r\n  }\r\n\r\n  public static closeDatabases(preserve?: IDB) {\r\n    this.INSTANCES.forEach((storage) => {\r\n      if(preserve && preserve === storage) {\r\n        return;\r\n      }\r\n\r\n      const db = storage.db;\r\n      if(db) {\r\n        db.onclose = () => {};\r\n        db.close();\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nexport default class IDBStorage<T extends Database<any>, StoreName extends string = T['stores'][0]['name']> {\r\n  private log: ReturnType<typeof logger>;\r\n  private storeName: T['stores'][0]['name'];\r\n  private idb: IDB;\r\n\r\n  constructor(db: T, storeName: typeof db['stores'][0]['name']) {\r\n    this.storeName = storeName;\r\n    this.log = logger(['IDB', db.name, storeName].join('-'));\r\n    this.idb = IDB.create(db);\r\n  }\r\n\r\n  /**\r\n   * ! WARNING ! function requires at least one opened connection\r\n   */\r\n  /* public static clearObjectStores() {\r\n    const storage = this.STORAGES[0];\r\n    this.closeDatabases(storage);\r\n\r\n    const names = Array.from(storage.db.objectStoreNames);\r\n    const promises = names.map((name) => storage.clear(name));\r\n    return Promise.all(promises);\r\n  } */\r\n\r\n  /* public static deleteDatabase() {\r\n    this.closeDatabases();\r\n\r\n    const storages = this.STORAGES;\r\n    const dbNames = Array.from(new Set(storages.map((storage) => storage.name)));\r\n    const promises = dbNames.map((dbName) => {\r\n      return new Promise<void>((resolve, reject) => {\r\n        const deleteRequest = indexedDB.deleteDatabase(dbName);\r\n  \r\n        deleteRequest.onerror = () => {\r\n          reject();\r\n        };\r\n  \r\n        deleteRequest.onsuccess = () => {\r\n          resolve();\r\n        };\r\n      });\r\n    });\r\n\r\n    return Promise.all(promises);\r\n  } */\r\n\r\n  public delete(entryName: string | string[], storeName?: StoreName): Promise<void> {\r\n    //return Promise.resolve();\r\n    if(!Array.isArray(entryName)) {\r\n      entryName = [].concat(entryName);\r\n    }\r\n\r\n    return this.getObjectStore('readwrite', (objectStore) => {\r\n      return (entryName as string[]).map((entryName) => objectStore.delete(entryName));\r\n    }, DEBUG ? 'delete: ' + entryName.join(', ') : '', storeName);\r\n  }\r\n\r\n  public clear(storeName?: StoreName): Promise<void> {\r\n    return this.getObjectStore('readwrite', (objectStore) => objectStore.clear(), DEBUG ? 'clear' : '', storeName);\r\n  }\r\n\r\n  public save(entryName: string | string[], value: any | any[], storeName?: StoreName) {\r\n    // const handleError = (error: Error) => {\r\n    //   this.log.error('save: transaction error:', entryName, value, db, error, error && error.name);\r\n    //   if((!error || error.name === 'InvalidStateError')/*  && false */) {\r\n    //     setTimeout(() => {\r\n    //       this.save(entryName, value);\r\n    //     }, 2e3);\r\n    //   } else {\r\n    //     //console.error('IndexedDB saveFile transaction error:', error, error && error.name);\r\n    //   }\r\n    // };\r\n\r\n    if(!Array.isArray(entryName)) {\r\n      entryName = [].concat(entryName);\r\n      value = [].concat(value);\r\n    }\r\n    \r\n    return this.getObjectStore('readwrite', (objectStore) => {\r\n      return (entryName as string[]).map((entryName, idx) => objectStore.put(value[idx], entryName));\r\n    }, DEBUG ? 'save: ' + entryName.join(', ') : '', storeName);\r\n  }\r\n\r\n  // public saveFile(fileName: string, blob: Blob | Uint8Array) {\r\n  //   //return Promise.resolve(blobConstruct([blob]));\r\n  //   if(!(blob instanceof Blob)) {\r\n  //     blob = blobConstruct(blob);\r\n  //   }\r\n\r\n  //   return this.save(fileName, blob);\r\n  // }\r\n\r\n  /* public saveFileBase64(db: IDBDatabase, fileName: string, blob: Blob | any): Promise<Blob> {\r\n    if(this.getBlobSize(blob) > 10 * 1024 * 1024) {\r\n      return Promise.reject();\r\n    }\r\n\r\n    if(!(blob instanceof Blob)) {\r\n      var safeMimeType = blobSafeMimeType(blob.type || 'image/jpeg');\r\n      var address = 'data:' + safeMimeType + ';base64,' + bytesToBase64(blob);\r\n      return this.storagePutB64String(db, fileName, address).then(() => {\r\n        return blob;\r\n      });\r\n    }\r\n\r\n    try {\r\n      var reader = new FileReader();\r\n    } catch (e) {\r\n      this.storageIsAvailable = false;\r\n      return Promise.reject();\r\n    }\r\n\r\n    let promise = new Promise<Blob>((resolve, reject) => {\r\n      reader.onloadend = () => {\r\n        this.storagePutB64String(db, fileName, reader.result as string).then(() => {\r\n          resolve(blob);\r\n        }, reject);\r\n      }\r\n  \r\n      reader.onerror = reject;\r\n    });\r\n    \r\n\r\n    try {\r\n      reader.readAsDataURL(blob);\r\n    } catch (e) {\r\n      this.storageIsAvailable = false;\r\n      return Promise.reject();\r\n    }\r\n\r\n    return promise;\r\n  }\r\n\r\n  public storagePutB64String(db: IDBDatabase, fileName: string, b64string: string) {\r\n    try {\r\n      var objectStore = db.transaction([this.storeName], 'readwrite')\r\n        .objectStore(this.storeName);\r\n      var request = objectStore.put(b64string, fileName);\r\n    } catch(error) {\r\n      this.storageIsAvailable = false;\r\n      return Promise.reject(error);\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n      request.onsuccess = function(event) {\r\n        resolve();\r\n      };\r\n  \r\n      request.onerror = reject;\r\n    });\r\n  }\r\n\r\n  public getBlobSize(blob: any) {\r\n    return blob.size || blob.byteLength || blob.length;\r\n  } */\r\n\r\n  public get<T>(entryName: string[], storeName?: StoreName): Promise<T[]>;\r\n  public get<T>(entryName: string, storeName?: StoreName): Promise<T>;\r\n  public get<T>(entryName: string | string[], storeName?: StoreName): Promise<T> | Promise<T[]> {\r\n    //return Promise.reject();\r\n\r\n    if(!Array.isArray(entryName)) {\r\n      entryName = [].concat(entryName);\r\n    }\r\n\r\n    if(!entryName.length) {\r\n      return Promise.resolve([]) as any;\r\n    }\r\n\r\n    return this.getObjectStore<T>('readonly', (objectStore) => {\r\n      return (entryName as string[]).map((entryName) => objectStore.get(entryName));\r\n    }, DEBUG ? 'get: ' + entryName.join(', ') : '', storeName);\r\n  }\r\n\r\n  private getObjectStore<T>(\r\n    mode: IDBTransactionMode, \r\n    callback: (objectStore: IDBObjectStore) => IDBRequest | IDBRequest[], \r\n    log?: string, \r\n    storeName = this.storeName\r\n  ) {\r\n    let perf: number;\r\n\r\n    if(log) {\r\n      perf = performance.now();\r\n      this.log(log + ': start');\r\n    }\r\n\r\n    return this.idb.openDatabase().then((db) => {\r\n      return new Promise<T>((resolve, reject) => {\r\n        /* if(mode === 'readwrite') {\r\n          return;\r\n        } */\r\n\r\n        const transaction = db.transaction([storeName], mode);\r\n\r\n        const onError = () => {\r\n          clearTimeout(timeout);\r\n          reject(transaction.error);\r\n        };\r\n\r\n        // let resolved = false;\r\n        const onComplete = (/* what: string */) => {\r\n          clearTimeout(timeout);\r\n\r\n          if(log) {\r\n            this.log(log + ': end', performance.now() - perf/* , what */);\r\n          }\r\n\r\n          // if(resolved) {\r\n          //   return;\r\n          // }\r\n\r\n          // resolved = true;\r\n          const results = requests.map((r) => r.result);\r\n          resolve(isArray ? results : results[0]);\r\n        };\r\n\r\n        transaction.onerror = onError;\r\n\r\n        // * have to wait while clearing or setting something\r\n        const waitForTransactionComplete = mode === 'readwrite';\r\n        if(waitForTransactionComplete) {\r\n          transaction.oncomplete = () => onComplete(/* 'transaction' */);\r\n        }\r\n  \r\n        const timeout = setTimeout(() => {\r\n          this.log.error('transaction not finished', transaction, log);\r\n        }, 10000);\r\n  \r\n        /* transaction.addEventListener('abort', (e) => {\r\n          //handleError();\r\n          this.log.error('IndexedDB: transaction abort!', transaction.error);\r\n        }); */\r\n  \r\n        const callbackResult = callback(transaction.objectStore(storeName));\r\n\r\n        const isArray = Array.isArray(callbackResult);\r\n        const requests: IDBRequest[] = isArray ? callbackResult : [].concat(callbackResult) as any;\r\n\r\n        if(waitForTransactionComplete) {\r\n          return;\r\n        }\r\n\r\n        const length = requests.length;\r\n        let left = length;\r\n\r\n        const onRequestFinished = () => {\r\n          if(transaction.error) {\r\n            return;\r\n          }\r\n\r\n          if(!--left) {\r\n            onComplete(/* 'requests' */);\r\n          }\r\n        };\r\n\r\n        for(let i = 0; i < length; ++i) {\r\n          const request = requests[i];\r\n          request.onerror = onError;\r\n          request.onsuccess = onRequestFinished;\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  public getAll<T>(storeName?: StoreName): Promise<T[]> {\r\n    return this.getObjectStore<T[]>('readonly', (objectStore) => objectStore.getAll(), DEBUG ? 'getAll' : '', storeName);\r\n  }\r\n\r\n  /* public getAllKeys(): Promise<Array<string>> {\r\n    console.time('getAllEntries');\r\n    return this.openDatabase().then((db) => {\r\n      var objectStore = db.transaction([this.storeName], 'readonly')\r\n        .objectStore(this.storeName);\r\n      var request = objectStore.getAllKeys();\r\n\r\n      return new Promise((resolve, reject) => {\r\n        request.onsuccess = function(event) {\r\n          // @ts-ignore\r\n          var result = event.target.result;\r\n          resolve(result);\r\n          console.timeEnd('getAllEntries');\r\n        }\r\n  \r\n        request.onerror = reject;\r\n      });\r\n    });\r\n  } */\r\n\r\n  /* public isFileExists(fileName: string): Promise<boolean> {\r\n    console.time('isFileExists');\r\n    return this.openDatabase().then((db) => {\r\n      var objectStore = db.transaction([this.storeName], 'readonly')\r\n        .objectStore(this.storeName);\r\n      var request = objectStore.openCursor(fileName);\r\n\r\n      return new Promise((resolve, reject) => {\r\n        request.onsuccess = function(event) {\r\n          // @ts-ignore\r\n          var cursor = event.target.result;\r\n          resolve(!!cursor);\r\n          console.timeEnd('isFileExists');\r\n        }\r\n  \r\n        request.onerror = reject;\r\n      });\r\n    });\r\n  } */\r\n\r\n  /* public getFileWriter(fileName: string, mimeType: string) {\r\n    var fakeWriter = FileManager.getFakeFileWriter(mimeType, (blob) => {\r\n      return this.saveFile(fileName, blob);\r\n    });\r\n\r\n    return Promise.resolve(fakeWriter);\r\n  } */\r\n}\r\n","export default function safeAssign<T>(object: T, fromObject: any) {\r\n  if(fromObject) {\r\n    for(let i in fromObject) {\r\n      if(fromObject[i] !== undefined) {\r\n        // @ts-ignore\r\n        object[i] = fromObject[i];\r\n      }\r\n    }\r\n  }\r\n\r\n  return object;\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n * \r\n * Originally from:\r\n * https://github.com/zhukov/webogram\r\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\r\n * https://github.com/zhukov/webogram/blob/master/LICENSE\r\n */\r\n\r\nimport { Database } from \"../../config/databases\";\r\nimport DATABASE_STATE from \"../../config/databases/state\";\r\nimport { IS_FIREFOX } from \"../../environment/userAgent\";\r\nimport deepEqual from \"../../helpers/object/deepEqual\";\r\nimport IDBStorage from \"../idb\";\r\nimport { log, ServiceWorkerPingTask, ServiceWorkerPushClickTask } from \"./index.service\";\r\n\r\nconst ctx = self as any as ServiceWorkerGlobalScope;\r\nconst defaultBaseUrl = location.protocol + '//' + location.hostname + location.pathname.split('/').slice(0, -1).join('/') + '/';\r\n\r\nexport type PushNotificationObject = {\r\n  loc_key: string,\r\n  loc_args: string[],\r\n  //user_id: number, // should be number\r\n  custom: {\r\n    channel_id?: string, // should be number\r\n    chat_id?: string, // should be number\r\n    from_id?: string, // should be number\r\n    msg_id: string,\r\n    peerId?: string // should be number\r\n  },\r\n  sound?: string,\r\n  random_id: number,\r\n  badge?: string, // should be number\r\n  description: string,\r\n  mute: string, // should be number\r\n  title: string,\r\n\r\n  action?: 'mute1d' | 'push_settings', // will be set before postMessage to main thread\r\n};\r\n\r\nclass SomethingGetter<T extends Database<any>, Storage extends Record<string, any>> {\r\n  private cache: Partial<Storage> = {};\r\n  private storage: IDBStorage<T>;\r\n\r\n  constructor(\r\n    db: T, \r\n    storeName: typeof db['stores'][number]['name'], \r\n    private defaults: {\r\n      [Property in keyof Storage]: ((value: Storage[Property]) => Storage[Property]) | Storage[Property]\r\n    }\r\n  ) {\r\n    this.storage = new IDBStorage<T>(db, storeName);\r\n  }\r\n\r\n  public async get<T extends keyof Storage>(key: T) {\r\n    if(this.cache[key] !== undefined) {\r\n      return this.cache[key];\r\n    }\r\n\r\n    let value: Storage[T];\r\n    try {\r\n      value = await this.storage.get(key as string);\r\n    } catch(err) {\r\n\r\n    }\r\n\r\n    if(this.cache[key] !== undefined) {\r\n      return this.cache[key];\r\n    }\r\n\r\n    if(value === undefined) {\r\n      const callback = this.defaults[key];\r\n      value = typeof(callback) === 'function' ? callback() : callback;\r\n    }\r\n\r\n    return this.cache[key] = value;\r\n  }\r\n\r\n  public async set<T extends keyof Storage>(key: T, value: Storage[T]) {\r\n    const cached = this.cache[key] ?? this.defaults[key];\r\n    if(deepEqual(cached, value)) {\r\n      return;\r\n    }\r\n\r\n    this.cache[key] = value;\r\n\r\n    try {\r\n      this.storage.save(key as string, value);\r\n    } catch(err) {\r\n\r\n    }\r\n  }\r\n}\r\n\r\ntype PushStorage = {\r\n  push_mute_until: number,\r\n  push_lang: Partial<ServiceWorkerPingTask['payload']['lang']>\r\n  push_settings: Partial<ServiceWorkerPingTask['payload']['settings']>\r\n};\r\n\r\nconst getter = new SomethingGetter<typeof DATABASE_STATE, PushStorage>(DATABASE_STATE, 'session', {\r\n  push_mute_until: 0,\r\n  push_lang: {\r\n    push_message_nopreview: 'You have a new message',\r\n    push_action_mute1d: 'Mute for 24H',\r\n    push_action_settings: 'Settings'\r\n  },\r\n  push_settings: {}\r\n});\r\n\r\nctx.addEventListener('push', (event) => {\r\n  const obj: PushNotificationObject = event.data.json();\r\n  log('push', obj);\r\n\r\n  let hasActiveWindows = false;\r\n  const checksPromise = Promise.all([\r\n    getter.get('push_mute_until'), \r\n    ctx.clients.matchAll({type: 'window'})\r\n  ]).then((result) => {\r\n    const [muteUntil, clientList] = result;\r\n    \r\n    log('matched clients', clientList);\r\n    hasActiveWindows = clientList.length > 0;\r\n    if(hasActiveWindows) {\r\n      throw 'Supress notification because some instance is alive';\r\n    }\r\n    \r\n    const nowTime = Date.now();\r\n    if(userInvisibleIsSupported() &&\r\n        muteUntil &&\r\n        nowTime < muteUntil) {\r\n      throw `Supress notification because mute for ${Math.ceil((muteUntil - nowTime) / 60000)} min`;\r\n    }\r\n\r\n    if(!obj.badge) {\r\n      throw 'No badge?';\r\n    }\r\n  });\r\n\r\n  checksPromise.catch((reason) => {\r\n    log(reason);\r\n  });\r\n\r\n  const notificationPromise = checksPromise.then(() => {\r\n    return Promise.all([getter.get('push_settings'), getter.get('push_lang')])\r\n  }).then((result) => {\r\n    return fireNotification(obj, result[0], result[1]);\r\n  });\r\n\r\n  const closePromise = notificationPromise.catch(() => {\r\n    log('Closing all notifications on push', hasActiveWindows);\r\n    if(userInvisibleIsSupported() || hasActiveWindows) {\r\n      return closeAllNotifications();\r\n    }\r\n\r\n    return ctx.registration.showNotification('Telegram', {\r\n      tag: 'unknown_peer'\r\n    }).then(() => {\r\n      if(hasActiveWindows) {\r\n        return closeAllNotifications();\r\n      }\r\n\r\n      setTimeout(() => closeAllNotifications(), hasActiveWindows ? 0 : 100);\r\n    }).catch((error) => {\r\n      log.error('Show notification error', error);\r\n    });\r\n  });\r\n\r\n  event.waitUntil(closePromise);\r\n});\r\n\r\nctx.addEventListener('notificationclick', (event) => {\r\n  const notification = event.notification;\r\n  log('On notification click: ', notification.tag);\r\n  notification.close();\r\n\r\n  const action = event.action as PushNotificationObject['action'];\r\n  if(action === 'mute1d' && userInvisibleIsSupported()) {\r\n    log('[SW] mute for 1d');\r\n    getter.set('push_mute_until', Date.now() + 86400e3);\r\n    return;\r\n  }\r\n\r\n  const data: PushNotificationObject = notification.data;\r\n  if(!data) {\r\n    return;\r\n  }\r\n\r\n  const promise = ctx.clients.matchAll({\r\n    type: 'window'\r\n  }).then((clientList) => {\r\n    data.action = action;\r\n    pendingNotification = {type: 'push_click', payload: data};\r\n    for(let i = 0; i < clientList.length; i++) {\r\n      const client = clientList[i];\r\n      if('focus' in client) {\r\n        client.focus();\r\n        client.postMessage(pendingNotification);\r\n        pendingNotification = undefined;\r\n        return;\r\n      }\r\n    }\r\n\r\n    if(ctx.clients.openWindow) {\r\n      return getter.get('push_settings').then((settings) => {\r\n        return ctx.clients.openWindow(settings.baseUrl || defaultBaseUrl);\r\n      });\r\n    }\r\n  }).catch((error) => {\r\n    log.error('Clients.matchAll error', error);\r\n  })\r\n\r\n  event.waitUntil(promise);\r\n});\r\n\r\nctx.addEventListener('notificationclose', onCloseNotification);\r\n\r\nlet notifications: Set<Notification> = new Set();\r\nlet pendingNotification: ServiceWorkerPushClickTask;\r\nfunction pushToNotifications(notification: Notification) {\r\n  if(!notifications.has(notification)) {\r\n    notifications.add(notification);\r\n    // @ts-ignore\r\n    notification.onclose = onCloseNotification;\r\n  }\r\n}\r\n\r\nfunction onCloseNotification(event: NotificationEvent) {\r\n  removeFromNotifications(event.notification)\r\n}\r\n\r\nfunction removeFromNotifications(notification: Notification) {\r\n  notifications.delete(notification);\r\n}\r\n\r\nexport function closeAllNotifications() {\r\n  for(const notification of notifications) {\r\n    try {\r\n      notification.close();\r\n    } catch(e) {}\r\n  }\r\n\r\n  let promise: Promise<void>;\r\n  if('getNotifications' in ctx.registration) {\r\n    promise = ctx.registration.getNotifications({}).then((notifications) => {\r\n      for(let i = 0, len = notifications.length; i < len; ++i) {\r\n        try {\r\n          notifications[i].close();\r\n        } catch(e) {}\r\n      }\r\n    }).catch((error) => {\r\n      log.error('Offline register SW error', error);\r\n    });\r\n  } else {\r\n    promise = Promise.resolve();\r\n  }\r\n\r\n  notifications.clear();\r\n\r\n  return promise;\r\n}\r\n\r\nfunction userInvisibleIsSupported() {\r\n  return IS_FIREFOX;\r\n}\r\n\r\nfunction fireNotification(obj: PushNotificationObject, settings: PushStorage['push_settings'], lang: PushStorage['push_lang']) {\r\n  const icon = 'assets/img/logo_filled_rounded.png';\r\n  let title = obj.title || 'Telegram';\r\n  let body = obj.description || '';\r\n  let peerId: string;\r\n\r\n  if(obj.custom) {\r\n    if(obj.custom.channel_id) {\r\n      peerId = '' + -obj.custom.channel_id;\r\n    } else if(obj.custom.chat_id) {\r\n      peerId = '' + -obj.custom.chat_id;\r\n    } else {\r\n      peerId = obj.custom.from_id || '';\r\n    }\r\n  }\r\n\r\n  obj.custom.peerId = '' + peerId;\r\n  let tag = 'peer' + peerId;\r\n\r\n  if(settings && settings.nopreview) {\r\n    title = 'Telegram';\r\n    body = lang.push_message_nopreview;\r\n    tag = 'unknown_peer';\r\n  }\r\n\r\n  log('show notify', title, body, icon, obj);\r\n\r\n  const actions: (Omit<NotificationAction, 'action'> & {action: PushNotificationObject['action']})[] = [{\r\n    action: 'mute1d',\r\n    title: lang.push_action_mute1d\r\n  }/* , {\r\n    action: 'push_settings',\r\n    title: lang.push_action_settings || 'Settings'\r\n  } */];\r\n\r\n  const notificationPromise = ctx.registration.showNotification(title, {\r\n    body,\r\n    icon,\r\n    tag,\r\n    data: obj,\r\n    actions\r\n  });\r\n\r\n  return notificationPromise.then((event) => {\r\n    // @ts-ignore\r\n    if(event && event.notification) {\r\n      // @ts-ignore\r\n      pushToNotifications(event.notification);\r\n    }\r\n  }).catch((error) => {\r\n    log.error('Show notification promise', error);\r\n  });\r\n}\r\n\r\nexport function onPing(task: ServiceWorkerPingTask, event: ExtendableMessageEvent) {\r\n  const client = event.ports && event.ports[0] || event.source;\r\n  const payload = task.payload;\r\n\r\n  if(pendingNotification &&\r\n      client &&\r\n      'postMessage' in client) {\r\n    client.postMessage(pendingNotification, []);\r\n    pendingNotification = undefined;\r\n  }\r\n\r\n  if(payload.lang) {\r\n    getter.set('push_lang', payload.lang);\r\n  }\r\n\r\n  if(payload.settings) {\r\n    getter.set('push_settings', payload.settings);\r\n  }\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport type { Database } from '.';\r\nimport type { IDBIndex } from '../../lib/idb';\r\n\r\nconst DATABASE_STATE: Database<'session' | 'stickerSets' | 'users' | 'chats' | 'messages' | 'dialogs'> = {\r\n  name: 'tweb',\r\n  version: 7,\r\n  stores: [{\r\n    name: 'session'\r\n  }, {\r\n    name: 'stickerSets'\r\n  }, {\r\n    name: 'users'\r\n  }, {\r\n    name: 'chats'\r\n  }, {\r\n    name: 'dialogs',\r\n    // indexes: [\r\n    //   ...(new Array(20 + 2).fill(0)).map((_, idx) => {\r\n    //     const name = `index_${idx}`;\r\n    //     const index: IDBIndex = {\r\n    //       indexName: name,\r\n    //       keyPath: name,\r\n    //       objectParameters: {}\r\n    //     };\r\n\r\n    //     return index\r\n    //   })\r\n    // ]\r\n  }, {\r\n    name: 'messages'\r\n  }]\r\n};\r\n\r\nexport default DATABASE_STATE;\r\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\n                  \n                                   \n          \n\nimport type { Modify, WorkerTaskTemplate, WorkerTaskVoidTemplate } from '../../types';\nimport type { WebPushApiManager } from '../mtproto/webPushApiManager';\nimport type { PushNotificationObject } from './push';\nimport type { ToggleStorageTask } from '../mtproto/mtprotoworker';\nimport type { MyUploadFile } from '../mtproto/apiFileManager';\nimport { logger, LogTypes } from '../logger';\nimport { CancellablePromise } from '../../helpers/cancellablePromise';\nimport { CACHE_ASSETS_NAME, requestCache } from './cache';\nimport onStreamFetch from './stream';\nimport { closeAllNotifications, onPing } from './push';\nimport CacheStorageController from '../cacheStorage';\nimport { IS_SAFARI } from '../../environment/userAgent';\n\nexport const log = logger('SW', LogTypes.Error | LogTypes.Debug | LogTypes.Log | LogTypes.Warn);\nconst ctx = self as any as ServiceWorkerGlobalScope;\nexport const deferredPromises: Map<WindowClient['id'], {[taskId: string]: CancellablePromise<any>}> = new Map();\n\nexport interface RequestFilePartTask extends Modify<WorkerTaskTemplate, {id: string}> {\n  type: 'requestFilePart',\n  payload: {\n    docId: DocId,\n    dcId: number,\n    offset: number,\n    limit: number\n  }\n};\n\nexport interface RequestFilePartTaskResponse extends Modify<WorkerTaskTemplate, {id: string}> {\n  type: 'requestFilePart',\n  payload?: MyUploadFile,\n  originalPayload?: RequestFilePartTask['payload']\n};\n\nexport interface ServiceWorkerPingTask extends WorkerTaskVoidTemplate {\n  type: 'ping',\n  payload: {\n    localNotifications: boolean,\n    lang: {\n      push_action_mute1d: string\n      push_action_settings: string\n      push_message_nopreview: string\n    },\n    settings: WebPushApiManager['settings']\n  }\n};\n\nexport interface ServiceWorkerNotificationsClearTask extends WorkerTaskVoidTemplate {\n  type: 'notifications_clear'\n};\n\nexport interface ServiceWorkerPushClickTask extends WorkerTaskVoidTemplate {\n  type: 'push_click',\n  payload: PushNotificationObject\n};\n\nexport type ServiceWorkerTask = RequestFilePartTaskResponse | ServiceWorkerPingTask | ServiceWorkerNotificationsClearTask | ToggleStorageTask;\n\n                   \nconst taskListeners: {\n  [type in ServiceWorkerTask['type']]: (task: any, event: ExtendableMessageEvent) => void\n} = {\n  notifications_clear: () => {\n    closeAllNotifications();\n  },\n  ping: (task: ServiceWorkerPingTask, event) => {\n    onPing(task, event);\n  },\n  requestFilePart: (task: RequestFilePartTaskResponse, e: ExtendableMessageEvent) => {\n    const windowClient = e.source as WindowClient;\n    const promises = deferredPromises.get(windowClient.id);\n    if(!promises) {\n      return;\n    }\n\n    const promise = promises[task.id];\n    if(promise) {\n      if(task.error) {\n        promise.reject(task.error);\n      } else {\n        promise.resolve(task.payload);\n      }\n  \n      delete promises[task.id];\n    }\n  },\n  toggleStorages: (task: ToggleStorageTask) => {\n    const {enabled, clearWrite} = task.payload;\n    CacheStorageController.toggleStorage(enabled, clearWrite);\n  }\n};\nctx.addEventListener('message', (e) => {\n  const task = e.data as ServiceWorkerTask;\n  const callback = taskListeners[task.type];\n  if(callback) {\n    callback(task, e);\n  }\n});\n          \n\n//const cacheStorage = new CacheStorageController('cachedAssets');\n/* let taskId = 0;\n\nexport function getTaskId() {\n  return taskId;\n}\n\nexport function incrementTaskId() {\n  return taskId++;\n} */\n\nconst onFetch = (event: FetchEvent): void => {\n                \n  if(\n    !IS_SAFARI && \n    event.request.url.indexOf(location.origin + '/') === 0 && \n    event.request.url.match(/\\.(js|css|jpe?g|json|wasm|png|mp3|svg|tgs|ico|woff2?|ttf|webmanifest?)(?:\\?.*)?$/)\n  ) {\n    return event.respondWith(requestCache(event));\n  }\n            \n\n  try {\n    const [, url, scope, params] = /http[:s]+\\/\\/.*?(\\/(.*?)(?:$|\\/(.*)$))/.exec(event.request.url) || [];\n\n    //log.debug('[fetch]:', event);\n  \n    switch(scope) {\n      case 'stream': {\n        onStreamFetch(event, params);\n        break;\n      }\n    }\n  } catch(err) {\n    event.respondWith(new Response('', {\n      status: 500,\n      statusText: 'Internal Server Error',\n    }));\n  }\n};\n\nconst onChangeState = () => {\n  ctx.onfetch = onFetch;\n};\n\nctx.addEventListener('install', (event) => {\n  log('installing');\n  event.waitUntil(ctx.skipWaiting()); // Activate worker immediately\n});\n\nctx.addEventListener('activate', (event) => {\n  log('activating', ctx);\n  event.waitUntil(ctx.caches.delete(CACHE_ASSETS_NAME));\n  event.waitUntil(ctx.clients.claim());\n});\n\nctx.onerror = (error) => {\n  log.error('error:', error);\n};\n\nctx.onunhandledrejection = (error) => {\n  log.error('onunhandledrejection:', error);\n};\n\nctx.onoffline = ctx.ononline = onChangeState;\n\nonChangeState();\n","export default function timeout(delay: number): Promise<Response> {\r\n  return new Promise(((resolve) => {\r\n    setTimeout(() => {\r\n      resolve(new Response('', {\r\n        status: 408,\r\n        statusText: 'Request timed out.',\r\n      }));\r\n    }, delay);\r\n  }));\r\n}\r\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","oldGetScript","u","oldLoadScript","e","queryMap","countMap","chunkId","catch","error","retries","realSrc","message","request","Promise","resolve","setTimeout","cacheBust","Date","now","Modes","test","location","search","indexOf","debug","http","ssl","multipleConnections","asServiceWorker","transport","DEBUG","window","self","USER_AGENT","navigator","userAgent","IS_SAFARI","toLowerCase","vendor","platform","maxTouchPoints","match","IS_FIREFOX","IS_SERVICE_WORKER","ServiceWorkerGlobalScope","IS_WEB_WORKER","WorkerGlobalScope","getWindowClients","clients","matchAll","includeUncontrolled","type","postMessage","listener","args","err","console","notifyServiceWorker","all","then","listeners","length","slice","forEach","_logTimer","bind","dT","toFixed","LogTypes","LOG_LEVELS","None","Error","Warn","Log","Debug","STYLES_SUPPORTED","LOGGER_STYLES","methods","logger","prefix","ignoreDebugReset","style","originalPrefix","originalStyle","log","method","logType","setPrefix","newPrefix","setLevel","level","reduce","acc","v","bindPrefix","CACHE_ASSETS_NAME","isCorrectResponse","response","ok","status","timeoutRace","promise","race","reject","blobConstruct","blobParts","mimeType","blob","Array","isArray","safeMimeType","blobSafeMimeType","Blob","bb","BlobBuilder","blobPart","append","getBlob","constructor","blobSupported","this","isAvailable","getFakeFileWriter","size","saveFileCallback","bytes","Uint8Array","fakeFileWriter","write","part","offset","endOffset","byteLength","newBytes","set","truncate","trim","finalize","saveToStorage","getParts","replaceParts","parts","CacheStorageController","dbName","useStorage","STORAGES","openDatabase","push","openDbPromise","caches","open","delete","entryName","timeoutOperation","cache","deleteAll","save","put","getFile","fileName","saveFile","Response","headers","callback","rejected","timeout","undefined","res","clearTimeout","getFileWriter","fileSize","fakeWriter","static","enabled","clearWrite","map","storage","cacheStorage","CHUNK_CACHED_TIME_HEADER","setInterval","keys","requests","filtered","Map","timestamp","url","has","promises","id","ignoreSearch","ignoreVary","clientId","deferredPromises","find","client","taskId","streams","Stream","info","loadedOffsets","Set","destroy","getId","limitPart","STREAM_CHUNK_UPPER_LIMIT","STREAM_CHUNK_MIDDLE_LIMIT","destroyDebounced","fn","ms","shouldRunFirst","shouldRunLast","waitingTimeout","waitingPromise","hadNewCall","invoke","_resolve","_reject","apply","debounce","_waitingTimeout","requestFilePartFromWorker","alignedOffset","limit","fromPreload","task","payload","docId","dcId","JSON","stringify","windowClient","deferred","uploadFile","add","deferredHelper","isFulfilled","isRejected","notify","notifyAll","lastNotify","addNotifyListener","value","finally","cancel","assign","deferredPromise","bytesPromise","saveChunkToCache","preloadChunks","requestFilePartFromCache","getChunkKey","reader","FileReader","addEventListener","target","result","readBlobAs","readBlobAsArrayBuffer","buffer","readBlobAsUint8Array","requestFilePart","preloadChunk","end","alignOffset","requestRange","range","possibleResponse","statusText","responseForSafariFirstRange","Math","ceil","alignLimit","min","ab","base","deepEqual","x","y","tx","every","IDB","db","object","fromObject","i","safeAssign","name","storageIsAvailable","join","INSTANCES","createNew","createIndexes","os","store","indexNames","from","indexName","deleteIndex","indexes","index","contains","createIndex","keyPath","objectParameters","indexedDB","version","finished","onerror","onsuccess","event","calledNew","onclose","onabort","transaction","close","onversionchange","onupgradeneeded","warn","oldVersion","newVersion","stores","objectStoreNames","objectStore","createObjectStore","instance","preserve","IDBStorage","storeName","idb","create","concat","getObjectStore","clear","idx","mode","perf","performance","onError","onComplete","results","r","waitForTransactionComplete","oncomplete","callbackResult","left","onRequestFinished","getAll","defaultBaseUrl","protocol","hostname","pathname","split","getter","defaults","push_mute_until","push_lang","push_message_nopreview","push_action_mute1d","push_action_settings","push_settings","data","json","hasActiveWindows","checksPromise","muteUntil","clientList","nowTime","userInvisibleIsSupported","badge","reason","notificationPromise","settings","lang","icon","peerId","title","body","description","custom","channel_id","chat_id","from_id","tag","nopreview","actions","action","registration","showNotification","notification","notifications","onCloseNotification","fireNotification","closePromise","closeAllNotifications","waitUntil","pendingNotification","focus","openWindow","baseUrl","getNotifications","len","taskListeners","notifications_clear","ping","ports","source","onPing","toggleStorages","toggleStorage","onFetch","origin","respondWith","file","fetch","clone","replace","random","requestCache","scope","params","exec","header","chunks","ranges","parseRange","parse","decodeURIComponent","stream","onStreamFetch","onChangeState","onfetch","skipWaiting","claim","onunhandledrejection","onoffline","ononline"],"sourceRoot":""}